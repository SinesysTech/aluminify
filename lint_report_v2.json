[{"filePath":"E:\\Development\\aluminify\\app\\api\\atividade\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[398,401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[398,401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  atividadeService,\r\n  AtividadeNotFoundError,\r\n  AtividadeValidationError,\r\n} from '@/backend/services/atividade';\r\nimport { requireAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\n\r\nconst serializeAtividade = (\r\n  atividade: Awaited<ReturnType<typeof atividadeService.getById>>,\r\n) => {\r\n  const a = atividade as any; // Type assertion para contornar incompatibilidade de tipos\r\n  return {\r\n    id: a.id,\r\n    moduloId: a.moduloId || a.modulo_id,\r\n    tipo: a.tipo,\r\n    titulo: a.titulo,\r\n    arquivoUrl: a.arquivoUrl || a.arquivo_url,\r\n    gabaritoUrl: a.gabaritoUrl || a.gabarito_url,\r\n    linkExterno: a.linkExterno || a.link_externo,\r\n    obrigatorio: a.obrigatorio,\r\n    ordemExibicao: a.ordemExibicao || a.ordem_exibicao,\r\n    createdAt: a.createdAt?.toISOString?.() || a.created_at,\r\n    updatedAt: a.updatedAt?.toISOString?.() || a.updated_at,\r\n  };\r\n};\r\n\r\nfunction handleError(error: unknown) {\r\n  if (error instanceof AtividadeNotFoundError) {\r\n    return NextResponse.json({ error: error.message }, { status: 404 });\r\n  }\r\n\r\n  if (error instanceof AtividadeValidationError) {\r\n    return NextResponse.json({ error: error.message }, { status: 400 });\r\n  }\r\n\r\n  console.error(error);\r\n  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n}\r\n\r\ninterface RouteContext {\r\n  params: Promise<{ id: string }>;\r\n}\r\n\r\n// GET - Buscar atividade por ID\r\nexport async function GET(_request: NextRequest, context: RouteContext) {\r\n  try {\r\n    const params = await context.params;\r\n    const atividade = await atividadeService.getById(params.id);\r\n    return NextResponse.json({ data: serializeAtividade(atividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\n// PATCH - Atualizar atividade (especialmente arquivo_url ap√≥s upload direto)\r\nasync function patchHandler(request: AuthenticatedRequest, params: { id: string }) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n\r\n    const atividade = await atividadeService.update(params.id, {\r\n      arquivoUrl: body?.arquivoUrl,\r\n      gabaritoUrl: body?.gabaritoUrl,\r\n      linkExterno: body?.linkExterno,\r\n      titulo: body?.titulo,\r\n      obrigatorio: body?.obrigatorio,\r\n      ordemExibicao: body?.ordemExibicao,\r\n    });\r\n\r\n    return NextResponse.json({ data: serializeAtividade(atividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport async function PATCH(request: NextRequest, context: RouteContext) {\r\n  const params = await context.params;\r\n  return requireAuth((req) => patchHandler(req, params))(request);\r\n}\r\n\r\nasync function deleteHandler(request: AuthenticatedRequest, params: { id: string }) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    await atividadeService.delete(params.id);\r\n    return NextResponse.json({ message: 'Atividade removida com sucesso' });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport async function DELETE(request: NextRequest, context: RouteContext) {\r\n  const params = await context.params;\r\n  return requireAuth((req) => deleteHandler(req, params))(request);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\atividade\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[371,374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[371,374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  atividadeService,\r\n  AtividadeValidationError,\r\n} from '@/backend/services/atividade';\r\nimport { requireAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\n\r\nconst serializeAtividade = (\r\n  atividade: Awaited<ReturnType<typeof atividadeService.getById>>,\r\n) => {\r\n  const a = atividade as any; // Type assertion para contornar incompatibilidade de tipos\r\n  return {\r\n    id: a.id,\r\n    moduloId: a.moduloId || a.modulo_id,\r\n    tipo: a.tipo,\r\n    titulo: a.titulo,\r\n    arquivoUrl: a.arquivoUrl || a.arquivo_url,\r\n    gabaritoUrl: a.gabaritoUrl || a.gabarito_url,\r\n    linkExterno: a.linkExterno || a.link_externo,\r\n    obrigatorio: a.obrigatorio,\r\n    ordemExibicao: a.ordemExibicao || a.ordem_exibicao,\r\n    createdAt: a.createdAt?.toISOString?.() || a.created_at,\r\n    updatedAt: a.updatedAt?.toISOString?.() || a.updated_at,\r\n  };\r\n};\r\n\r\nfunction handleError(error: unknown) {\r\n  if (error instanceof AtividadeValidationError) {\r\n    return NextResponse.json({ error: error.message }, { status: 400 });\r\n  }\r\n\r\n  console.error(error);\r\n  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n}\r\n\r\n// GET - Listar atividades (filtro por modulo_id ou frente_id)\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const moduloId = searchParams.get('modulo_id');\r\n    const frenteId = searchParams.get('frente_id');\r\n\r\n    let atividades;\r\n\r\n    if (moduloId) {\r\n      atividades = await atividadeService.listByModulo(moduloId);\r\n    } else if (frenteId) {\r\n      atividades = await atividadeService.listByFrente(frenteId);\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'modulo_id or frente_id query parameter is required' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({ data: atividades.map(serializeAtividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nasync function postHandler(request: AuthenticatedRequest) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n    const atividade = await atividadeService.create({\r\n      moduloId: body?.modulo_id,\r\n      tipo: body?.tipo,\r\n      titulo: body?.titulo,\r\n      arquivoUrl: body?.arquivo_url,\r\n      gabaritoUrl: body?.gabarito_url,\r\n      linkExterno: body?.link_externo,\r\n      obrigatorio: body?.obrigatorio,\r\n      ordemExibicao: body?.ordem_exibicao,\r\n    });\r\n\r\n    return NextResponse.json({ data: serializeAtividade(atividade) }, { status: 201 });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport const POST = requireAuth(postHandler);","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\auth\\professor\\signup\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2444,2447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2444,2447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getDatabaseClient } from '@/backend/clients/database';\r\n\r\n/**\r\n * POST /api/auth/professor/signup\r\n *\r\n * Cadastro p√∫blico de professor SEM empresa (onboarding).\r\n * - Cria usu√°rio no Supabase Auth via admin client\r\n * - Insere registro em `public.professores` com `empresa_id = null`\r\n * - Atualiza metadata com `role: 'professor'` (sem disparar trigger de insert)\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const email = String(body?.email ?? '').trim().toLowerCase();\r\n    const password = String(body?.password ?? '');\r\n    const fullName = String(body?.fullName ?? '').trim();\r\n\r\n    if (!email || !password || !fullName) {\r\n      return NextResponse.json(\r\n        { error: 'email, password e fullName s√£o obrigat√≥rios' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (password.length < 8) {\r\n      return NextResponse.json(\r\n        { error: 'A senha deve ter pelo menos 8 caracteres' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const adminClient = getDatabaseClient();\r\n\r\n    // 1) Criar usu√°rio sem role no metadata para n√£o exigir empresa_id no trigger de insert\r\n    const { data: createdUser, error: createUserError } = await adminClient.auth.admin.createUser({\r\n      email,\r\n      password,\r\n      email_confirm: true,\r\n      user_metadata: {\r\n        full_name: fullName,\r\n      },\r\n    });\r\n\r\n    if (createUserError || !createdUser.user) {\r\n      if (\r\n        createUserError?.message?.includes('already registered') ||\r\n        createUserError?.message?.includes('already exists') ||\r\n        createUserError?.status === 422\r\n      ) {\r\n        return NextResponse.json({ error: 'Este email j√° est√° cadastrado' }, { status: 400 });\r\n      }\r\n\r\n      return NextResponse.json(\r\n        { error: `Erro ao criar usu√°rio: ${createUserError?.message || 'Erro desconhecido'}` },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    const userId = createdUser.user.id;\r\n\r\n    // 2) Criar registro de professor com empresa_id null (apenas admin consegue)\r\n    const { error: insertProfessorError } = await adminClient.from('professores').insert({\r\n      id: userId,\r\n      email,\r\n      nome_completo: fullName,\r\n      empresa_id: null,\r\n      is_admin: false,\r\n      cpf: null,\r\n      telefone: null,\r\n      biografia: null,\r\n      foto_url: null,\r\n      especialidade: null,\r\n    } as any);\r\n\r\n    if (insertProfessorError) {\r\n      // rollback best-effort\r\n      await adminClient.auth.admin.deleteUser(userId);\r\n      return NextResponse.json(\r\n        { error: `Erro ao criar registro de professor: ${insertProfessorError.message}` },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 3) Atualizar metadata para role professor (n√£o dispara trigger de insert)\r\n    await adminClient.auth.admin.updateUserById(userId, {\r\n      user_metadata: {\r\n        role: 'professor',\r\n        full_name: fullName,\r\n        is_admin: false,\r\n      },\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        user: { id: userId, email, fullName },\r\n        message: 'Conta de professor criada. Agora voc√™ pode cadastrar sua empresa dentro do app.',\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    console.error('Error in professor signup:', error);\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return NextResponse.json({ error: message }, { status: 500 });\r\n  }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\integrations\\google\\callback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2268,2271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2268,2271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/server\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const code = searchParams.get(\"code\")\r\n  const state = searchParams.get(\"state\")\r\n  const error = searchParams.get(\"error\")\r\n\r\n  // Handle errors from Google\r\n  if (error) {\r\n    console.error(\"Google OAuth error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(error)}`, request.url)\r\n    )\r\n  }\r\n\r\n  if (!code || !state) {\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?error=missing_params\", request.url)\r\n    )\r\n  }\r\n\r\n  try {\r\n    // Parse state to get professorId\r\n    const { professorId } = JSON.parse(decodeURIComponent(state))\r\n\r\n    if (!professorId) {\r\n      throw new Error(\"Missing professorId in state\")\r\n    }\r\n\r\n    // Exchange code for tokens\r\n    const clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID\r\n    const clientSecret = process.env.GOOGLE_CLIENT_SECRET\r\n    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL || request.nextUrl.origin}/api/integrations/google/callback`\r\n\r\n    if (!clientId || !clientSecret) {\r\n      throw new Error(\"Google OAuth credentials not configured\")\r\n    }\r\n\r\n    const tokenResponse = await fetch(\"https://oauth2.googleapis.com/token\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: new URLSearchParams({\r\n        code,\r\n        client_id: clientId,\r\n        client_secret: clientSecret,\r\n        redirect_uri: redirectUri,\r\n        grant_type: \"authorization_code\",\r\n      }),\r\n    })\r\n\r\n    if (!tokenResponse.ok) {\r\n      const errorText = await tokenResponse.text()\r\n      console.error(\"Token exchange error:\", errorText)\r\n      throw new Error(\"Failed to exchange code for tokens\")\r\n    }\r\n\r\n    const tokens = await tokenResponse.json()\r\n\r\n    // Calculate token expiry\r\n    const tokenExpiry = new Date(Date.now() + tokens.expires_in * 1000).toISOString()\r\n\r\n    // Save tokens to database\r\n    const supabase = await createClient()\r\n\r\n    const { error: upsertError } = await (supabase as any)\r\n      .from(\"agendamento_integracoes\")\r\n      .upsert({\r\n        professor_id: professorId,\r\n        provider: \"google\",\r\n        access_token: tokens.access_token,\r\n        refresh_token: tokens.refresh_token,\r\n        token_expiry: tokenExpiry,\r\n        updated_at: new Date().toISOString(),\r\n      }, {\r\n        onConflict: \"professor_id\"\r\n      })\r\n\r\n    if (upsertError) {\r\n      console.error(\"Database error:\", upsertError)\r\n      throw new Error(\"Failed to save integration\")\r\n    }\r\n\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?success=google\", request.url)\r\n    )\r\n  } catch (error) {\r\n    console.error(\"Google OAuth callback error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(String(error))}`, request.url)\r\n    )\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\integrations\\zoom\\callback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2419,2422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2419,2422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/server\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const code = searchParams.get(\"code\")\r\n  const state = searchParams.get(\"state\")\r\n  const error = searchParams.get(\"error\")\r\n\r\n  // Handle errors from Zoom\r\n  if (error) {\r\n    console.error(\"Zoom OAuth error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(error)}`, request.url)\r\n    )\r\n  }\r\n\r\n  if (!code || !state) {\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?error=missing_params\", request.url)\r\n    )\r\n  }\r\n\r\n  try {\r\n    // Parse state to get professorId\r\n    const { professorId } = JSON.parse(decodeURIComponent(state))\r\n\r\n    if (!professorId) {\r\n      throw new Error(\"Missing professorId in state\")\r\n    }\r\n\r\n    // Exchange code for tokens\r\n    const clientId = process.env.NEXT_PUBLIC_ZOOM_CLIENT_ID\r\n    const clientSecret = process.env.ZOOM_CLIENT_SECRET\r\n    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL || request.nextUrl.origin}/api/integrations/zoom/callback`\r\n\r\n    if (!clientId || !clientSecret) {\r\n      throw new Error(\"Zoom OAuth credentials not configured\")\r\n    }\r\n\r\n    // Zoom uses Basic auth with client credentials\r\n    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString(\"base64\")\r\n\r\n    const tokenResponse = await fetch(\"https://zoom.us/oauth/token\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Authorization\": `Basic ${basicAuth}`,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: new URLSearchParams({\r\n        code,\r\n        grant_type: \"authorization_code\",\r\n        redirect_uri: redirectUri,\r\n      }),\r\n    })\r\n\r\n    if (!tokenResponse.ok) {\r\n      const errorText = await tokenResponse.text()\r\n      console.error(\"Zoom token exchange error:\", errorText)\r\n      throw new Error(\"Failed to exchange code for tokens\")\r\n    }\r\n\r\n    const tokens = await tokenResponse.json()\r\n\r\n    // Calculate token expiry (Zoom tokens typically last 1 hour)\r\n    const tokenExpiry = new Date(Date.now() + (tokens.expires_in || 3600) * 1000).toISOString()\r\n\r\n    // Save tokens to database\r\n    const supabase = await createClient()\r\n\r\n    const { error: upsertError } = await (supabase as any)\r\n      .from(\"agendamento_integracoes\")\r\n      .upsert({\r\n        professor_id: professorId,\r\n        provider: \"zoom\",\r\n        access_token: tokens.access_token,\r\n        refresh_token: tokens.refresh_token,\r\n        token_expiry: tokenExpiry,\r\n        updated_at: new Date().toISOString(),\r\n      }, {\r\n        onConflict: \"professor_id\"\r\n      })\r\n\r\n    if (upsertError) {\r\n      console.error(\"Database error:\", upsertError)\r\n      throw new Error(\"Failed to save integration\")\r\n    }\r\n\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?success=zoom\", request.url)\r\n    )\r\n  } catch (error) {\r\n    console.error(\"Zoom OAuth callback error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(String(error))}`, request.url)\r\n    )\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\sessao\\finalizar\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[392,395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[392,395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { requireUserAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\nimport {\r\n  sessaoEstudoService,\r\n  SessaoEstudoValidationError,\r\n  SessaoEstudoNotFoundError,\r\n} from '@/backend/services/sessao-estudo';\r\nimport { SessaoEstudo } from '@/types/sessao-estudo';\r\n\r\nfunction serialize(sessao: SessaoEstudo) {\r\n  const s = sessao as any; // Type assertion para compatibilidade\r\n  return {\r\n    id: s.id,\r\n    aluno_id: s.aluno_id || s.alunoId,\r\n    disciplina_id: s.disciplina_id || s.disciplinaId,\r\n    frente_id: s.frente_id || s.frenteId,\r\n    modulo_id: s.modulo_id || s.moduloId,\r\n    atividade_relacionada_id: s.atividade_relacionada_id || s.atividadeRelacionadaId,\r\n    inicio: s.inicio,\r\n    fim: s.fim,\r\n    tempo_total_bruto_segundos: s.tempo_total_bruto_segundos || s.tempoTotalBrutoSegundos,\r\n    tempo_total_liquido_segundos: s.tempo_total_liquido_segundos || s.tempoTotalLiquidoSegundos,\r\n    log_pausas: s.log_pausas || s.logPausas,\r\n    metodo_estudo: s.metodo_estudo || s.metodoEstudo,\r\n    nivel_foco: s.nivel_foco || s.nivelFoco,\r\n    status: s.status,\r\n    created_at: s.created_at || s.createdAt,\r\n  };\r\n}\r\n\r\nasync function handler(request: AuthenticatedRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const sessao = await sessaoEstudoService.finalizarSessao(request.user!.id, {\r\n      sessaoId: body?.sessao_id,\r\n      logPausas: body?.log_pausas ?? [],\r\n      fimIso: body?.fim ?? undefined,\r\n      nivelFoco: body?.nivel_foco ?? undefined,\r\n      status: body?.status ?? undefined,\r\n    });\r\n\r\n    return NextResponse.json({ data: serialize(sessao) });\r\n  } catch (error) {\r\n    if (error instanceof SessaoEstudoValidationError) {\r\n      return NextResponse.json({ error: error.message }, { status: 400 });\r\n    }\r\n    if (error instanceof SessaoEstudoNotFoundError) {\r\n      return NextResponse.json({ error: error.message }, { status: 404 });\r\n    }\r\n\r\n    console.error('[sessao/finalizar]', error);\r\n    return NextResponse.json({ error: 'Erro interno' }, { status: 500 });\r\n  }\r\n}\r\n\r\nexport const PATCH = requireUserAuth(handler);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\backend\\services\\conversation\\conversation.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":338,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9095,9098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9095,9098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9216,9219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9216,9219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from \"@/lib/server\";\r\nimport type {\r\n  Conversation,\r\n  ChatMessage,\r\n  CreateConversationRequest,\r\n  UpdateConversationRequest,\r\n  ListConversationsRequest,\r\n  DeleteConversationRequest,\r\n  GetActiveConversationRequest,\r\n} from \"./conversation.types\";\r\n\r\n// Helper function to map database conversation to Conversation type\r\ninterface ConversationRow {\r\n  id: string;\r\n  user_id: string;\r\n  session_id: string;\r\n  title: string;\r\n  messages?: unknown;\r\n  created_at?: string | null;\r\n  updated_at?: string | null;\r\n  is_active?: boolean | null;\r\n  history?: unknown;\r\n  [key: string]: unknown;\r\n}\r\n\r\nfunction mapConversation(data: ConversationRow): Conversation {\r\n  return {\r\n    ...data,\r\n    messages:\r\n      data.messages &&\r\n      typeof data.messages === \"object\" &&\r\n      Array.isArray(data.messages)\r\n        ? (data.messages as unknown as ChatMessage[])\r\n        : null,\r\n    created_at: data.created_at || \"1970-01-01T00:00:00.000Z\",\r\n    updated_at: data.updated_at || \"1970-01-01T00:00:00.000Z\",\r\n    is_active: data.is_active ?? true,\r\n  } as Conversation;\r\n}\r\n\r\nexport class ConversationService {\r\n  /**\r\n   * Criar nova conversa\r\n   */\r\n  async createConversation(\r\n    request: CreateConversationRequest,\r\n  ): Promise<Conversation> {\r\n    const supabase = await createClient();\r\n\r\n    // Gerar session_id √∫nico\r\n    const sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .insert({\r\n        user_id: request.userId,\r\n        session_id: sessionId,\r\n        title: request.title || \"Nova Conversa\",\r\n        is_active: true, // Nova conversa sempre come√ßa ativa\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error creating conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to create conversation: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      throw new Error(\"Failed to create conversation: No data returned\");\r\n    }\r\n\r\n    console.log(\"[Conversation Service] ‚úÖ Conversation created:\", data.id);\r\n\r\n    type ConversationRow = {\r\n      id: string;\r\n      user_id: string;\r\n      session_id: string;\r\n      title: string;\r\n      messages: unknown;\r\n      is_active: boolean | null;\r\n      created_at: string | null;\r\n      updated_at: string | null;\r\n    };\r\n    return mapConversation(data as ConversationRow);\r\n  }\r\n\r\n  /**\r\n   * Listar conversas do usu√°rio\r\n   */\r\n  async listConversations(\r\n    request: ListConversationsRequest,\r\n  ): Promise<Conversation[]> {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", request.userId)\r\n      .order(\"updated_at\", { ascending: false });\r\n\r\n    if (request.limit) {\r\n      query = query.limit(request.limit);\r\n    }\r\n\r\n    if (request.offset) {\r\n      query = query.range(\r\n        request.offset,\r\n        request.offset + (request.limit || 10) - 1,\r\n      );\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error listing conversations:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to list conversations: ${error.message}`);\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] üìã Listed\",\r\n      data?.length || 0,\r\n      \"conversations\",\r\n    );\r\n    return (data || []).map(mapConversation);\r\n  }\r\n\r\n  /**\r\n   * Obter conversa ativa do usu√°rio\r\n   */\r\n  async getActiveConversation(\r\n    request: GetActiveConversationRequest,\r\n  ): Promise<Conversation | null> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", request.userId)\r\n      .eq(\"is_active\", true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error getting active conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to get active conversation: ${error.message}`);\r\n    }\r\n\r\n    if (data) {\r\n      console.log(\"[Conversation Service] ‚úÖ Active conversation:\", data.id);\r\n      return mapConversation(data);\r\n    } else {\r\n      console.log(\"[Conversation Service] ‚ÑπÔ∏è  No active conversation found\");\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obter conversa por ID\r\n   */\r\n  async getConversationById(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<Conversation | null> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"id\", id)\r\n      .eq(\"user_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error getting conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to get conversation: ${error.message}`);\r\n    }\r\n\r\n    return data ? mapConversation(data) : null;\r\n  }\r\n\r\n  /**\r\n   * Atualizar conversa\r\n   */\r\n  async updateConversation(\r\n    request: UpdateConversationRequest,\r\n  ): Promise<Conversation> {\r\n    const supabase = await createClient();\r\n\r\n    const updates: Record<string, unknown> = {};\r\n\r\n    if (request.title !== undefined && request.title !== null) {\r\n      const trimmedTitle = String(request.title).trim();\r\n      if (trimmedTitle.length > 0) {\r\n        updates.title = trimmedTitle;\r\n      } else {\r\n        throw new Error(\"Title cannot be empty\");\r\n      }\r\n    }\r\n\r\n    if (request.is_active !== undefined) {\r\n      updates.is_active = Boolean(request.is_active);\r\n    }\r\n\r\n    // Verificar se h√° campos para atualizar\r\n    if (Object.keys(updates).length === 0) {\r\n      console.log(\r\n        \"[Conversation Service] No fields to update, returning existing conversation\",\r\n      );\r\n      const existing = await this.getConversationById(\r\n        request.id,\r\n        request.userId,\r\n      );\r\n      if (!existing) {\r\n        throw new Error(\"Conversation not found\");\r\n      }\r\n      return existing;\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] Updating conversation:\",\r\n      request.id,\r\n      \"with:\",\r\n      updates,\r\n    );\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .update(updates)\r\n      .eq(\"id\", request.id)\r\n      .eq(\"user_id\", request.userId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error updating conversation:\",\r\n        error,\r\n      );\r\n      console.error(\r\n        \"[Conversation Service] Error details:\",\r\n        JSON.stringify(error, null, 2),\r\n      );\r\n      throw new Error(`Failed to update conversation: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      console.error(\"[Conversation Service] No data returned after update\");\r\n      throw new Error(\"Conversation not found or unauthorized\");\r\n    }\r\n\r\n    console.log(\"[Conversation Service] ‚úÖ Conversation updated:\", data.id);\r\n    return mapConversation(data);\r\n  }\r\n\r\n  /**\r\n   * Marcar conversa como ativa (desmarca outras)\r\n   */\r\n  async setActiveConversation(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<Conversation> {\r\n    return this.updateConversation({\r\n      id,\r\n      userId,\r\n      is_active: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletar conversa\r\n   */\r\n  async deleteConversation(request: DeleteConversationRequest): Promise<void> {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .delete()\r\n      .eq(\"id\", request.id)\r\n      .eq(\"user_id\", request.userId);\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error deleting conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to delete conversation: ${error.message}`);\r\n    }\r\n\r\n    console.log(\"[Conversation Service] üóëÔ∏è  Conversation deleted:\", request.id);\r\n  }\r\n\r\n  /**\r\n   * Obter ou criar conversa ativa\r\n   * Se n√£o houver conversa ativa, cria uma nova\r\n   */\r\n  async getOrCreateActiveConversation(userId: string): Promise<Conversation> {\r\n    // Tentar obter conversa ativa\r\n    let active = await this.getActiveConversation({ userId });\r\n\r\n    // Se n√£o houver, criar nova\r\n    if (!active) {\r\n      console.log(\r\n        \"[Conversation Service] No active conversation, creating new one\",\r\n      );\r\n      active = await this.createConversation({ userId });\r\n    }\r\n\r\n    return active;\r\n  }\r\n\r\n  /**\r\n   * Atualiza o hist√≥rico completo da conversa (JSONB)\r\n   */\r\n  async updateConversationHistory(\r\n    conversationId: string,\r\n    userId: string,\r\n    history: ChatMessage[],\r\n  ): Promise<void> {\r\n    const supabase = await createClient();\r\n\r\n    // `history` √© persistido em JSONB. O tipo `Json` do Supabase √© bem estrito e n√£o aceita `ChatMessage[]` diretamente.\r\n    // Em runtime isso √© serializ√°vel, ent√£o fazemos cast controlado para evitar ru√≠do de typecheck.\r\n    const payload = {\r\n      conversation_id: conversationId,\r\n      user_id: userId,\r\n      history: history as any,\r\n    };\r\n\r\n    const { error } = await supabase\r\n      .from(\"chat_conversation_history\")\r\n      .upsert(payload as any, { onConflict: \"conversation_id\" });\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error updating conversation history:\",\r\n        error,\r\n      );\r\n      throw new Error(\r\n        `Failed to update conversation history: ${error.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] ‚úÖ Conversation history saved:\",\r\n      conversationId,\r\n    );\r\n  }\r\n\r\n  async getConversationHistory(\r\n    conversationId: string,\r\n    userId: string,\r\n  ): Promise<ChatMessage[]> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversation_history\")\r\n      .select(\"history\")\r\n      .eq(\"conversation_id\", conversationId)\r\n      .eq(\"user_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error fetching conversation history:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to fetch conversation history: ${error.message}`);\r\n    }\r\n\r\n    if (Array.isArray(data?.history)) {\r\n      return data?.history as unknown as ChatMessage[];\r\n    }\r\n\r\n    return [];\r\n  }\r\n}\r\n\r\nexport const conversationService = new ConversationService();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\backend\\services\\cronograma\\cronograma.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2416,2419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2416,2419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1953,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1953,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[67416,67419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[67416,67419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  getDatabaseClient,\r\n  clearDatabaseClientCache,\r\n} from \"@/backend/clients/database\";\r\nimport type { Database } from \"@/lib/database.types\";\r\nimport {\r\n  GerarCronogramaInput,\r\n  GerarCronogramaResult,\r\n  AulaCompleta,\r\n  FrenteDistribuicao,\r\n  SemanaInfo,\r\n  ItemDistribuicao,\r\n  CronogramaSemanasDias,\r\n  AtualizarDistribuicaoDiasInput,\r\n  RecalcularDatasResult,\r\n  SemanaEstatisticas,\r\n  EstatisticasSemanasResult,\r\n  CronogramaDetalhado,\r\n  FeriasPeriodo,\r\n} from \"./cronograma.types\";\r\nimport {\r\n  FrenteValidacaoResult,\r\n  FrenteStatsAccumulator,\r\n  FrenteCountAccumulator,\r\n  FrenteComCursoDiferenteAccumulator,\r\n  AulaQueryResult,\r\n  ModuloQueryResult,\r\n  DiagnosticoFrente,\r\n  FrenteInfo,\r\n  ModuloInfo,\r\n  ModuloSelecionadoQueryResult,\r\n  FrenteQueryResult,\r\n  getFirst,\r\n  getDisciplinaNome,\r\n  getFrenteInfo,\r\n  getModuloInfo,\r\n} from \"./cronograma.query-types\";\r\nimport {\r\n  CronogramaValidationError,\r\n  CronogramaTempoInsuficienteError,\r\n  CronogramaConflictError,\r\n} from \"./errors\";\r\n\r\nconst TEMPO_PADRAO_MINUTOS = 10;\r\nconst FATOR_MULTIPLICADOR = 1.5;\r\n\r\n// Helper para logs que s√≥ aparecem em desenvolvimento\r\nconst logDebug = (...args: unknown[]) => {\r\n  if (process.env.NODE_ENV === \"development\") {\r\n    console.log(...args);\r\n  }\r\n};\r\n\r\nconst logError = (...args: unknown[]) => {\r\n  console.error(...args);\r\n};\r\n\r\n// Helper to map database row to CronogramaDetalhado\r\nfunction mapToCronogramaDetalhado(\r\n  row: Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Row\"],\r\n): CronogramaDetalhado {\r\n  return {\r\n    id: row.id,\r\n    aluno_id: row.aluno_id,\r\n    curso_alvo_id: row.curso_alvo_id,\r\n    nome: row.nome ?? \"Meu Cronograma\",\r\n    data_inicio: row.data_inicio,\r\n    data_fim: row.data_fim,\r\n    dias_estudo_semana: row.dias_estudo_semana,\r\n    horas_estudo_dia: row.horas_estudo_dia,\r\n    periodos_ferias: (row.periodos_ferias as unknown as FeriasPeriodo[]) ?? [],\r\n    prioridade_minima: row.prioridade_minima,\r\n    modalidade_estudo: row.modalidade_estudo as \"paralelo\" | \"sequencial\",\r\n    disciplinas_selecionadas:\r\n      (row.disciplinas_selecionadas as unknown as string[]) ?? [],\r\n    ordem_frentes_preferencia:\r\n      (row.ordem_frentes_preferencia as unknown as string[]) ?? null,\r\n    modulos_selecionados:\r\n      (row.modulos_selecionados as unknown as string[]) ?? null,\r\n    excluir_aulas_concluidas: row.excluir_aulas_concluidas,\r\n    velocidade_reproducao: (row as any).velocidade_reproducao ?? 1.0,\r\n    created_at: row.created_at ?? new Date().toISOString(),\r\n    updated_at: row.updated_at ?? new Date().toISOString(),\r\n  };\r\n}\r\n\r\nexport class CronogramaService {\r\n  async gerarCronograma(\r\n    input: GerarCronogramaInput,\r\n    userId: string,\r\n    userEmail?: string,\r\n    empresaId?: string,\r\n  ): Promise<GerarCronogramaResult> {\r\n    logDebug(\"[CronogramaService] Iniciando gera√ß√£o de cronograma:\", {\r\n      aluno_id: input.aluno_id,\r\n      userId,\r\n      userEmail,\r\n      data_inicio: input.data_inicio,\r\n      data_fim: input.data_fim,\r\n      disciplinas_count: input.disciplinas_ids?.length || 0,\r\n    });\r\n\r\n    // Valida√ß√µes b√°sicas\r\n    if (!input.aluno_id || !input.data_inicio || !input.data_fim) {\r\n      throw new CronogramaValidationError(\r\n        \"Campos obrigat√≥rios: aluno_id, data_inicio, data_fim\",\r\n      );\r\n    }\r\n\r\n    // Verificar se aluno_id corresponde ao usu√°rio autenticado\r\n    if (input.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Voc√™ s√≥ pode criar cronogramas para si mesmo\",\r\n      );\r\n    }\r\n\r\n    // Validar datas\r\n    const dataInicio = new Date(input.data_inicio);\r\n    const dataFim = new Date(input.data_fim);\r\n\r\n    if (isNaN(dataInicio.getTime()) || isNaN(dataFim.getTime())) {\r\n      throw new CronogramaValidationError(\"Datas inv√°lidas\");\r\n    }\r\n\r\n    if (dataFim <= dataInicio) {\r\n      throw new CronogramaValidationError(\r\n        \"data_fim deve ser posterior a data_inicio\",\r\n      );\r\n    }\r\n\r\n    const client = getDatabaseClient();\r\n\r\n    // Resolver empresa_id (prioriza metadata; faz fallback para tabela alunos)\r\n    const resolvedEmpresaId = await this.resolveEmpresaId(\r\n      client,\r\n      userId,\r\n      empresaId,\r\n    );\r\n    if (!resolvedEmpresaId) {\r\n      throw new CronogramaValidationError(\r\n        \"Empresa n√£o encontrada para o usu√°rio autenticado (empresa_id ausente).\",\r\n      );\r\n    }\r\n\r\n    // Verificar se aluno_id corresponde ao usu√°rio autenticado, se n√£o existir, criar\r\n    await this.ensureAlunoExists(client, userId, userEmail, resolvedEmpresaId);\r\n\r\n    // Deletar cronograma anterior do aluno (se existir)\r\n    await this.deletarCronogramaAnterior(client, userId);\r\n\r\n    const excluirConcluidas = input.excluir_aulas_concluidas !== false;\r\n    const aulasConcluidas = excluirConcluidas\r\n      ? await this.buscarAulasConcluidas(\r\n          client,\r\n          input.aluno_id,\r\n          input.curso_alvo_id,\r\n        )\r\n      : new Set<string>();\r\n\r\n    // ============================================\r\n    // ETAPA 1: C√°lculo de Capacidade\r\n    // ============================================\r\n\r\n    const semanas = this.calcularSemanas(\r\n      dataInicio,\r\n      dataFim,\r\n      input.ferias,\r\n      input.horas_dia,\r\n      input.dias_semana,\r\n    );\r\n    const capacidadeTotal = semanas\r\n      .filter((s) => !s.is_ferias)\r\n      .reduce((acc, s) => acc + s.capacidade_minutos, 0);\r\n\r\n    // ============================================\r\n    // ETAPA 2: Busca e Filtragem de Aulas\r\n    // ============================================\r\n\r\n    const aulasBase = await this.buscarAulas(\r\n      client,\r\n      input.disciplinas_ids,\r\n      input.prioridade_minima,\r\n      input.curso_alvo_id,\r\n      input.modulos_ids,\r\n    );\r\n\r\n    const aulas = excluirConcluidas\r\n      ? aulasBase.filter((aula) => !aulasConcluidas.has(aula.id))\r\n      : aulasBase;\r\n\r\n    if (!aulas.length) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula dispon√≠vel ap√≥s aplicar os filtros selecionados.\",\r\n      );\r\n    }\r\n\r\n    // Validar que todas as frentes das disciplinas selecionadas t√™m aulas\r\n    // Buscar todas as frentes das disciplinas selecionadas para valida√ß√£o\r\n    let validacaoFrentesQuery = client\r\n      .from(\"frentes\")\r\n      .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n      .in(\"disciplina_id\", input.disciplinas_ids);\r\n\r\n    if (input.curso_alvo_id) {\r\n      validacaoFrentesQuery = validacaoFrentesQuery.eq(\r\n        \"curso_id\",\r\n        input.curso_alvo_id,\r\n      );\r\n    }\r\n\r\n    const { data: todasFrentes, error: frentesError } =\r\n      await validacaoFrentesQuery;\r\n\r\n    // Type assertion needed: Supabase doesn't infer join types automatically\r\n    // The query joins frentes with disciplinas table to get disciplina name\r\n    type FrenteWithDisciplina = {\r\n      id: string;\r\n      nome: string;\r\n      disciplina_id: string;\r\n      curso_id: string;\r\n      disciplinas: { nome: string } | null;\r\n    };\r\n\r\n    if (!frentesError && todasFrentes && todasFrentes.length > 0) {\r\n      const typedFrentes = todasFrentes as unknown as FrenteWithDisciplina[];\r\n      const frentesComAulas = new Set(aulas.map((a) => a.frente_id));\r\n      const frentesSemAulas = typedFrentes.filter(\r\n        (f) => !frentesComAulas.has(f.id),\r\n      );\r\n\r\n      if (frentesSemAulas.length > 0) {\r\n        console.warn(\r\n          \"[CronogramaService] ‚ö†Ô∏è Frentes sem aulas no cronograma gerado:\",\r\n          {\r\n            total_frentes_sem_aulas: frentesSemAulas.length,\r\n            total_frentes_esperadas: todasFrentes.length,\r\n            total_frentes_com_aulas: frentesComAulas.size,\r\n            frentes: frentesSemAulas.map((f: FrenteValidacaoResult) => ({\r\n              id: f.id,\r\n              nome: f.nome,\r\n              disciplina: getDisciplinaNome(f.disciplinas) || \"Desconhecida\",\r\n              curso_id: f.curso_id,\r\n            })),\r\n            motivo_possivel: excluirConcluidas\r\n              ? \"Aulas podem ter sido exclu√≠das por estarem conclu√≠das ou n√£o terem prioridade suficiente\"\r\n              : \"Aulas podem n√£o ter prioridade suficiente ou m√≥dulos n√£o foram selecionados\",\r\n            prioridade_minima: input.prioridade_minima,\r\n            modulos_selecionados: input.modulos_ids?.length || 0,\r\n          },\r\n        );\r\n      } else {\r\n        console.log(\r\n          \"[CronogramaService] ‚úÖ Todas as frentes selecionadas t√™m aulas no cronograma\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // ============================================\r\n    // ETAPA 3: C√°lculo de Custo Real\r\n    // ============================================\r\n\r\n    // Velocidade de reprodu√ß√£o padr√£o: 1.00x\r\n    const velocidadeReproducao = input.velocidade_reproducao ?? 1.0;\r\n\r\n    // Tempo de aula ajustado pela velocidade: se assistir em 1.5x, o tempo real √© reduzido\r\n    // Tempo de estudo (anota√ß√µes/exerc√≠cios) √© calculado sobre o tempo de aula ajustado\r\n    const aulasComCusto = aulas.map((aula) => {\r\n      const tempoOriginal = aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS;\r\n      const tempoAulaAjustado = tempoOriginal / velocidadeReproducao;\r\n      // Custo = tempo de aula (ajustado) + tempo de estudo (calculado sobre o tempo ajustado)\r\n      const custo = tempoAulaAjustado * FATOR_MULTIPLICADOR;\r\n      return {\r\n        ...aula,\r\n        custo,\r\n      };\r\n    });\r\n\r\n    const custoTotalNecessario = aulasComCusto.reduce(\r\n      (acc, aula) => acc + aula.custo,\r\n      0,\r\n    );\r\n\r\n    // ============================================\r\n    // ETAPA 4: Verifica√ß√£o de Viabilidade\r\n    // ============================================\r\n\r\n    if (custoTotalNecessario > capacidadeTotal) {\r\n      const horasNecessarias = custoTotalNecessario / 60;\r\n      const horasDisponiveis = capacidadeTotal / 60;\r\n      const semanasUteis = semanas.filter((s) => !s.is_ferias).length;\r\n      const horasDiaNecessarias =\r\n        horasNecessarias / (semanasUteis * input.dias_semana);\r\n\r\n      throw new CronogramaTempoInsuficienteError(\"Tempo insuficiente\", {\r\n        horas_necessarias: Math.ceil(horasNecessarias),\r\n        horas_disponiveis: Math.ceil(horasDisponiveis),\r\n        horas_dia_necessarias: Math.ceil(horasDiaNecessarias * 10) / 10,\r\n        horas_dia_atual: input.horas_dia,\r\n      });\r\n    }\r\n\r\n    // ============================================\r\n    // ETAPA 5: Algoritmo de Distribui√ß√£o\r\n    // ============================================\r\n\r\n    const itens = this.distribuirAulas(\r\n      aulasComCusto,\r\n      semanas,\r\n      input.modalidade,\r\n      input.ordem_frentes_preferencia,\r\n    );\r\n\r\n    if (itens.length === 0) {\r\n      console.error(\r\n        \"[CronogramaService] Nenhum item foi criado na distribui√ß√£o!\",\r\n        {\r\n          totalAulas: aulasComCusto.length,\r\n          totalSemanas: semanas.length,\r\n          semanasUteis: semanas.filter((s) => !s.is_ferias).length,\r\n          modalidade: input.modalidade,\r\n        },\r\n      );\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula foi distribu√≠da. Verifique se h√° semanas √∫teis dispon√≠veis e se as aulas selecionadas s√£o compat√≠veis com o per√≠odo.\",\r\n      );\r\n    }\r\n\r\n    logDebug(\"[CronogramaService] Distribui√ß√£o conclu√≠da:\", {\r\n      totalItens: itens.length,\r\n      semanasComItens: new Set(itens.map((i) => i.semana_numero)).size,\r\n    });\r\n\r\n    // ============================================\r\n    // ETAPA 6: Persist√™ncia\r\n    // ============================================\r\n\r\n    const cronograma = await this.persistirCronograma(\r\n      client,\r\n      input,\r\n      itens,\r\n      resolvedEmpresaId,\r\n    );\r\n\r\n    const semanasUteis = semanas.filter((s) => !s.is_ferias);\r\n\r\n    return {\r\n      success: true,\r\n      cronograma,\r\n      estatisticas: {\r\n        total_aulas: aulas.length,\r\n        total_semanas: semanas.length,\r\n        semanas_uteis: semanasUteis.length,\r\n        capacidade_total_minutos: capacidadeTotal,\r\n        custo_total_minutos: custoTotalNecessario,\r\n        frentes_distribuidas: new Set(aulas.map((a) => a.frente_id)).size,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async deletarCronogramaAnterior(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n  ): Promise<void> {\r\n    console.log(\r\n      \"[CronogramaService] Verificando e deletando cronograma anterior...\",\r\n    );\r\n\r\n    // Buscar cronograma existente do aluno\r\n    const { data: cronogramaExistente, error: selectError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id\")\r\n      .eq(\"aluno_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (selectError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao verificar cronograma existente:\",\r\n        selectError,\r\n      );\r\n      // N√£o lan√ßar erro, apenas logar - pode n√£o existir cronograma anterior\r\n      return;\r\n    }\r\n\r\n    if (cronogramaExistente) {\r\n      console.log(\r\n        \"[CronogramaService] Deletando cronograma anterior:\",\r\n        cronogramaExistente.id,\r\n      );\r\n\r\n      // Deletar cronograma (cascade vai deletar os itens automaticamente devido ao ON DELETE CASCADE)\r\n      const { error: deleteError } = await client\r\n        .from(\"cronogramas\")\r\n        .delete()\r\n        .eq(\"id\", cronogramaExistente.id);\r\n\r\n      if (deleteError) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao deletar cronograma anterior:\",\r\n          deleteError,\r\n        );\r\n        throw new Error(\r\n          `Erro ao deletar cronograma anterior: ${deleteError.message}`,\r\n        );\r\n      }\r\n\r\n      console.log(\r\n        \"[CronogramaService] Cronograma anterior deletado com sucesso\",\r\n      );\r\n    } else {\r\n      console.log(\"[CronogramaService] Nenhum cronograma anterior encontrado\");\r\n    }\r\n  }\r\n\r\n  private async ensureAlunoExists(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n    userEmail?: string,\r\n    empresaId?: string,\r\n  ): Promise<void> {\r\n    // Verificar se o aluno j√° existe\r\n    const { data: alunoExistente, error: selectError } = await client\r\n      .from(\"alunos\")\r\n      .select(\"id\")\r\n      .eq(\"id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (selectError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao verificar aluno:\",\r\n        selectError,\r\n      );\r\n      throw new Error(`Erro ao verificar aluno: ${selectError.message}`);\r\n    }\r\n\r\n    // Se o aluno n√£o existe, criar um registro b√°sico\r\n    if (!alunoExistente) {\r\n      console.log(\r\n        \"[CronogramaService] Aluno n√£o encontrado, criando registro...\",\r\n      );\r\n\r\n      if (!userEmail) {\r\n        throw new CronogramaValidationError(\r\n          \"Email do usu√°rio √© necess√°rio para criar o registro de aluno\",\r\n        );\r\n      }\r\n\r\n      if (!empresaId) {\r\n        throw new CronogramaValidationError(\r\n          \"Empresa n√£o encontrada para criar o registro de aluno (empresa_id ausente).\",\r\n        );\r\n      }\r\n\r\n      const { error: insertError } = await client.from(\"alunos\").insert({\r\n        id: userId,\r\n        email: userEmail,\r\n        empresa_id: empresaId,\r\n      });\r\n\r\n      if (insertError) {\r\n        console.error(\"[CronogramaService] Erro ao criar aluno:\", insertError);\r\n        throw new Error(\r\n          `Erro ao criar registro de aluno: ${insertError.message}`,\r\n        );\r\n      }\r\n\r\n      console.log(\"[CronogramaService] Registro de aluno criado com sucesso\");\r\n    }\r\n  }\r\n\r\n  private async resolveEmpresaId(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n    empresaId?: string,\r\n  ): Promise<string | undefined> {\r\n    if (empresaId) return empresaId;\r\n\r\n    const { data, error } = await client\r\n      .from(\"alunos\")\r\n      .select(\"empresa_id\")\r\n      .eq(\"id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao resolver empresa_id do aluno:\",\r\n        error,\r\n      );\r\n      return undefined;\r\n    }\r\n\r\n    return (data?.empresa_id as string | null | undefined) ?? undefined;\r\n  }\r\n\r\n  private calcularSemanas(\r\n    dataInicio: Date,\r\n    dataFim: Date,\r\n    ferias: Array<{ inicio: string; fim: string }>,\r\n    horasDia: number,\r\n    diasSemana: number,\r\n  ): SemanaInfo[] {\r\n    const semanas: SemanaInfo[] = [];\r\n    const inicio = new Date(dataInicio);\r\n    let semanaNumero = 1;\r\n\r\n    while (inicio <= dataFim) {\r\n      const fimSemana = new Date(inicio);\r\n      fimSemana.setDate(fimSemana.getDate() + 6); // 7 dias (0-6)\r\n\r\n      // Verificar se a semana cai em per√≠odo de f√©rias\r\n      let isFerias = false;\r\n      for (const periodo of ferias || []) {\r\n        const inicioFerias = new Date(periodo.inicio);\r\n        const fimFerias = new Date(periodo.fim);\r\n        if (\r\n          (inicio >= inicioFerias && inicio <= fimFerias) ||\r\n          (fimSemana >= inicioFerias && fimSemana <= fimFerias) ||\r\n          (inicio <= inicioFerias && fimSemana >= fimFerias)\r\n        ) {\r\n          isFerias = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      semanas.push({\r\n        numero: semanaNumero,\r\n        data_inicio: new Date(inicio),\r\n        data_fim: fimSemana > dataFim ? new Date(dataFim) : fimSemana,\r\n        is_ferias: isFerias,\r\n        capacidade_minutos: isFerias ? 0 : horasDia * diasSemana * 60,\r\n      });\r\n\r\n      inicio.setDate(inicio.getDate() + 7);\r\n      semanaNumero++;\r\n    }\r\n\r\n    return semanas;\r\n  }\r\n\r\n  private async buscarAulas(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    disciplinasIds: string[],\r\n    prioridadeMinima: number,\r\n    cursoId?: string,\r\n    modulosSelecionados?: string[],\r\n  ): Promise<AulaCompleta[]> {\r\n    const prioridadeMinimaEfetiva = Math.max(1, prioridadeMinima ?? 1);\r\n    console.log(\r\n      \"üîç [CronogramaService] ===========================================\",\r\n    );\r\n    console.log(\"üîç [CronogramaService] INICIANDO BUSCA DE AULAS\");\r\n    console.log(\"üîç [CronogramaService] Disciplinas:\", disciplinasIds);\r\n    console.log(\"üîç [CronogramaService] Curso ID:\", cursoId);\r\n    console.log(\r\n      \"üîç [CronogramaService] M√≥dulos selecionados:\",\r\n      modulosSelecionados?.length || 0,\r\n    );\r\n    console.log(\r\n      \"üîç [CronogramaService] Prioridade m√≠nima:\",\r\n      prioridadeMinimaEfetiva,\r\n    );\r\n    console.log(\r\n      \"üîç [CronogramaService] ===========================================\",\r\n    );\r\n\r\n    // Buscar frentes das disciplinas selecionadas (com informa√ß√µes completas para valida√ß√£o)\r\n    console.log(\r\n      \"üîç [CronogramaService] ========== DIAGN√ìSTICO DE FRENTES ==========\",\r\n    );\r\n    console.log(\"[CronogramaService] Buscando frentes para:\", {\r\n      disciplinas_ids: disciplinasIds,\r\n      curso_id: cursoId,\r\n      total_disciplinas: disciplinasIds.length,\r\n    });\r\n\r\n    // PRIMEIRO: Buscar TODAS as frentes das disciplinas (sem filtro de curso) para diagn√≥stico\r\n    const { data: todasFrentesSemFiltro, error: todasFrentesError } =\r\n      await client\r\n        .from(\"frentes\")\r\n        .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n        .in(\"disciplina_id\", disciplinasIds);\r\n\r\n    if (todasFrentesError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar todas as frentes (diagn√≥stico):\",\r\n        todasFrentesError,\r\n      );\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] TOTAL de frentes encontradas (SEM filtro de curso):\",\r\n        todasFrentesSemFiltro?.length || 0,\r\n      );\r\n\r\n      // Agrupar por disciplina e curso\r\n      const frentesPorDisciplinaECurso = new Map<\r\n        string,\r\n        { disciplina: string; frentes: FrenteInfo[] }\r\n      >();\r\n      todasFrentesSemFiltro?.forEach((frente: FrenteValidacaoResult) => {\r\n        const discId = frente.disciplina_id;\r\n        const discNome =\r\n          getDisciplinaNome(frente.disciplinas) || \"Desconhecida\";\r\n        const key = `${discId}_${frente.curso_id || \"sem-curso\"}`;\r\n\r\n        if (!frentesPorDisciplinaECurso.has(key)) {\r\n          frentesPorDisciplinaECurso.set(key, {\r\n            disciplina: discNome,\r\n            frentes: [],\r\n          });\r\n        }\r\n        frentesPorDisciplinaECurso.get(key)!.frentes.push({\r\n          id: frente.id,\r\n          nome: frente.nome,\r\n          curso_id: frente.curso_id,\r\n        });\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] Frentes agrupadas por disciplina e curso:\",\r\n        Array.from(frentesPorDisciplinaECurso.entries()).map(([key, info]) => ({\r\n          disciplina: info.disciplina,\r\n          curso_id:\r\n            key.split(\"_\")[1] === \"sem-curso\" ? null : key.split(\"_\")[1],\r\n          total_frentes: info.frentes.length,\r\n          frentes: info.frentes.map((f: FrenteInfo) => f.nome),\r\n        })),\r\n      );\r\n\r\n      // Verificar frentes do curso selecionado\r\n      if (cursoId) {\r\n        const frentesDoCurso =\r\n          todasFrentesSemFiltro?.filter(\r\n            (f: FrenteValidacaoResult) => f.curso_id === cursoId,\r\n          ) || [];\r\n        console.log(\"[CronogramaService] Frentes do curso selecionado:\", {\r\n          curso_id: cursoId,\r\n          total: frentesDoCurso.length,\r\n          frentes: frentesDoCurso.map((f: FrenteValidacaoResult) => ({\r\n            id: f.id,\r\n            nome: f.nome,\r\n            disciplina: getDisciplinaNome(f.disciplinas),\r\n          })),\r\n        });\r\n\r\n        // Verificar se h√° frentes sem curso_id\r\n        const frentesSemCurso =\r\n          todasFrentesSemFiltro?.filter(\r\n            (f: FrenteValidacaoResult) => !f.curso_id,\r\n          ) || [];\r\n        if (frentesSemCurso.length > 0) {\r\n          console.warn(\r\n            \"[CronogramaService] ‚ö†Ô∏è Frentes SEM curso_id encontradas:\",\r\n            frentesSemCurso.map((f: FrenteValidacaoResult) => ({\r\n              id: f.id,\r\n              nome: f.nome,\r\n              disciplina: getDisciplinaNome(f.disciplinas),\r\n            })),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // AGORA: Buscar frentes com filtro de curso (query real)\r\n    let frentesQuery = client\r\n      .from(\"frentes\")\r\n      .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n      .in(\"disciplina_id\", disciplinasIds);\r\n\r\n    if (cursoId) {\r\n      frentesQuery = frentesQuery.eq(\"curso_id\", cursoId);\r\n    }\r\n\r\n    const { data: frentesData, error: frentesError } = await frentesQuery;\r\n\r\n    if (frentesError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar frentes:\",\r\n        frentesError,\r\n      );\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar frentes: ${frentesError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"üîç [CronogramaService] RESULTADO DA BUSCA DE FRENTES:\", {\r\n      total_encontradas: frentesData?.length || 0,\r\n      frentes: frentesData?.map((f: FrenteValidacaoResult) => ({\r\n        id: f.id,\r\n        nome: f.nome,\r\n        disciplina_id: f.disciplina_id,\r\n        curso_id: f.curso_id,\r\n        disciplina_nome: Array.isArray(f.disciplinas)\r\n          ? f.disciplinas[0]?.nome\r\n          : f.disciplinas?.nome,\r\n      })),\r\n    });\r\n\r\n    const frenteIds = frentesData?.map((f) => f.id) || [];\r\n    const frentesPorDisciplina = new Map<string, string[]>();\r\n\r\n    // Agrupar frentes por disciplina para valida√ß√£o\r\n    frentesData?.forEach((frente: FrenteValidacaoResult) => {\r\n      const discId = frente.disciplina_id;\r\n      if (discId && !frentesPorDisciplina.has(discId)) {\r\n        frentesPorDisciplina.set(discId, []);\r\n      }\r\n      if (discId) {\r\n        frentesPorDisciplina.get(discId)!.push(frente.nome);\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Frentes encontradas por disciplina (COM filtro):\",\r\n      Array.from(frentesPorDisciplina.entries()).map(([discId, nomes]) => {\r\n        const primeiraFrente = frentesData?.find(\r\n          (f: FrenteValidacaoResult) => f.disciplina_id === discId,\r\n        );\r\n        const disciplinaNome =\r\n          getDisciplinaNome(primeiraFrente?.disciplinas) || \"Desconhecida\";\r\n        return {\r\n          disciplina_id: discId,\r\n          disciplina_nome: disciplinaNome,\r\n          frentes: nomes,\r\n          total: nomes.length,\r\n        };\r\n      }),\r\n    );\r\n\r\n    // Valida√ß√£o cr√≠tica: verificar se todas as disciplinas t√™m frentes\r\n    disciplinasIds.forEach((discId) => {\r\n      const frentesDaDisciplina = frentesPorDisciplina.get(discId) || [];\r\n      if (frentesDaDisciplina.length === 0) {\r\n        console.error(\r\n          `[CronogramaService] ‚ùå‚ùå‚ùå DISCIPLINA ${discId} N√ÉO TEM FRENTES ENCONTRADAS!`,\r\n        );\r\n      } else {\r\n        console.log(\r\n          `[CronogramaService] ‚úÖ Disciplina ${discId} tem ${frentesDaDisciplina.length} frente(s):`,\r\n          frentesDaDisciplina,\r\n        );\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes encontradas:\",\r\n      frenteIds.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] ===========================================\",\r\n    );\r\n\r\n    if (frenteIds.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma frente encontrada para as disciplinas selecionadas\",\r\n      );\r\n    }\r\n\r\n    // Buscar m√≥dulos das frentes (com informa√ß√µes da frente para valida√ß√£o)\r\n    console.log(\r\n      \"[CronogramaService] ========== DIAGN√ìSTICO DE M√ìDULOS ==========\",\r\n    );\r\n    console.log(\"[CronogramaService] Buscando m√≥dulos para:\", {\r\n      total_frentes: frenteIds.length,\r\n      frente_ids: frenteIds,\r\n      curso_id: cursoId,\r\n    });\r\n\r\n    // PRIMEIRO: Buscar TODOS os m√≥dulos das frentes (sem filtro de curso) para diagn√≥stico\r\n    const { data: todosModulosSemFiltro, error: todosModulosError } =\r\n      await client\r\n        .from(\"modulos\")\r\n        .select(\r\n          \"id, nome, frente_id, curso_id, frentes(id, nome, disciplina_id, curso_id, disciplinas(nome))\",\r\n        )\r\n        .in(\"frente_id\", frenteIds);\r\n\r\n    if (todosModulosError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar todos os m√≥dulos (diagn√≥stico):\",\r\n        todosModulosError,\r\n      );\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] TOTAL de m√≥dulos encontrados (SEM filtro de curso):\",\r\n        todosModulosSemFiltro?.length || 0,\r\n      );\r\n\r\n      // Agrupar m√≥dulos por frente\r\n      const modulosPorFrenteSemFiltro = new Map<string, DiagnosticoFrente>();\r\n      todosModulosSemFiltro?.forEach((modulo: ModuloQueryResult) => {\r\n        const frenteId = modulo.frente_id || \"\";\r\n        if (!modulosPorFrenteSemFiltro.has(frenteId)) {\r\n          const frente = getFrenteInfo(modulo.frentes);\r\n          modulosPorFrenteSemFiltro.set(frenteId, {\r\n            frente: {\r\n              id: frente?.id,\r\n              nome: frente?.nome,\r\n              disciplina: getDisciplinaNome(frente?.disciplinas),\r\n              curso_id: frente?.curso_id,\r\n            },\r\n            modulos: [],\r\n          });\r\n        }\r\n        modulosPorFrenteSemFiltro.get(frenteId)!.modulos.push({\r\n          id: modulo.id,\r\n          nome: modulo.nome || \"\",\r\n          curso_id: modulo.curso_id ?? null,\r\n        });\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] M√≥dulos agrupados por frente (SEM filtro):\",\r\n        Array.from(modulosPorFrenteSemFiltro.entries()).map(\r\n          ([frenteId, info]) => ({\r\n            frente_id: frenteId,\r\n            frente_nome: info.frente.nome,\r\n            disciplina: info.frente.disciplina,\r\n            frente_curso_id: info.frente.curso_id,\r\n            total_modulos: info.modulos.length,\r\n            modulos: info.modulos.map((m: ModuloInfo) => ({\r\n              id: m.id,\r\n              nome: m.nome,\r\n              curso_id: m.curso_id,\r\n            })),\r\n          }),\r\n        ),\r\n      );\r\n\r\n      // Verificar m√≥dulos do curso selecionado\r\n      if (cursoId) {\r\n        const modulosDoCurso =\r\n          todosModulosSemFiltro?.filter(\r\n            (m: ModuloQueryResult) => m.curso_id === cursoId,\r\n          ) || [];\r\n        console.log(\"[CronogramaService] M√≥dulos do curso selecionado:\", {\r\n          curso_id: cursoId,\r\n          total: modulosDoCurso.length,\r\n        });\r\n\r\n        // Verificar frentes sem m√≥dulos no curso\r\n        frenteIds.forEach((frenteId) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          const modulosDaFrente =\r\n            todosModulosSemFiltro?.filter(\r\n              (m: ModuloQueryResult) =>\r\n                m.frente_id === frenteId && m.curso_id === cursoId,\r\n            ) || [];\r\n\r\n          if (modulosDaFrente.length === 0) {\r\n            console.error(\r\n              `[CronogramaService] ‚ùå‚ùå‚ùå FRENTE \"${frente?.nome}\" (${frenteId}) N√ÉO TEM M√ìDULOS NO CURSO ${cursoId}!`,\r\n            );\r\n          } else {\r\n            console.log(\r\n              `[CronogramaService] ‚úÖ Frente \"${frente?.nome}\" tem ${modulosDaFrente.length} m√≥dulo(s) no curso`,\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // AGORA: Buscar m√≥dulos com filtro de curso (query real)\r\n    let modulosQuery = client\r\n      .from(\"modulos\")\r\n      .select(\r\n        \"id, frente_id, curso_id, frentes(nome, disciplina_id, curso_id, disciplinas(nome))\",\r\n      )\r\n      .in(\"frente_id\", frenteIds);\r\n\r\n    // Alguns m√≥dulos antigos podem n√£o ter curso_id definido.\r\n    // Quando um curso √© informado, aceitamos m√≥dulos que perten√ßam √†s frentes do curso\r\n    // mesmo se o curso_id estiver null, para manter compatibilidade com dados legados.\r\n    if (cursoId) {\r\n      modulosQuery = modulosQuery.or(`curso_id.eq.${cursoId},curso_id.is.null`);\r\n    }\r\n\r\n    const { data: modulosData, error: modulosError } = await modulosQuery;\r\n\r\n    if (modulosError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar m√≥dulos:\",\r\n        modulosError,\r\n      );\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar m√≥dulos: ${modulosError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"üîç [CronogramaService] RESULTADO DA BUSCA DE M√ìDULOS:\", {\r\n      total_encontrados: modulosData?.length || 0,\r\n      frentes_com_modulos: new Set(\r\n        modulosData?.map((m: ModuloQueryResult) => m.frente_id || \"\") || [],\r\n      ).size,\r\n      total_frentes_esperadas: frenteIds.length,\r\n      modulos_por_frente: modulosData?.reduce(\r\n        (acc: Record<string, number>, m: ModuloQueryResult) => {\r\n          const frenteId = m.frente_id || \"\";\r\n          if (!acc[frenteId]) {\r\n            acc[frenteId] = 0;\r\n          }\r\n          acc[frenteId]++;\r\n          return acc;\r\n        },\r\n        {} as Record<string, number>,\r\n      ),\r\n    });\r\n\r\n    // Verificar quais frentes N√ÉO t√™m m√≥dulos\r\n    const frentesComModulos = new Set(\r\n      modulosData?.map((m: ModuloQueryResult) => m.frente_id || \"\") || [],\r\n    );\r\n    const frentesSemModulos = frenteIds.filter(\r\n      (id) => !frentesComModulos.has(id),\r\n    );\r\n    if (frentesSemModulos.length > 0) {\r\n      console.error(\r\n        \"üîç [CronogramaService] ‚ùå‚ùå‚ùå FRENTES SEM M√ìDULOS ENCONTRADAS:\",\r\n        frentesSemModulos.map((id) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === id,\r\n          );\r\n          return {\r\n            frente_id: id,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            disciplina_id: frente?.disciplina_id,\r\n          };\r\n        }),\r\n      );\r\n    }\r\n\r\n    let moduloIds = modulosData?.map((m) => m.id) || [];\r\n    const modulosPorFrente = new Map<string, string[]>();\r\n\r\n    // Agrupar m√≥dulos por frente para valida√ß√£o\r\n    modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n      const frenteId = modulo.frente_id || \"\";\r\n      if (!modulosPorFrente.has(frenteId)) {\r\n        modulosPorFrente.set(frenteId, []);\r\n      }\r\n      modulosPorFrente.get(frenteId)!.push(modulo.id);\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] M√≥dulos encontrados por frente (COM filtro):\",\r\n      Array.from(modulosPorFrente.entries()).map(([frenteId, moduloIds]) => {\r\n        const frente = frentesData?.find(\r\n          (f: FrenteValidacaoResult) => f.id === frenteId,\r\n        );\r\n        const moduloComFrente = modulosData?.find(\r\n          (m: ModuloQueryResult) => m.frente_id === frenteId,\r\n        );\r\n        const frenteInfo = getFrenteInfo(moduloComFrente?.frentes);\r\n        const disciplinaNome =\r\n          getDisciplinaNome(frenteInfo?.disciplinas) || \"Desconhecida\";\r\n        return {\r\n          frente_id: frenteId,\r\n          frente_nome: frente?.nome || frenteInfo?.nome || \"Desconhecida\",\r\n          disciplina: disciplinaNome,\r\n          total_modulos: moduloIds.length,\r\n          modulo_ids: moduloIds,\r\n        };\r\n      }),\r\n    );\r\n\r\n    // Valida√ß√£o cr√≠tica: verificar se todas as frentes t√™m m√≥dulos\r\n    frenteIds.forEach((frenteId) => {\r\n      const modulosDaFrente = modulosPorFrente.get(frenteId) || [];\r\n      const frente = frentesData?.find(\r\n        (f: FrenteValidacaoResult) => f.id === frenteId,\r\n      );\r\n      if (modulosDaFrente.length === 0) {\r\n        console.error(\r\n          `[CronogramaService] ‚ùå‚ùå‚ùå FRENTE \"${frente?.nome}\" (${frenteId}) N√ÉO TEM M√ìDULOS!`,\r\n        );\r\n      } else {\r\n        console.log(\r\n          `[CronogramaService] ‚úÖ Frente \"${frente?.nome}\" tem ${modulosDaFrente.length} m√≥dulo(s)`,\r\n        );\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Total de m√≥dulos encontrados:\",\r\n      moduloIds.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] ===========================================\",\r\n    );\r\n\r\n    if (modulosSelecionados && modulosSelecionados.length > 0) {\r\n      const modulosAntesFiltro = moduloIds.length;\r\n\r\n      // Log detalhado dos m√≥dulos antes do filtro\r\n      const modulosPorFrenteAntes = new Map<\r\n        string,\r\n        { total: number; ids: string[] }\r\n      >();\r\n      modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n        const frenteId = modulo.frente_id || \"\";\r\n        if (!modulosPorFrenteAntes.has(frenteId)) {\r\n          modulosPorFrenteAntes.set(frenteId, { total: 0, ids: [] });\r\n        }\r\n        const frente = modulosPorFrenteAntes.get(frenteId)!;\r\n        frente.total++;\r\n        frente.ids.push(modulo.id);\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] M√≥dulos ANTES do filtro por frente:\",\r\n        Array.from(modulosPorFrenteAntes.entries()).map(([frenteId, info]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_modulos: info.total,\r\n            modulo_ids: info.ids,\r\n          };\r\n        }),\r\n      );\r\n\r\n      moduloIds = moduloIds.filter((id) => modulosSelecionados.includes(id));\r\n\r\n      console.log(\"[CronogramaService] Filtro de m√≥dulos aplicado:\", {\r\n        modulos_antes: modulosAntesFiltro,\r\n        modulos_depois: moduloIds.length,\r\n        modulos_selecionados_total: modulosSelecionados.length,\r\n        modulos_selecionados_primeiros_10: modulosSelecionados.slice(0, 10),\r\n      });\r\n\r\n      // Validar que todas as frentes t√™m pelo menos um m√≥dulo selecionado\r\n      const frentesComModulosSelecionados = new Set<string>();\r\n      const modulosPorFrenteDepois = new Map<\r\n        string,\r\n        { total: number; ids: string[] }\r\n      >();\r\n\r\n      modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n        if (moduloIds.includes(modulo.id)) {\r\n          const frenteId = modulo.frente_id || \"\";\r\n          frentesComModulosSelecionados.add(frenteId);\r\n          if (!modulosPorFrenteDepois.has(frenteId)) {\r\n            modulosPorFrenteDepois.set(frenteId, { total: 0, ids: [] });\r\n          }\r\n          const frente = modulosPorFrenteDepois.get(frenteId)!;\r\n          frente.total++;\r\n          frente.ids.push(modulo.id);\r\n        }\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] M√≥dulos DEPOIS do filtro por frente:\",\r\n        Array.from(modulosPorFrenteDepois.entries()).map(([frenteId, info]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_modulos: info.total,\r\n            modulo_ids: info.ids,\r\n          };\r\n        }),\r\n      );\r\n\r\n      // Verificar se h√° m√≥dulos selecionados que n√£o pertencem a nenhuma frente encontrada\r\n      const modulosSelecionadosValidos = new Set(moduloIds);\r\n      const modulosSelecionadosInvalidos = modulosSelecionados.filter(\r\n        (id) => !modulosSelecionadosValidos.has(id),\r\n      );\r\n      if (modulosSelecionadosInvalidos.length > 0) {\r\n        console.warn(\r\n          \"[CronogramaService] ‚ö†Ô∏è M√≥dulos selecionados que n√£o pertencem √†s frentes encontradas:\",\r\n          {\r\n            total_invalidos: modulosSelecionadosInvalidos.length,\r\n            modulo_ids: modulosSelecionadosInvalidos.slice(0, 10),\r\n          },\r\n        );\r\n      }\r\n\r\n      const frentesSemModulos = frenteIds.filter(\r\n        (id) => !frentesComModulosSelecionados.has(id),\r\n      );\r\n      if (frentesSemModulos.length > 0) {\r\n        const frentesSemModulosNomes = frentesSemModulos.map((id) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === id,\r\n          );\r\n          return {\r\n            frente_id: id,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            disciplina_id: frente?.disciplina_id || \"Desconhecida\",\r\n          };\r\n        });\r\n        console.warn(\r\n          \"[CronogramaService] ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Frentes sem m√≥dulos selecionados (CR√çTICO):\",\r\n          JSON.stringify(frentesSemModulosNomes, null, 2),\r\n        );\r\n\r\n        // Tentar identificar se h√° m√≥dulos dessas frentes que n√£o foram selecionados\r\n        frentesSemModulos.forEach((frenteId) => {\r\n          const modulosDaFrente = modulosPorFrenteAntes.get(frenteId);\r\n          if (modulosDaFrente && modulosDaFrente.ids.length > 0) {\r\n            console.warn(\r\n              `[CronogramaService] ‚ö†Ô∏è Frente ${frentesData?.find((f: FrenteValidacaoResult) => f.id === frenteId)?.nome} tem ${modulosDaFrente.ids.length} m√≥dulo(s) dispon√≠vel(is) mas nenhum foi selecionado:`,\r\n              modulosDaFrente.ids.slice(0, 5),\r\n            );\r\n          }\r\n        });\r\n      }\r\n\r\n      if (moduloIds.length === 0) {\r\n        console.warn(\r\n          \"[CronogramaService] Nenhum m√≥dulo selecionado permaneceu ap√≥s o filtro por frentes/curso.\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // Diagn√≥stico adicional quando o usu√°rio selecionou m√≥dulos mas nenhum foi considerado v√°lido\r\n    if (\r\n      moduloIds.length === 0 &&\r\n      modulosSelecionados &&\r\n      modulosSelecionados.length > 0\r\n    ) {\r\n      const { data: modulosSelecionadosData, error: modulosSelecionadosError } =\r\n        await client\r\n          .from(\"modulos\")\r\n          .select(\r\n            \"id, frente_id, curso_id, frentes(id, nome, curso_id, disciplinas(nome))\",\r\n          )\r\n          .in(\"id\", modulosSelecionados);\r\n\r\n      if (modulosSelecionadosError) {\r\n        console.warn(\r\n          \"[CronogramaService] N√£o foi poss√≠vel diagnosticar m√≥dulos selecionados:\",\r\n          modulosSelecionadosError,\r\n        );\r\n      } else {\r\n        const frentesValidasSet = new Set(frenteIds);\r\n        const modulosForaDasFrentes = (modulosSelecionadosData || []).filter(\r\n          (m: ModuloSelecionadoQueryResult) =>\r\n            m.frente_id && !frentesValidasSet.has(m.frente_id),\r\n        );\r\n\r\n        console.warn(\r\n          \"[CronogramaService] ‚ö†Ô∏è M√≥dulos selecionados n√£o pertencem √†s frentes/curso informados:\",\r\n          {\r\n            cursoId,\r\n            total_modulos_selecionados: modulosSelecionados.length,\r\n            total_modulos_encontrados: modulosSelecionadosData?.length || 0,\r\n            modulos_fora_das_frentes: modulosForaDasFrentes.map(\r\n              (m: ModuloSelecionadoQueryResult) => {\r\n                const frenteInfo = getFirst(m.frentes);\r\n                return {\r\n                  id: m.id,\r\n                  frente_id: m.frente_id,\r\n                  curso_id: m.curso_id,\r\n                  frente_nome: frenteInfo?.nome,\r\n                  frente_curso_id: frenteInfo?.curso_id,\r\n                  disciplina_nome: getFirst(frenteInfo?.disciplinas)?.nome,\r\n                };\r\n              },\r\n            ),\r\n          },\r\n        );\r\n      }\r\n\r\n      throw new CronogramaValidationError(\r\n        \"Nenhum m√≥dulo v√°lido encontrado para o curso selecionado. Verifique se os m√≥dulos est√£o vinculados √†s frentes e disciplinas escolhidas.\",\r\n      );\r\n    }\r\n\r\n    if (moduloIds.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhum m√≥dulo encontrado para as frentes selecionadas\",\r\n      );\r\n    }\r\n\r\n    // PRIMEIRO: Buscar TODAS as aulas (sem filtro de prioridade) para diagn√≥stico\r\n    console.log(\r\n      \"üîç [CronogramaService] Buscando TODAS as aulas (sem filtro de prioridade) para diagn√≥stico...\",\r\n    );\r\n    const { data: todasAulasSemFiltro, error: todasAulasError } = await client\r\n      .from(\"aulas\")\r\n      .select(\r\n        `\r\n        id,\r\n        nome,\r\n        prioridade,\r\n        modulo_id,\r\n        modulos!inner(\r\n          id,\r\n          frente_id,\r\n          frentes!inner(\r\n            id,\r\n            nome,\r\n            curso_id\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .in(\"modulo_id\", moduloIds);\r\n\r\n    if (!todasAulasError && todasAulasSemFiltro) {\r\n      // Agrupar por frente\r\n      const aulasPorFrente = new Map<\r\n        string,\r\n        {\r\n          total: number;\r\n          prioridade_0: number;\r\n          prioridade_null: number;\r\n          prioridade_menor_1: number;\r\n          prioridade_maior_igual_1: number;\r\n        }\r\n      >();\r\n\r\n      todasAulasSemFiltro.forEach((aula: AulaQueryResult) => {\r\n        const modulo = getModuloInfo(aula.modulos);\r\n        const frente = getFrenteInfo(modulo?.frentes);\r\n        const frenteId = frente?.id;\r\n        if (!frenteId) return;\r\n\r\n        if (!aulasPorFrente.has(frenteId)) {\r\n          aulasPorFrente.set(frenteId, {\r\n            total: 0,\r\n            prioridade_0: 0,\r\n            prioridade_null: 0,\r\n            prioridade_menor_1: 0,\r\n            prioridade_maior_igual_1: 0,\r\n          });\r\n        }\r\n\r\n        const stats = aulasPorFrente.get(frenteId)!;\r\n        stats.total++;\r\n\r\n        if (aula.prioridade === null || aula.prioridade === undefined) {\r\n          stats.prioridade_null++;\r\n        } else if (aula.prioridade === 0) {\r\n          stats.prioridade_0++;\r\n        } else if (aula.prioridade < 1) {\r\n          stats.prioridade_menor_1++;\r\n        } else if (aula.prioridade >= 1) {\r\n          stats.prioridade_maior_igual_1++;\r\n        }\r\n      });\r\n\r\n      console.log(\r\n        \"üîç [CronogramaService] Diagn√≥stico de aulas por frente (ANTES do filtro de prioridade):\",\r\n        Array.from(aulasPorFrente.entries()).map(([frenteId, stats]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteQueryResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_aulas: stats.total,\r\n            prioridade_0: stats.prioridade_0,\r\n            prioridade_null: stats.prioridade_null,\r\n            prioridade_menor_1: stats.prioridade_menor_1,\r\n            prioridade_maior_igual_1: stats.prioridade_maior_igual_1,\r\n            sera_incluida: stats.prioridade_maior_igual_1 > 0,\r\n          };\r\n        }),\r\n      );\r\n    }\r\n\r\n    // Buscar aulas dos m√≥dulos com filtro de prioridade\r\n    // N√£o usamos curso_id direto de aulas para evitar problemas de cache/sincroniza√ß√£o\r\n    // Filtramos via join com frentes ap√≥s buscar\r\n    const aulasQuery = client\r\n      .from(\"aulas\")\r\n      .select(\r\n        `\r\n        id,\r\n        nome,\r\n        numero_aula,\r\n        tempo_estimado_minutos,\r\n        prioridade,\r\n        modulos!inner(\r\n          id,\r\n          nome,\r\n          numero_modulo,\r\n          frentes!inner(\r\n            id,\r\n            nome,\r\n            curso_id,\r\n            disciplinas!inner(\r\n              id,\r\n              nome\r\n            )\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .in(\"modulo_id\", moduloIds)\r\n      .gte(\"prioridade\", prioridadeMinimaEfetiva)\r\n      .neq(\"prioridade\", 0);\r\n\r\n    const { data: aulasDataRaw, error: aulasError } = await aulasQuery;\r\n\r\n    if (aulasError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar aulas:\", {\r\n        message: aulasError.message,\r\n        details: aulasError.details,\r\n        hint: aulasError.hint,\r\n        code: aulasError.code,\r\n      });\r\n\r\n      // Se o erro for sobre curso_id n√£o existir, tentar buscar sem selecionar curso_id\r\n      if (aulasError.message?.includes(\"curso_id\")) {\r\n        console.warn(\r\n          \"[CronogramaService] Tentando buscar aulas sem filtro de curso_id...\",\r\n        );\r\n        const { data: aulasDataSemFiltro, error: errorSemFiltro } = await client\r\n          .from(\"aulas\")\r\n          .select(\r\n            `\r\n            id,\r\n            nome,\r\n            numero_aula,\r\n            tempo_estimado_minutos,\r\n            prioridade,\r\n            modulos!inner(\r\n              id,\r\n              nome,\r\n              numero_modulo,\r\n              frentes!inner(\r\n                id,\r\n                nome,\r\n                curso_id,\r\n                disciplinas!inner(\r\n                  id,\r\n                  nome\r\n                )\r\n              )\r\n            )\r\n          `,\r\n          )\r\n          .in(\"modulo_id\", moduloIds)\r\n          .gte(\"prioridade\", prioridadeMinimaEfetiva)\r\n          .neq(\"prioridade\", 0);\r\n\r\n        if (errorSemFiltro) {\r\n          throw new CronogramaValidationError(\r\n            `Erro ao buscar aulas: ${errorSemFiltro.message}`,\r\n          );\r\n        }\r\n\r\n        // Filtrar por curso_id em mem√≥ria baseado na frente\r\n        if (aulasDataSemFiltro) {\r\n          const aulasFiltradas = aulasDataSemFiltro.filter(\r\n            (aula: AulaQueryResult) => {\r\n              const modulo = getModuloInfo(aula.modulos);\r\n              const frente = getFrenteInfo(modulo?.frentes);\r\n              return frente?.curso_id === cursoId;\r\n            },\r\n          );\r\n\r\n          if (aulasFiltradas.length === 0) {\r\n            throw new CronogramaValidationError(\r\n              \"Nenhuma aula encontrada com os crit√©rios fornecidos\",\r\n            );\r\n          }\r\n\r\n          // Continuar com aulasFiltradas\r\n          const aulas: AulaCompleta[] = aulasFiltradas.map(\r\n            (aula: AulaQueryResult) => {\r\n              const modulo = getModuloInfo(aula.modulos);\r\n              const frente = getFrenteInfo(modulo?.frentes);\r\n              const disciplina = getFirst(frente?.disciplinas);\r\n              return {\r\n                id: aula.id,\r\n                nome: aula.nome,\r\n                numero_aula: aula.numero_aula ?? null,\r\n                tempo_estimado_minutos:\r\n                  aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS,\r\n                prioridade: aula.prioridade ?? 1,\r\n                modulo_id: modulo?.id || \"\",\r\n                modulo_nome: modulo?.nome || \"\",\r\n                numero_modulo: modulo?.numero_modulo ?? null,\r\n                frente_id: frente?.id || \"\",\r\n                frente_nome: frente?.nome || \"\",\r\n                disciplina_id: disciplina?.id || \"\",\r\n                disciplina_nome: disciplina?.nome || \"\",\r\n              };\r\n            },\r\n          );\r\n\r\n          return aulas;\r\n        }\r\n      }\r\n\r\n      console.error(\"[CronogramaService] Erro ao buscar aulas:\", {\r\n        message: aulasError.message,\r\n        details: aulasError.details,\r\n        hint: aulasError.hint,\r\n        code: aulasError.code,\r\n      });\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar aulas: ${aulasError.message}`,\r\n      );\r\n    }\r\n\r\n    if (!aulasDataRaw || aulasDataRaw.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula encontrada com os crit√©rios fornecidos\",\r\n      );\r\n    }\r\n\r\n    console.log(\r\n      \"üîç [CronogramaService] Aulas encontradas ANTES do filtro de curso:\",\r\n      {\r\n        total: aulasDataRaw.length,\r\n        por_frente: aulasDataRaw.reduce(\r\n          (acc: FrenteStatsAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id || \"\";\r\n            const frenteNome = frente?.nome || \"\";\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = {\r\n                frente_nome: frenteNome,\r\n                total: 0,\r\n                curso_ids: new Set(),\r\n              };\r\n            }\r\n            acc[frenteId].total++;\r\n            if (frente?.curso_id) {\r\n              acc[frenteId].curso_ids.add(frente.curso_id);\r\n            }\r\n            return acc;\r\n          },\r\n          {} as FrenteStatsAccumulator,\r\n        ),\r\n      },\r\n    );\r\n\r\n    // Filtrar por curso_id usando o join com frentes (se fornecido)\r\n    let aulasData = aulasDataRaw;\r\n    if (cursoId) {\r\n      const aulasAntesFiltro = aulasDataRaw.length;\r\n      aulasData = aulasDataRaw.filter((aula: AulaQueryResult) => {\r\n        const modulo = getModuloInfo(aula.modulos);\r\n        const frente = getFrenteInfo(modulo?.frentes);\r\n        return frente?.curso_id === cursoId;\r\n      });\r\n\r\n      console.log(\"üîç [CronogramaService] Filtro de curso aplicado:\", {\r\n        curso_id: cursoId,\r\n        aulas_antes: aulasAntesFiltro,\r\n        aulas_depois: aulasData.length,\r\n        aulas_removidas: aulasAntesFiltro - aulasData.length,\r\n        por_frente: aulasData.reduce(\r\n          (acc: FrenteCountAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id || \"\";\r\n            const frenteNome = frente?.nome || \"\";\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = { frente_nome: frenteNome, total: 0 };\r\n            }\r\n            acc[frenteId].total++;\r\n            return acc;\r\n          },\r\n          {} as FrenteCountAccumulator,\r\n        ),\r\n      });\r\n\r\n      if (aulasData.length === 0) {\r\n        // Log detalhado antes de lan√ßar erro\r\n        const frentesComCursoDiferente = aulasDataRaw.reduce(\r\n          (acc: FrenteComCursoDiferenteAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id ?? \"\";\r\n            const frenteNome = frente?.nome ?? \"Desconhecida\";\r\n            const frenteCursoId = frente?.curso_id ?? null;\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = {\r\n                frente_nome: frenteNome,\r\n                curso_id: frenteCursoId,\r\n                total: 0,\r\n              };\r\n            }\r\n            acc[frenteId].total++;\r\n            return acc;\r\n          },\r\n          {} as FrenteComCursoDiferenteAccumulator,\r\n        );\r\n\r\n        interface FrenteInfo {\r\n          frente_nome: string;\r\n          curso_id: string | null;\r\n          total: number;\r\n        }\r\n\r\n        console.error(\r\n          \"üîç [CronogramaService] ‚ùå‚ùå‚ùå Nenhuma aula encontrada ap√≥s filtro de curso:\",\r\n          {\r\n            curso_id_esperado: cursoId,\r\n            frentes_encontradas: Object.values(frentesComCursoDiferente).map(\r\n              (f: FrenteInfo) => ({\r\n                frente_nome: f.frente_nome,\r\n                curso_id: f.curso_id,\r\n                total_aulas: f.total,\r\n                curso_id_correto: f.curso_id === cursoId,\r\n              }),\r\n            ),\r\n          },\r\n        );\r\n\r\n        throw new CronogramaValidationError(\r\n          \"Nenhuma aula encontrada para o curso selecionado\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // Mapear dados para estrutura mais simples\r\n    const aulas: AulaCompleta[] = aulasData.map((aula: AulaQueryResult) => {\r\n      const modulo = getModuloInfo(aula.modulos);\r\n      const frente = getFrenteInfo(modulo?.frentes);\r\n      const disciplina = getFirst(frente?.disciplinas);\r\n\r\n      return {\r\n        id: aula.id,\r\n        nome: aula.nome,\r\n        numero_aula: aula.numero_aula ?? null,\r\n        tempo_estimado_minutos: aula.tempo_estimado_minutos ?? null,\r\n        prioridade: aula.prioridade ?? 0,\r\n        modulo_id: modulo?.id ?? \"\",\r\n        modulo_nome: modulo?.nome ?? \"\",\r\n        numero_modulo: modulo?.numero_modulo ?? null,\r\n        frente_id: frente?.id ?? \"\",\r\n        frente_nome: frente?.nome ?? \"\",\r\n        disciplina_id: disciplina?.id ?? \"\",\r\n        disciplina_nome: disciplina?.nome ?? \"\",\r\n      };\r\n    });\r\n\r\n    // Validar que todas as frentes selecionadas t√™m aulas\r\n    const frentesComAulas = new Set<string>();\r\n    aulas.forEach((aula) => {\r\n      frentesComAulas.add(aula.frente_id);\r\n    });\r\n\r\n    const frentesSemAulasInicial = frenteIds.filter(\r\n      (id) => !frentesComAulas.has(id),\r\n    );\r\n    if (frentesSemAulasInicial.length > 0) {\r\n      const frentesSemAulasNomes = frentesSemAulasInicial.map((id) => {\r\n        const frente = frentesData?.find((f: FrenteQueryResult) => f.id === id);\r\n        return frente?.nome || id;\r\n      });\r\n      console.warn(\r\n        \"[CronogramaService] ‚ö†Ô∏è Frentes sem aulas encontradas (ap√≥s filtros):\",\r\n        {\r\n          frentes: frentesSemAulasNomes,\r\n          motivo_possivel:\r\n            \"Nenhuma aula encontrada com prioridade >= \" +\r\n            prioridadeMinimaEfetiva +\r\n            \" ou m√≥dulos n√£o selecionados\",\r\n        },\r\n      );\r\n\r\n      // Verificar se h√° m√≥dulos selecionados para essas frentes\r\n      if (modulosSelecionados && modulosSelecionados.length > 0) {\r\n        frentesSemAulasInicial.forEach((frenteId) => {\r\n          const modulosDaFrente = modulosPorFrente.get(frenteId) || [];\r\n          const modulosSelecionadosDaFrente = modulosDaFrente.filter((id) =>\r\n            modulosSelecionados.includes(id),\r\n          );\r\n          if (modulosSelecionadosDaFrente.length > 0) {\r\n            console.warn(\r\n              `[CronogramaService] ‚ö†Ô∏è Frente ${frentesData?.find((f: FrenteQueryResult) => f.id === frenteId)?.nome} tem ${modulosSelecionadosDaFrente.length} m√≥dulo(s) selecionado(s) mas nenhuma aula foi encontrada`,\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // Agrupar aulas por frente e disciplina para log\r\n    const aulasPorFrente = new Map<\r\n      string,\r\n      { frente_nome: string; disciplina_nome: string; total: number }\r\n    >();\r\n    aulas.forEach((aula) => {\r\n      if (!aulasPorFrente.has(aula.frente_id)) {\r\n        aulasPorFrente.set(aula.frente_id, {\r\n          frente_nome: aula.frente_nome,\r\n          disciplina_nome: aula.disciplina_nome,\r\n          total: 0,\r\n        });\r\n      }\r\n      aulasPorFrente.get(aula.frente_id)!.total++;\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Aulas encontradas por frente:\",\r\n      Array.from(aulasPorFrente.entries()).map(([frenteId, info]) => ({\r\n        frente_id: frenteId,\r\n        frente_nome: info.frente_nome,\r\n        disciplina_nome: info.disciplina_nome,\r\n        total_aulas: info.total,\r\n      })),\r\n    );\r\n\r\n    // Ordenar aulas: Disciplina > Frente > Numero Modulo > Numero Aula\r\n    aulas.sort((a, b) => {\r\n      // Ordenar por disciplina\r\n      if (a.disciplina_nome !== b.disciplina_nome) {\r\n        return a.disciplina_nome.localeCompare(b.disciplina_nome);\r\n      }\r\n      // Ordenar por frente\r\n      if (a.frente_nome !== b.frente_nome) {\r\n        return a.frente_nome.localeCompare(b.frente_nome);\r\n      }\r\n      // Ordenar por n√∫mero do m√≥dulo\r\n      const numModA = a.numero_modulo ?? 0;\r\n      const numModB = b.numero_modulo ?? 0;\r\n      if (numModA !== numModB) {\r\n        return numModA - numModB;\r\n      }\r\n      // Ordenar por n√∫mero da aula\r\n      const numAulaA = a.numero_aula ?? 0;\r\n      const numAulaB = b.numero_aula ?? 0;\r\n      return numAulaA - numAulaB;\r\n    });\r\n\r\n    console.log(\"[CronogramaService] ========== RESUMO FINAL ==========\");\r\n    console.log(\r\n      \"[CronogramaService] Total de aulas encontradas:\",\r\n      aulas.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes com aulas:\",\r\n      frentesComAulas.size,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes esperadas:\",\r\n      frenteIds.length,\r\n    );\r\n\r\n    // Listar todas as frentes e se t√™m aulas\r\n    const frentesComStatus = frenteIds.map((frenteId) => {\r\n      const frente = frentesData?.find(\r\n        (f: FrenteQueryResult) => f.id === frenteId,\r\n      );\r\n      const temAulas = frentesComAulas.has(frenteId);\r\n      const totalAulas = aulas.filter((a) => a.frente_id === frenteId).length;\r\n      return {\r\n        frente_id: frenteId,\r\n        frente_nome: frente?.nome || \"Desconhecida\",\r\n        disciplina_id: frente?.disciplina_id || \"Desconhecida\",\r\n        tem_aulas: temAulas,\r\n        total_aulas: totalAulas,\r\n      };\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Status de todas as frentes:\",\r\n      JSON.stringify(frentesComStatus, null, 2),\r\n    );\r\n\r\n    const frentesSemAulas = frentesComStatus.filter((f) => !f.tem_aulas);\r\n    if (frentesSemAulas.length > 0) {\r\n      console.error(\r\n        \"[CronogramaService] ‚ùå‚ùå‚ùå FRENTES SEM AULAS NO CRONOGRAMA:\",\r\n        JSON.stringify(frentesSemAulas, null, 2),\r\n      );\r\n    } else {\r\n      console.log(\"[CronogramaService] ‚úÖ Todas as frentes t√™m aulas!\");\r\n    }\r\n    console.log(\"[CronogramaService] ====================================\");\r\n\r\n    return aulas;\r\n  }\r\n\r\n  private distribuirAulas(\r\n    aulasComCusto: Array<AulaCompleta & { custo: number }>,\r\n    semanas: SemanaInfo[],\r\n    modalidade: \"paralelo\" | \"sequencial\",\r\n    ordemFrentesPreferencia?: string[],\r\n  ): ItemDistribuicao[] {\r\n    // Agrupar aulas por frente\r\n    type FrenteComCusto = Omit<FrenteDistribuicao, \"aulas\"> & {\r\n      aulas: Array<AulaCompleta & { custo: number }>;\r\n    };\r\n    const frentesMap = new Map<string, FrenteComCusto>();\r\n\r\n    for (const aula of aulasComCusto) {\r\n      if (!frentesMap.has(aula.frente_id)) {\r\n        frentesMap.set(aula.frente_id, {\r\n          frente_id: aula.frente_id,\r\n          frente_nome: aula.frente_nome,\r\n          aulas: [],\r\n          custo_total: 0,\r\n          peso: 0,\r\n        });\r\n      }\r\n\r\n      const frente = frentesMap.get(aula.frente_id)!;\r\n      frente.aulas.push(aula);\r\n      frente.custo_total += aula.custo;\r\n    }\r\n\r\n    const frentes: FrenteComCusto[] = Array.from(frentesMap.values());\r\n    const custoTotalNecessario = aulasComCusto.reduce(\r\n      (acc, aula) => acc + aula.custo,\r\n      0,\r\n    );\r\n\r\n    // Calcular pesos (modo paralelo)\r\n    if (modalidade === \"paralelo\") {\r\n      frentes.forEach((frente) => {\r\n        frente.peso = frente.custo_total / custoTotalNecessario;\r\n      });\r\n    }\r\n\r\n    // Ordenar frentes (modo sequencial)\r\n    if (modalidade === \"sequencial\" && ordemFrentesPreferencia) {\r\n      const ordemMap = new Map(\r\n        ordemFrentesPreferencia.map((nome, idx) => [nome, idx]),\r\n      );\r\n      frentes.sort((a, b) => {\r\n        const ordemA = ordemMap.get(a.frente_nome) ?? Infinity;\r\n        const ordemB = ordemMap.get(b.frente_nome) ?? Infinity;\r\n        return ordemA - ordemB;\r\n      });\r\n    }\r\n\r\n    // Distribuir aulas por semana\r\n    const itens: ItemDistribuicao[] = [];\r\n    const semanasUteis = semanas.filter((s) => !s.is_ferias);\r\n\r\n    console.log(\"[CronogramaService] Distribuindo aulas:\", {\r\n      totalAulas: aulasComCusto.length,\r\n      totalSemanas: semanas.length,\r\n      semanasUteis: semanasUteis.length,\r\n      semanasFerias: semanas.filter((s) => s.is_ferias).length,\r\n      totalFrentes: frentes.length,\r\n      modalidade,\r\n    });\r\n\r\n    let frenteIndex = 0;\r\n    const aulaIndexPorFrente = new Map<string, number>();\r\n\r\n    // Inicializar √≠ndices de aula por frente\r\n    frentes.forEach((frente) => {\r\n      aulaIndexPorFrente.set(frente.frente_id, 0);\r\n    });\r\n\r\n    if (modalidade === \"paralelo\") {\r\n      // Modo Paralelo: Distribuir proporcionalmente\r\n      for (const semana of semanasUteis) {\r\n        const capacidadeSemanal = semana.capacidade_minutos;\r\n        let tempoUsado = 0;\r\n        let ordemNaSemana = 1;\r\n\r\n        // Distribuir cada frente proporcionalmente\r\n        for (const frente of frentes) {\r\n          const cotaFrente = capacidadeSemanal * frente.peso;\r\n          let tempoFrenteUsado = 0;\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n\r\n          while (\r\n            aulaIndex < frente.aulas.length &&\r\n            tempoFrenteUsado + frente.aulas[aulaIndex].custo <= cotaFrente &&\r\n            tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n          ) {\r\n            itens.push({\r\n              cronograma_id: \"\", // Ser√° preenchido ap√≥s criar cronograma\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoFrenteUsado += frente.aulas[aulaIndex].custo;\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n          }\r\n\r\n          aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n        }\r\n\r\n        // Fallback: Se sobrou tempo, preencher com aulas restantes\r\n        for (const frente of frentes) {\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n          while (\r\n            aulaIndex < frente.aulas.length &&\r\n            tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n          ) {\r\n            itens.push({\r\n              cronograma_id: \"\",\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n          }\r\n          aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n        }\r\n\r\n        // Garantir que pelo menos uma aula seja adicionada se houver aulas dispon√≠veis e capacidade\r\n        if (ordemNaSemana === 1 && capacidadeSemanal > 0) {\r\n          // Nenhuma aula foi adicionada nesta semana, mas h√° capacidade\r\n          // Tentar adicionar pelo menos uma aula de qualquer frente\r\n          for (const frente of frentes) {\r\n            const aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n            if (\r\n              aulaIndex < frente.aulas.length &&\r\n              tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n            ) {\r\n              itens.push({\r\n                cronograma_id: \"\",\r\n                aula_id: frente.aulas[aulaIndex].id,\r\n                semana_numero: semana.numero,\r\n                ordem_na_semana: ordemNaSemana++,\r\n              });\r\n              tempoUsado += frente.aulas[aulaIndex].custo;\r\n              aulaIndexPorFrente.set(frente.frente_id, aulaIndex + 1);\r\n              break; // Adicionar apenas uma aula para garantir progresso\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // Modo Sequencial: Completar uma frente antes de iniciar pr√≥xima\r\n      for (const semana of semanasUteis) {\r\n        const capacidadeSemanal = semana.capacidade_minutos;\r\n        let tempoUsado = 0;\r\n        let ordemNaSemana = 1;\r\n\r\n        while (frenteIndex < frentes.length && tempoUsado < capacidadeSemanal) {\r\n          const frente = frentes[frenteIndex];\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n\r\n          if (aulaIndex >= frente.aulas.length) {\r\n            frenteIndex++;\r\n            continue;\r\n          }\r\n\r\n          if (tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal) {\r\n            itens.push({\r\n              cronograma_id: \"\",\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n            aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(\"[CronogramaService] Distribui√ß√£o conclu√≠da:\", {\r\n      totalItens: itens.length,\r\n      itensPorSemana: itens.reduce(\r\n        (acc, item) => {\r\n          acc[item.semana_numero] = (acc[item.semana_numero] || 0) + 1;\r\n          return acc;\r\n        },\r\n        {} as Record<number, number>,\r\n      ),\r\n    });\r\n\r\n    return itens;\r\n  }\r\n\r\n  private async buscarAulasConcluidas(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    alunoId: string,\r\n    cursoId?: string,\r\n  ): Promise<Set<string>> {\r\n    if (!cursoId) {\r\n      return new Set();\r\n    }\r\n\r\n    const { data, error } = await client\r\n      .from(\"aulas_concluidas\")\r\n      .select(\"aula_id\")\r\n      .eq(\"aluno_id\", alunoId)\r\n      .eq(\"curso_id\", cursoId);\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar aulas conclu√≠das:\",\r\n        error,\r\n      );\r\n    } else if (data && data.length > 0) {\r\n      return new Set(data.map((row) => row.aula_id as string));\r\n    }\r\n\r\n    const { data: historicoData, error: historicoError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\"aula_id, cronogramas!inner(aluno_id, curso_alvo_id)\")\r\n      .eq(\"concluido\", true)\r\n      .eq(\"cronogramas.aluno_id\", alunoId)\r\n      .eq(\"cronogramas.curso_alvo_id\", cursoId);\r\n\r\n    if (historicoError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar hist√≥rico de aulas conclu√≠das:\",\r\n        historicoError,\r\n      );\r\n      return new Set();\r\n    }\r\n\r\n    return new Set((historicoData ?? []).map((row) => row.aula_id as string));\r\n  }\r\n\r\n  private async persistirCronograma(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    input: GerarCronogramaInput,\r\n    itens: ItemDistribuicao[],\r\n    empresaId: string,\r\n  ): Promise<CronogramaDetalhado> {\r\n    let cronograma: CronogramaDetalhado | null = null;\r\n\r\n    // Criar registro do cronograma\r\n    const { data: cronogramaData, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .insert({\r\n        empresa_id: empresaId,\r\n        aluno_id: input.aluno_id,\r\n        curso_alvo_id: input.curso_alvo_id || null,\r\n        nome: input.nome || \"Meu Cronograma\",\r\n        data_inicio: input.data_inicio,\r\n        data_fim: input.data_fim,\r\n        dias_estudo_semana: input.dias_semana,\r\n        horas_estudo_dia: input.horas_dia,\r\n        periodos_ferias: (input.ferias ||\r\n          []) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"periodos_ferias\"],\r\n        prioridade_minima: input.prioridade_minima,\r\n        modalidade_estudo: input.modalidade,\r\n        disciplinas_selecionadas:\r\n          input.disciplinas_ids as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"disciplinas_selecionadas\"],\r\n        ordem_frentes_preferencia: (input.ordem_frentes_preferencia ||\r\n          null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"ordem_frentes_preferencia\"],\r\n        modulos_selecionados: (input.modulos_ids?.length\r\n          ? input.modulos_ids\r\n          : null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"modulos_selecionados\"],\r\n        excluir_aulas_concluidas: input.excluir_aulas_concluidas !== false,\r\n        velocidade_reproducao: input.velocidade_reproducao ?? 1.0,\r\n      } as any)\r\n      .select()\r\n      .single();\r\n\r\n    if (cronogramaError || !cronogramaData) {\r\n      console.error(\"[CronogramaService] Erro ao criar cronograma:\", {\r\n        message: cronogramaError?.message,\r\n        details: cronogramaError?.details,\r\n        hint: cronogramaError?.hint,\r\n        code: cronogramaError?.code,\r\n      });\r\n\r\n      // Se for erro 409 (Conflict), lan√ßar erro espec√≠fico\r\n      if (\r\n        cronogramaError?.code === \"23505\" ||\r\n        cronogramaError?.code === \"PGRST116\"\r\n      ) {\r\n        throw new CronogramaConflictError(\r\n          `Erro ao criar cronograma: ${cronogramaError.message || \"Conflito ao criar cronograma\"}`,\r\n        );\r\n      }\r\n\r\n      // Se o erro mencionar schema cache, limpar cache e tentar novamente\r\n      if (\r\n        cronogramaError?.message?.includes(\"schema cache\") ||\r\n        cronogramaError?.message?.includes(\"Could not find\")\r\n      ) {\r\n        console.warn(\r\n          \"[CronogramaService] Problema com schema cache detectado, limpando cache...\",\r\n        );\r\n        clearDatabaseClientCache();\r\n\r\n        // Tentar inserir sem as colunas que podem estar causando problema\r\n        console.warn(\r\n          \"[CronogramaService] Tentando criar cronograma sem as colunas novas...\",\r\n        );\r\n        const { data: cronogramaFallback, error: fallbackError } = await client\r\n          .from(\"cronogramas\")\r\n          .insert({\r\n            empresa_id: empresaId,\r\n            aluno_id: input.aluno_id,\r\n            curso_alvo_id: input.curso_alvo_id || null,\r\n            nome: input.nome || \"Meu Cronograma\",\r\n            data_inicio: input.data_inicio,\r\n            data_fim: input.data_fim,\r\n            dias_estudo_semana: input.dias_semana,\r\n            horas_estudo_dia: input.horas_dia,\r\n            periodos_ferias: (input.ferias ||\r\n              []) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"periodos_ferias\"],\r\n            prioridade_minima: input.prioridade_minima,\r\n            modalidade_estudo: input.modalidade,\r\n            disciplinas_selecionadas:\r\n              input.disciplinas_ids as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"disciplinas_selecionadas\"],\r\n            ordem_frentes_preferencia: (input.ordem_frentes_preferencia ||\r\n              null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"ordem_frentes_preferencia\"],\r\n          })\r\n          .select()\r\n          .single();\r\n\r\n        if (fallbackError || !cronogramaFallback) {\r\n          throw new Error(\r\n            `Erro ao criar cronograma: ${fallbackError?.message || cronogramaError?.message || \"Desconhecido\"}`,\r\n          );\r\n        }\r\n\r\n        cronograma = mapToCronogramaDetalhado(cronogramaFallback);\r\n\r\n        // Verificar se cronograma foi criado com sucesso\r\n        if (!cronograma) {\r\n          throw new Error(\"Falha ao criar cronograma no fallback\");\r\n        }\r\n\r\n        // Cronograma confirmado como n√£o-nulo para este bloco\r\n        const cronogramaFallbackConfirmado = cronograma;\r\n\r\n        // Tentar atualizar com as colunas novas separadamente (se existirem)\r\n        try {\r\n          const updateData: Partial<\r\n            Pick<\r\n              CronogramaDetalhado,\r\n              \"modulos_selecionados\" | \"excluir_aulas_concluidas\"\r\n            >\r\n          > = {};\r\n          if (input.modulos_ids?.length) {\r\n            updateData.modulos_selecionados = input.modulos_ids;\r\n          }\r\n          if (input.excluir_aulas_concluidas !== undefined) {\r\n            updateData.excluir_aulas_concluidas =\r\n              input.excluir_aulas_concluidas;\r\n          }\r\n\r\n          if (Object.keys(updateData).length > 0) {\r\n            const { data: cronogramaUpdated, error: updateError } = await client\r\n              .from(\"cronogramas\")\r\n              .update(updateData)\r\n              .eq(\"id\", cronogramaFallbackConfirmado.id)\r\n              .select()\r\n              .single();\r\n\r\n            if (!updateError && cronogramaUpdated) {\r\n              cronograma = mapToCronogramaDetalhado(cronogramaUpdated);\r\n            } else {\r\n              console.warn(\r\n                \"[CronogramaService] N√£o foi poss√≠vel atualizar alguns campos novos, mas cronograma foi criado\",\r\n              );\r\n            }\r\n          }\r\n        } catch (updateErr) {\r\n          console.warn(\r\n            \"[CronogramaService] Erro ao atualizar campos novos (ignorado):\",\r\n            updateErr,\r\n          );\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `Erro ao criar cronograma: ${cronogramaError?.message || \"Desconhecido\"}`,\r\n        );\r\n      }\r\n    } else {\r\n      cronograma = mapToCronogramaDetalhado(cronogramaData);\r\n    }\r\n\r\n    // Verificar se cronograma foi criado com sucesso\r\n    if (!cronograma) {\r\n      throw new Error(\"Falha ao criar cronograma\");\r\n    }\r\n\r\n    // Agora cronograma √© garantidamente n√£o-nulo\r\n    const cronogramaConfirmado = cronograma;\r\n\r\n    // IMPORTANTE: Sempre salvar os itens, independente de como o cronograma foi criado\r\n    // Preencher cronograma_id nos itens\r\n    const itensCompleto = itens.map((item) => ({\r\n      ...item,\r\n      cronograma_id: cronogramaConfirmado.id,\r\n    }));\r\n\r\n    console.log(\"[CronogramaService] Inserindo itens do cronograma:\", {\r\n      totalItens: itensCompleto.length,\r\n      cronogramaId: cronogramaConfirmado.id,\r\n      primeirosItens: itensCompleto.slice(0, 3).map((i) => ({\r\n        aula_id: i.aula_id,\r\n        semana_numero: i.semana_numero,\r\n        ordem_na_semana: i.ordem_na_semana,\r\n      })),\r\n    });\r\n\r\n    // Bulk insert dos itens\r\n    const { data: itensInseridos, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .insert(itensCompleto)\r\n      .select(\"id, aula_id, semana_numero, ordem_na_semana\");\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao inserir itens:\", {\r\n        message: itensError.message,\r\n        details: itensError.details,\r\n        hint: itensError.hint,\r\n        code: itensError.code,\r\n        totalItens: itensCompleto.length,\r\n      });\r\n      // Tentar deletar o cronograma criado\r\n      await client\r\n        .from(\"cronogramas\")\r\n        .delete()\r\n        .eq(\"id\", cronogramaConfirmado.id);\r\n      throw new Error(\r\n        `Erro ao inserir itens do cronograma: ${itensError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"[CronogramaService] Itens inseridos com sucesso:\", {\r\n      totalInseridos: itensInseridos?.length || 0,\r\n      esperado: itensCompleto.length,\r\n    });\r\n\r\n    // Criar distribui√ß√£o padr√£o de dias\r\n    await this.criarDistribuicaoPadrao(\r\n      client,\r\n      cronogramaConfirmado.id,\r\n      input.dias_semana,\r\n    );\r\n\r\n    // Recalcular datas dos itens baseado na distribui√ß√£o padr√£o\r\n    try {\r\n      await this.recalcularDatasItens(cronogramaConfirmado.id, input.aluno_id);\r\n    } catch (recalcError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao recalcular datas (n√£o cr√≠tico):\",\r\n        recalcError,\r\n      );\r\n      // N√£o falhar a cria√ß√£o do cronograma se o rec√°lculo falhar\r\n    }\r\n\r\n    // Buscar cronograma completo com itens\r\n    const { data: cronogramaCompleto, error: fetchError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\r\n        `\r\n        *,\r\n        cronograma_itens(\r\n          id,\r\n          aula_id,\r\n          semana_numero,\r\n          ordem_na_semana,\r\n          concluido,\r\n          aulas(\r\n            id,\r\n            nome,\r\n            numero_aula,\r\n            tempo_estimado_minutos\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"id\", cronogramaConfirmado.id)\r\n      .single();\r\n\r\n    if (fetchError) {\r\n      console.error(\"Erro ao buscar cronograma completo:\", fetchError);\r\n      return cronogramaConfirmado;\r\n    }\r\n\r\n    if (!cronogramaCompleto) {\r\n      return cronogramaConfirmado;\r\n    }\r\n\r\n    return mapToCronogramaDetalhado(\r\n      cronogramaCompleto as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Row\"],\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Busca a distribui√ß√£o de dias da semana para um cronograma\r\n   */\r\n  async buscarDistribuicaoDias(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<CronogramaSemanasDias | null> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usu√°rio\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id\")\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma n√£o encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Voc√™ s√≥ pode acessar seus pr√≥prios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar distribui√ß√£o\r\n    const { data, error } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"*\")\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar distribui√ß√£o de dias:\",\r\n        error,\r\n      );\r\n      throw new Error(`Erro ao buscar distribui√ß√£o de dias: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      id: data.id,\r\n      cronograma_id: data.cronograma_id,\r\n      dias_semana: data.dias_semana || [],\r\n      created_at: new Date(data.created_at ?? new Date().toISOString()),\r\n      updated_at: new Date(data.updated_at ?? new Date().toISOString()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Salva ou atualiza a distribui√ß√£o de dias da semana para um cronograma\r\n   */\r\n  async atualizarDistribuicaoDias(\r\n    input: AtualizarDistribuicaoDiasInput,\r\n    userId: string,\r\n  ): Promise<CronogramaSemanasDias> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Validar dias da semana (0-6)\r\n    const diasValidos = input.dias_semana.every((dia) => dia >= 0 && dia <= 6);\r\n    if (!diasValidos || input.dias_semana.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"dias_semana deve ser um array de n√∫meros entre 0 (domingo) e 6 (s√°bado)\",\r\n      );\r\n    }\r\n\r\n    // Verificar se o cronograma pertence ao usu√°rio\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id, data_inicio\")\r\n      .eq(\"id\", input.cronograma_id)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma n√£o encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Voc√™ s√≥ pode atualizar seus pr√≥prios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Verificar se j√° existe distribui√ß√£o\r\n    const { data: existente } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"id\")\r\n      .eq(\"cronograma_id\", input.cronograma_id)\r\n      .maybeSingle();\r\n\r\n    let resultado;\r\n    if (existente) {\r\n      // Atualizar\r\n      const { data, error } = await client\r\n        .from(\"cronograma_semanas_dias\")\r\n        .update({\r\n          dias_semana: input.dias_semana,\r\n        })\r\n        .eq(\"id\", existente.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao atualizar distribui√ß√£o de dias:\",\r\n          error,\r\n        );\r\n        throw new Error(\r\n          `Erro ao atualizar distribui√ß√£o de dias: ${error.message}`,\r\n        );\r\n      }\r\n\r\n      resultado = data;\r\n    } else {\r\n      // Criar\r\n      const { data, error } = await client\r\n        .from(\"cronograma_semanas_dias\")\r\n        .insert({\r\n          cronograma_id: input.cronograma_id,\r\n          dias_semana: input.dias_semana,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao criar distribui√ß√£o de dias:\",\r\n          error,\r\n        );\r\n        throw new Error(`Erro ao criar distribui√ß√£o de dias: ${error.message}`);\r\n      }\r\n\r\n      resultado = data;\r\n    }\r\n\r\n    // Recalcular datas dos itens\r\n    await this.recalcularDatasItens(input.cronograma_id, userId);\r\n\r\n    return {\r\n      id: resultado.id,\r\n      cronograma_id: resultado.cronograma_id,\r\n      dias_semana: resultado.dias_semana || [],\r\n      created_at: new Date(resultado.created_at ?? new Date().toISOString()),\r\n      updated_at: new Date(resultado.updated_at ?? new Date().toISOString()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Recalcula as datas previstas de todos os itens do cronograma\r\n   * baseado na distribui√ß√£o de dias da semana\r\n   */\r\n  async recalcularDatasItens(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<RecalcularDatasResult> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usu√°rio\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id, data_inicio\")\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma n√£o encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Voc√™ s√≥ pode recalcular datas dos seus pr√≥prios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar distribui√ß√£o de dias\r\n    const { data: distribuicao, error: distError } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"dias_semana\")\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .maybeSingle();\r\n\r\n    if (distError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar distribui√ß√£o de dias:\",\r\n        distError,\r\n      );\r\n      throw new Error(\r\n        `Erro ao buscar distribui√ß√£o de dias: ${distError.message}`,\r\n      );\r\n    }\r\n\r\n    // Se n√£o houver distribui√ß√£o, usar padr√£o (segunda a sexta)\r\n    const diasSemana = distribuicao?.dias_semana || [1, 2, 3, 4, 5];\r\n\r\n    console.log(`[CronogramaService] Distribui√ß√£o de dias encontrada:`, {\r\n      cronogramaId,\r\n      distribuicaoExiste: !!distribuicao,\r\n      diasSemana,\r\n      diasSemanaTipo: typeof diasSemana,\r\n      diasSemanaIsArray: Array.isArray(diasSemana),\r\n    });\r\n\r\n    // Buscar todos os itens do cronograma com informa√ß√µes de disciplina e frente\r\n    // Necess√°rio para ordenar por disciplina ‚Üí frente ‚Üí ordem\r\n    const { data: itens, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\r\n        `\r\n        id, \r\n        semana_numero, \r\n        ordem_na_semana,\r\n        aula_id,\r\n        aulas!inner(\r\n          id,\r\n          modulos!inner(\r\n            id,\r\n            frentes!inner(\r\n              id,\r\n              nome,\r\n              disciplina_id,\r\n              disciplinas!inner(\r\n                id,\r\n                nome\r\n              )\r\n            )\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .order(\"semana_numero\", { ascending: true })\r\n      .order(\"ordem_na_semana\", { ascending: true });\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar itens:\", itensError);\r\n      throw new Error(`Erro ao buscar itens: ${itensError.message}`);\r\n    }\r\n\r\n    if (!itens || itens.length === 0) {\r\n      return { success: true, itens_atualizados: 0 };\r\n    }\r\n\r\n    // Calcular datas agrupando por semana\r\n    const dataInicio = new Date(cronograma.data_inicio);\r\n    const atualizacoes: Array<{ id: string; data_prevista: string }> = [];\r\n\r\n    // Ordenar dias da semana (0=domingo, 1=segunda, ..., 6=s√°bado)\r\n    const diasOrdenados = [...diasSemana].sort((a, b) => a - b);\r\n\r\n    // Fun√ß√£o helper para extrair informa√ß√µes de disciplina e frente de um item\r\n    // Tipo helper para itens com dados aninhados do Supabase\r\n    type ItemComAula = {\r\n      id: string;\r\n      semana_numero: number;\r\n      ordem_na_semana: number;\r\n      aula_id: string;\r\n      aulas: {\r\n        id: string;\r\n        modulos: {\r\n          id: string;\r\n          frentes: {\r\n            id: string;\r\n            nome: string;\r\n            disciplina_id: string | null;\r\n            disciplinas: { id: string; nome: string } | null;\r\n          };\r\n        };\r\n      };\r\n    };\r\n\r\n    const extrairInfoItem = (item: ItemComAula) => {\r\n      // Supabase pode retornar dados aninhados de diferentes formas\r\n      const aula = item.aulas;\r\n      const modulo = aula?.modulos || null;\r\n      const frente = modulo?.frentes || null;\r\n      const disciplina = frente?.disciplinas || null;\r\n\r\n      return {\r\n        disciplinaId: disciplina?.id || \"\",\r\n        disciplinaNome: disciplina?.nome || \"\",\r\n        frenteId: frente?.id || \"\",\r\n        frenteNome: frente?.nome || \"\",\r\n      };\r\n    };\r\n\r\n    // Agrupar itens por semana primeiro\r\n    const itensPorSemana = new Map<number, ItemComAula[]>();\r\n    itens.forEach((item) => {\r\n      const semana = item.semana_numero;\r\n      if (!itensPorSemana.has(semana)) {\r\n        itensPorSemana.set(semana, []);\r\n      }\r\n      itensPorSemana.get(semana)!.push(item);\r\n    });\r\n\r\n    // Fun√ß√£o para reorganizar itens de uma semana: alternar entre disciplinas e frentes\r\n    const reorganizarItensPorSemana = (itensDaSemana: ItemComAula[]) => {\r\n      // Extrair informa√ß√µes de cada item\r\n      const itensComInfo = itensDaSemana.map((item) => ({\r\n        ...item,\r\n        info: extrairInfoItem(item),\r\n      }));\r\n\r\n      // Usar tipo inferido do array\r\n      type ItemComInfo = (typeof itensComInfo)[0];\r\n\r\n      // Agrupar por frente (todas as Frentes A, depois todas as Frentes B, etc.)\r\n      const itensPorFrente = new Map<string, ItemComInfo[]>();\r\n      itensComInfo.forEach((item) => {\r\n        const frenteKey = `${item.info.disciplinaNome}_${item.info.frenteNome}`;\r\n        if (!itensPorFrente.has(frenteKey)) {\r\n          itensPorFrente.set(frenteKey, []);\r\n        }\r\n        itensPorFrente.get(frenteKey)!.push(item);\r\n      });\r\n\r\n      // Ordenar itens dentro de cada grupo por ordem_na_semana\r\n      itensPorFrente.forEach((itensGrupo) => {\r\n        itensGrupo.sort((a, b) => a.ordem_na_semana - b.ordem_na_semana);\r\n      });\r\n\r\n      // Agrupar por nome da frente (todas as Frentes A, depois todas as Frentes B, etc.)\r\n      // Isso permite alternar entre disciplinas dentro da mesma frente\r\n      const frentesPorNome = new Map<string, ItemComInfo[][]>();\r\n      itensPorFrente.forEach((itens) => {\r\n        const frenteNome = itens[0].info.frenteNome;\r\n        if (!frentesPorNome.has(frenteNome)) {\r\n          frentesPorNome.set(frenteNome, []);\r\n        }\r\n        frentesPorNome.get(frenteNome)!.push(itens);\r\n      });\r\n\r\n      // Ordenar nomes das frentes alfabeticamente (Frente A, Frente B, etc.)\r\n      const frentesNomes = Array.from(frentesPorNome.keys()).sort();\r\n\r\n      // Reorganizar: distribuir round-robin entre disciplinas dentro de cada frente\r\n      // Processar todas as Frentes A primeiro, depois todas as Frentes B, etc.\r\n      const itensReorganizados: ItemComInfo[] = [];\r\n\r\n      for (const frenteNome of frentesNomes) {\r\n        const gruposFrente = frentesPorNome.get(frenteNome)!;\r\n\r\n        // Ordenar grupos por disciplina para garantir ordem consistente\r\n        gruposFrente.sort((grupoA, grupoB) => {\r\n          const disciplinaA = grupoA[0].info.disciplinaNome;\r\n          const disciplinaB = grupoB[0].info.disciplinaNome;\r\n          return disciplinaA.localeCompare(disciplinaB);\r\n        });\r\n\r\n        // Encontrar o m√°ximo de itens em qualquer grupo desta frente\r\n        const maxItens = Math.max(...gruposFrente.map((grupo) => grupo.length));\r\n\r\n        // Distribuir round-robin: pegar um item de cada disciplina por vez\r\n        // Exemplo: Disc1 Aula1, Disc2 Aula1, Disc3 Aula1, Disc1 Aula2, Disc2 Aula2, etc.\r\n        for (let i = 0; i < maxItens; i++) {\r\n          for (const grupo of gruposFrente) {\r\n            if (i < grupo.length) {\r\n              const item = grupo[i];\r\n              itensReorganizados.push(item);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return itensReorganizados;\r\n    };\r\n\r\n    // Contador para debug: distribui√ß√£o de itens por dia da semana e por semana\r\n    const contadorPorDia: Record<number, number> = {\r\n      0: 0,\r\n      1: 0,\r\n      2: 0,\r\n      3: 0,\r\n      4: 0,\r\n      5: 0,\r\n      6: 0,\r\n    };\r\n    const contadorPorSemana: Record<number, Record<number, number>> = {};\r\n\r\n    logDebug(`[CronogramaService] Iniciando distribui√ß√£o por semana:`, {\r\n      totalItens: itens.length,\r\n      totalSemanas: itensPorSemana.size,\r\n      diasSelecionados: diasOrdenados,\r\n      itensPorSemana: Array.from(itensPorSemana.entries()).map(\r\n        ([semana, itens]) => ({\r\n          semana,\r\n          totalItens: itens.length,\r\n        }),\r\n      ),\r\n    });\r\n\r\n    // Processar cada semana separadamente\r\n    Array.from(itensPorSemana.entries())\r\n      .sort(([a], [b]) => a - b) // Ordenar por n√∫mero da semana\r\n      .forEach(([semanaNumero, itensDaSemanaOriginal]) => {\r\n        // Reorganizar itens para alternar entre disciplinas e frentes\r\n        const itensDaSemana = reorganizarItensPorSemana(itensDaSemanaOriginal);\r\n        // Calcular data base da semana: data_inicio + (semana_numero - 1) * 7 dias\r\n        const dataBaseSemana = new Date(dataInicio);\r\n        dataBaseSemana.setDate(\r\n          dataBaseSemana.getDate() + (semanaNumero - 1) * 7,\r\n        );\r\n\r\n        // Calcular o per√≠odo da semana do cronograma (7 dias a partir da data base)\r\n        const dataFimSemana = new Date(dataBaseSemana);\r\n        dataFimSemana.setDate(dataFimSemana.getDate() + 6);\r\n\r\n        const diaSemanaBase = dataBaseSemana.getDay();\r\n\r\n        // Encontrar quais dias selecionados caem dentro desta semana do cronograma\r\n        // A semana do cronograma vai de dataBaseSemana at√© dataFimSemana (7 dias)\r\n        const diasNaSemana: number[] = [];\r\n        for (let d = 0; d < 7; d++) {\r\n          const diaSemana = (diaSemanaBase + d) % 7;\r\n          if (diasOrdenados.includes(diaSemana)) {\r\n            diasNaSemana.push(diaSemana);\r\n          }\r\n        }\r\n\r\n        // Se n√£o houver dias selecionados nesta semana, usar todos os dias selecionados\r\n        // (mas isso n√£o deveria acontecer)\r\n        const diasParaUsar =\r\n          diasNaSemana.length > 0 ? diasNaSemana : diasOrdenados;\r\n        const numDiasParaUsar = diasParaUsar.length;\r\n\r\n        // Ordenar os dias para usar na ordem correta\r\n        const diasParaUsarOrdenados = [...diasParaUsar].sort((a, b) => {\r\n          const indexA = diasOrdenados.indexOf(a);\r\n          const indexB = diasOrdenados.indexOf(b);\r\n          return indexA - indexB;\r\n        });\r\n\r\n        // Dividir itens da semana igualmente entre os dias selecionados desta semana\r\n        const totalItensSemana = itensDaSemana.length;\r\n        const itensPorDia = Math.floor(totalItensSemana / numDiasParaUsar);\r\n        const itensRestantes = totalItensSemana % numDiasParaUsar;\r\n\r\n        logDebug(`[CronogramaService] Processando semana ${semanaNumero}:`, {\r\n          totalItens: totalItensSemana,\r\n          itensPorDia,\r\n          itensRestantes,\r\n          dataBaseSemana: dataBaseSemana.toISOString().split(\"T\")[0],\r\n          dataFimSemana: dataFimSemana.toISOString().split(\"T\")[0],\r\n          diaSemanaBase,\r\n          diasNaSemana,\r\n          diasParaUsar: diasParaUsarOrdenados,\r\n          numDiasParaUsar,\r\n        });\r\n\r\n        // Inicializar contador para esta semana\r\n        contadorPorSemana[semanaNumero] = {\r\n          0: 0,\r\n          1: 0,\r\n          2: 0,\r\n          3: 0,\r\n          4: 0,\r\n          5: 0,\r\n          6: 0,\r\n        };\r\n\r\n        let indiceItem = 0;\r\n\r\n        // Distribuir itens para cada dia selecionado que cai nesta semana\r\n        for (let i = 0; i < numDiasParaUsar; i++) {\r\n          const diaSemanaEscolhido = diasParaUsarOrdenados[i];\r\n\r\n          // Calcular quantos itens este dia receber√°\r\n          // Os primeiros dias recebem um item extra se houver resto\r\n          const quantidadeItensParaEsteDia =\r\n            itensPorDia + (i < itensRestantes ? 1 : 0);\r\n\r\n          // Calcular a data deste dia na semana\r\n          // Encontrar a primeira ocorr√™ncia do dia escolhido dentro do per√≠odo de 7 dias\r\n          const dataDiaSemana = new Date(dataBaseSemana);\r\n          let diasParaAdicionar = diaSemanaEscolhido - diaSemanaBase;\r\n\r\n          // Se o dia escolhido j√° passou na semana base, est√° na pr√≥xima semana do calend√°rio\r\n          // mas ainda dentro do per√≠odo de 7 dias da semana do cronograma\r\n          if (diasParaAdicionar < 0) {\r\n            diasParaAdicionar += 7;\r\n          }\r\n\r\n          dataDiaSemana.setDate(dataDiaSemana.getDate() + diasParaAdicionar);\r\n\r\n          // Verificar se a data est√° dentro do per√≠odo de 7 dias da semana do cronograma\r\n          if (dataDiaSemana < dataBaseSemana || dataDiaSemana > dataFimSemana) {\r\n            logError(\r\n              `[CronogramaService] ‚ö†Ô∏è Data calculada est√° fora do per√≠odo da semana ${semanaNumero}:`,\r\n              {\r\n                dataBaseSemana: dataBaseSemana.toISOString().split(\"T\")[0],\r\n                dataFimSemana: dataFimSemana.toISOString().split(\"T\")[0],\r\n                dataCalculada: dataDiaSemana.toISOString().split(\"T\")[0],\r\n                diaSemanaEscolhido,\r\n                diaSemanaBase,\r\n                diasParaAdicionar,\r\n              },\r\n            );\r\n            // Ajustar para ficar dentro do per√≠odo (usar data base como fallback)\r\n            dataDiaSemana.setTime(dataBaseSemana.getTime());\r\n          }\r\n\r\n          // Atribuir itens a este dia\r\n          for (\r\n            let j = 0;\r\n            j < quantidadeItensParaEsteDia && indiceItem < totalItensSemana;\r\n            j++\r\n          ) {\r\n            const item = itensDaSemana[indiceItem];\r\n\r\n            // Garantir formato YYYY-MM-DD consistente (sem convers√£o UTC)\r\n            const year = dataDiaSemana.getFullYear();\r\n            const month = String(dataDiaSemana.getMonth() + 1).padStart(2, \"0\");\r\n            const day = String(dataDiaSemana.getDate()).padStart(2, \"0\");\r\n            const dataPrevistaFormatada = `${year}-${month}-${day}`;\r\n\r\n            atualizacoes.push({\r\n              id: item.id,\r\n              data_prevista: dataPrevistaFormatada,\r\n            });\r\n\r\n            // Contar para debug\r\n            contadorPorDia[diaSemanaEscolhido] += 1;\r\n            contadorPorSemana[semanaNumero][diaSemanaEscolhido] += 1;\r\n\r\n            indiceItem++;\r\n\r\n            // Log detalhado para primeiros itens de cada semana\r\n            if (indiceItem <= 3 || j === 0) {\r\n              logDebug(\r\n                `[CronogramaService] Semana ${semanaNumero}, Item ${indiceItem}/${totalItensSemana}:`,\r\n                {\r\n                  itemId: item.id,\r\n                  ordem_na_semana: item.ordem_na_semana,\r\n                  diaSemana: diaSemanaEscolhido,\r\n                  data_prevista: dataPrevistaFormatada,\r\n                  quantidadeItensParaEsteDia,\r\n                },\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Verificar se todos os itens da semana foram distribu√≠dos\r\n        if (indiceItem !== totalItensSemana) {\r\n          logError(\r\n            `[CronogramaService] ‚ö†Ô∏è Erro: Nem todos os itens da semana ${semanaNumero} foram distribu√≠dos!`,\r\n            {\r\n              esperado: totalItensSemana,\r\n              distribuido: indiceItem,\r\n            },\r\n          );\r\n        }\r\n      });\r\n\r\n    // Log da distribui√ß√£o final por dia da semana e por semana\r\n    const totalItens = Object.values(contadorPorDia).reduce((a, b) => a + b, 0);\r\n    const itensPorDiaSelecionado = diasOrdenados.map((dia) => ({\r\n      dia: [\r\n        \"domingo\",\r\n        \"segunda\",\r\n        \"terca\",\r\n        \"quarta\",\r\n        \"quinta\",\r\n        \"sexta\",\r\n        \"sabado\",\r\n      ][dia],\r\n      valor: dia,\r\n      quantidade: contadorPorDia[dia],\r\n      percentual:\r\n        totalItens > 0\r\n          ? ((contadorPorDia[dia] / totalItens) * 100).toFixed(1) + \"%\"\r\n          : \"0%\",\r\n    }));\r\n\r\n    logDebug(`[CronogramaService] Distribui√ß√£o final por dia da semana:`, {\r\n      total: totalItens,\r\n      dias_selecionados: diasOrdenados,\r\n      distribuicao_por_dia: itensPorDiaSelecionado,\r\n    });\r\n\r\n    // Log da distribui√ß√£o por semana\r\n    logDebug(\r\n      `[CronogramaService] Distribui√ß√£o por semana:`,\r\n      Array.from(Object.entries(contadorPorSemana)).map(\r\n        ([semana, contadores]) => ({\r\n          semana: Number(semana),\r\n          totalItens: Object.values(contadores).reduce((a, b) => a + b, 0),\r\n          porDia: diasOrdenados.map((dia) => ({\r\n            dia: [\r\n              \"domingo\",\r\n              \"segunda\",\r\n              \"terca\",\r\n              \"quarta\",\r\n              \"quinta\",\r\n              \"sexta\",\r\n              \"sabado\",\r\n            ][dia],\r\n            quantidade: contadores[dia] || 0,\r\n          })),\r\n        }),\r\n      ),\r\n    );\r\n\r\n    // Atualizar itens em lote usando chunks para melhor performance\r\n    // Processar em lotes de 100 itens por vez\r\n    const CHUNK_SIZE = 100;\r\n    let itensAtualizados = 0;\r\n    const erros: Array<{ id: string; error: string }> = [];\r\n\r\n    // Processar em chunks\r\n    for (let i = 0; i < atualizacoes.length; i += CHUNK_SIZE) {\r\n      const chunk = atualizacoes.slice(i, i + CHUNK_SIZE);\r\n\r\n      // Usar Promise.all para processar chunk em paralelo\r\n      const resultados = await Promise.allSettled(\r\n        chunk.map(async (atualizacao) => {\r\n          const { error: updateError } = await client\r\n            .from(\"cronograma_itens\")\r\n            .update({ data_prevista: atualizacao.data_prevista })\r\n            .eq(\"id\", atualizacao.id);\r\n\r\n          if (updateError) {\r\n            throw new Error(`Item ${atualizacao.id}: ${updateError.message}`);\r\n          }\r\n          return atualizacao.id;\r\n        }),\r\n      );\r\n\r\n      // Contar sucessos e erros\r\n      resultados.forEach((resultado, index) => {\r\n        if (resultado.status === \"fulfilled\") {\r\n          itensAtualizados++;\r\n        } else {\r\n          const atualizacao = chunk[index];\r\n          erros.push({\r\n            id: atualizacao.id,\r\n            error: resultado.reason?.message || \"Erro desconhecido\",\r\n          });\r\n          console.error(\r\n            `[CronogramaService] Erro ao atualizar item ${atualizacao.id}:`,\r\n            resultado.reason,\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    // Valida√ß√£o de integridade: verificar se todos os itens foram atualizados\r\n    if (itensAtualizados < atualizacoes.length) {\r\n      console.warn(\r\n        `[CronogramaService] ‚ö†Ô∏è Apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados`,\r\n      );\r\n      console.warn(\r\n        `[CronogramaService] Erros encontrados:`,\r\n        erros.slice(0, 10),\r\n      ); // Logar apenas primeiros 10 erros\r\n\r\n      // Se menos de 90% dos itens foram atualizados, considerar como falha cr√≠tica\r\n      const taxaSucesso = itensAtualizados / atualizacoes.length;\r\n      if (taxaSucesso < 0.9) {\r\n        logError(\r\n          `[CronogramaService] Falha cr√≠tica: apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados (${(taxaSucesso * 100).toFixed(1)}%)`,\r\n        );\r\n        throw new Error(\r\n          `Falha ao atualizar datas: apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados (${(taxaSucesso * 100).toFixed(1)}%)`,\r\n        );\r\n      }\r\n    }\r\n\r\n    logDebug(\r\n      `[CronogramaService] Datas recalculadas: ${itensAtualizados} de ${atualizacoes.length} itens`,\r\n    );\r\n\r\n    return { success: true, itens_atualizados: itensAtualizados };\r\n  }\r\n\r\n  /**\r\n   * Calcula estat√≠sticas detalhadas por semana do cronograma\r\n   */\r\n  async calcularEstatisticasPorSemana(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<EstatisticasSemanasResult> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usu√°rio\r\n    const { data: cronogramaRaw, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\r\n        \"id, aluno_id, data_inicio, data_fim, horas_estudo_dia, dias_estudo_semana, periodos_ferias\",\r\n      )\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronogramaRaw) {\r\n      throw new CronogramaValidationError(\"Cronograma n√£o encontrado\");\r\n    }\r\n\r\n    const cronograma = cronogramaRaw as {\r\n      id: string;\r\n      aluno_id: string;\r\n      data_inicio: string;\r\n      data_fim: string;\r\n      horas_estudo_dia: number;\r\n      dias_estudo_semana: number;\r\n      periodos_ferias: unknown;\r\n    };\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Voc√™ s√≥ pode acessar seus pr√≥prios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar todos os itens do cronograma com suas aulas\r\n    const { data: itens, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\r\n        `\r\n        id,\r\n        semana_numero,\r\n        ordem_na_semana,\r\n        concluido,\r\n        aula_id,\r\n        aulas(\r\n          id,\r\n          tempo_estimado_minutos\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .order(\"semana_numero\", { ascending: true })\r\n      .order(\"ordem_na_semana\", { ascending: true });\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar itens:\", itensError);\r\n      throw new Error(`Erro ao buscar itens: ${itensError.message}`);\r\n    }\r\n\r\n    // Calcular semanas (mesma l√≥gica do calcularSemanas)\r\n    const dataInicio = new Date(cronograma.data_inicio);\r\n    const dataFim = new Date(cronograma.data_fim);\r\n    const ferias =\r\n      (cronograma.periodos_ferias as unknown as FeriasPeriodo[]) || [];\r\n    const horasDia = cronograma.horas_estudo_dia || 0;\r\n    const diasSemana = cronograma.dias_estudo_semana || 0;\r\n    const velocidadeReproducao = cronograma.velocidade_reproducao ?? 1.0;\r\n\r\n    const semanas = this.calcularSemanas(\r\n      dataInicio,\r\n      dataFim,\r\n      ferias,\r\n      horasDia,\r\n      diasSemana,\r\n    );\r\n\r\n    // Agrupar itens por semana\r\n    // Tipo helper para itens com dados aninhados do Supabase\r\n    type ItemComDados = {\r\n      id: string;\r\n      semana_numero: number;\r\n      ordem_na_semana: number;\r\n      concluido?: boolean | null;\r\n      aula_id: string;\r\n      aulas?: {\r\n        id: string;\r\n        tempo_estimado_minutos?: number | null;\r\n      } | null;\r\n    };\r\n\r\n    const itensPorSemana = new Map<number, ItemComDados[]>();\r\n    ((itens as unknown as ItemComDados[]) || []).forEach((item) => {\r\n      const semanaNum = item.semana_numero;\r\n      if (!itensPorSemana.has(semanaNum)) {\r\n        itensPorSemana.set(semanaNum, []);\r\n      }\r\n      itensPorSemana.get(semanaNum)!.push(item);\r\n    });\r\n\r\n    // Calcular estat√≠sticas para cada semana\r\n    const semanasEstatisticas: SemanaEstatisticas[] = semanas.map((semana) => {\r\n      const itensDaSemana = itensPorSemana.get(semana.numero) || [];\r\n\r\n      // Calcular tempo usado (soma dos custos das aulas)\r\n      let tempoUsado = 0;\r\n      let totalAulas = 0;\r\n      let aulasConcluidas = 0;\r\n\r\n      itensDaSemana.forEach((item) => {\r\n        const aula = Array.isArray(item.aulas) ? item.aulas[0] : item.aulas;\r\n        if (!aula) return;\r\n\r\n        totalAulas++;\r\n        if (item.concluido) {\r\n          aulasConcluidas++;\r\n        }\r\n\r\n        // Calcular custo (mesma l√≥gica do gerarCronograma)\r\n        const tempoOriginal =\r\n          aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS;\r\n        const tempoAulaAjustado = tempoOriginal / velocidadeReproducao;\r\n        const custo = tempoAulaAjustado * FATOR_MULTIPLICADOR;\r\n        tempoUsado += custo;\r\n      });\r\n\r\n      const capacidade = semana.capacidade_minutos;\r\n      const tempoDisponivel = Math.max(0, capacidade - tempoUsado);\r\n      const percentualUsado =\r\n        capacidade > 0 ? (tempoUsado / capacidade) * 100 : 0;\r\n      const aulasPendentes = totalAulas - aulasConcluidas;\r\n\r\n      return {\r\n        semana_numero: semana.numero,\r\n        data_inicio: semana.data_inicio.toISOString(),\r\n        data_fim: semana.data_fim.toISOString(),\r\n        capacidade_minutos: capacidade,\r\n        tempo_usado_minutos: Math.round(tempoUsado * 100) / 100, // Arredondar para 2 casas decimais\r\n        tempo_disponivel_minutos: Math.round(tempoDisponivel * 100) / 100,\r\n        percentual_usado: Math.round(percentualUsado * 100) / 100,\r\n        is_ferias: semana.is_ferias,\r\n        total_aulas: totalAulas,\r\n        aulas_concluidas: aulasConcluidas,\r\n        aulas_pendentes: aulasPendentes,\r\n      };\r\n    });\r\n\r\n    // Calcular resumo geral\r\n    const semanasUteis = semanasEstatisticas.filter((s) => !s.is_ferias);\r\n    const capacidadeTotal = semanasUteis.reduce(\r\n      (acc, s) => acc + s.capacidade_minutos,\r\n      0,\r\n    );\r\n    const tempoTotalUsado = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.tempo_usado_minutos,\r\n      0,\r\n    );\r\n    const tempoTotalDisponivel = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.tempo_disponivel_minutos,\r\n      0,\r\n    );\r\n    const percentualMedioUsado =\r\n      semanasUteis.length > 0\r\n        ? semanasUteis.reduce((acc, s) => acc + s.percentual_usado, 0) /\r\n          semanasUteis.length\r\n        : 0;\r\n    const totalAulas = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.total_aulas,\r\n      0,\r\n    );\r\n    const totalAulasConcluidas = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.aulas_concluidas,\r\n      0,\r\n    );\r\n    const semanasSobrecarregadas = semanasEstatisticas.filter(\r\n      (s) => s.percentual_usado > 100,\r\n    ).length;\r\n\r\n    return {\r\n      success: true,\r\n      semanas: semanasEstatisticas,\r\n      resumo: {\r\n        total_semanas: semanasEstatisticas.length,\r\n        semanas_uteis: semanasUteis.length,\r\n        semanas_ferias: semanasEstatisticas.length - semanasUteis.length,\r\n        capacidade_total_minutos: Math.round(capacidadeTotal * 100) / 100,\r\n        tempo_total_usado_minutos: Math.round(tempoTotalUsado * 100) / 100,\r\n        tempo_total_disponivel_minutos:\r\n          Math.round(tempoTotalDisponivel * 100) / 100,\r\n        percentual_medio_usado: Math.round(percentualMedioUsado * 100) / 100,\r\n        total_aulas: totalAulas,\r\n        total_aulas_concluidas: totalAulasConcluidas,\r\n        semanas_sobrecarregadas: semanasSobrecarregadas,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cria distribui√ß√£o padr√£o ao gerar um novo cronograma\r\n   */\r\n  private async criarDistribuicaoPadrao(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    cronogramaId: string,\r\n    diasEstudoSemana: number,\r\n  ): Promise<void> {\r\n    // Calcular dias padr√£o baseado em dias_estudo_semana\r\n    // Se dias_estudo_semana = 5, usar segunda a sexta [1,2,3,4,5]\r\n    // Se dias_estudo_semana = 3, usar segunda, quarta, sexta [1,3,5]\r\n    // etc.\r\n    let diasPadrao: number[] = [];\r\n\r\n    if (diasEstudoSemana >= 5) {\r\n      diasPadrao = [1, 2, 3, 4, 5]; // Segunda a sexta\r\n    } else if (diasEstudoSemana === 4) {\r\n      diasPadrao = [1, 2, 4, 5]; // Segunda, ter√ßa, quinta, sexta\r\n    } else if (diasEstudoSemana === 3) {\r\n      diasPadrao = [1, 3, 5]; // Segunda, quarta, sexta\r\n    } else if (diasEstudoSemana === 2) {\r\n      diasPadrao = [1, 4]; // Segunda e quinta\r\n    } else {\r\n      diasPadrao = [1]; // Apenas segunda\r\n    }\r\n\r\n    const { error } = await client.from(\"cronograma_semanas_dias\").insert({\r\n      cronograma_id: cronogramaId,\r\n      dias_semana: diasPadrao,\r\n    });\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao criar distribui√ß√£o padr√£o:\",\r\n        error,\r\n      );\r\n      // N√£o lan√ßar erro, apenas logar - a distribui√ß√£o pode ser criada depois\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] Distribui√ß√£o padr√£o criada:\",\r\n        diasPadrao,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const cronogramaService = new CronogramaService();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\auth-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15383,15386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15383,15386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Auth Pattern Analyzer\r\n *\r\n * Analyzes authentication and authorization patterns in the codebase\r\n * to identify inconsistencies, redundancies, and unnecessary complexity.\r\n *\r\n * Detects:\r\n * - Multiple auth client instantiation patterns\r\n * - Inconsistent permission checking approaches\r\n * - Inconsistent session management\r\n * - Redundant auth middleware\r\n * - Unnecessary auth wrapper functions\r\n */\r\n\r\nimport { SourceFile, Node, ArrowFunction } from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Pattern for tracking auth client instantiation\r\n */\r\ninterface AuthClientPattern {\r\n  functionName: string;\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking permission checks\r\n */\r\ninterface PermissionCheckPattern {\r\n  type: \"role\" | \"permission\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking session management\r\n */\r\ninterface SessionPattern {\r\n  type: \"cookie\" | \"token\" | \"supabase\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Analyzer for authentication and authorization patterns\r\n */\r\nexport class AuthPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"AuthPatternAnalyzer\";\r\n\r\n  private authClientPatterns: AuthClientPattern[] = [];\r\n  private permissionCheckPatterns: PermissionCheckPattern[] = [];\r\n  private sessionPatterns: SessionPattern[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"api-route\", \"service\", \"middleware\", \"util\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for auth-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 5.1: Detect auth client instantiation patterns\r\n    issues.push(...this.detectAuthClientPatterns(file, ast));\r\n\r\n    // Task 5.2: Detect auth inconsistencies\r\n    issues.push(...this.detectAuthInconsistencies(file, ast));\r\n\r\n    // Task 5.3: Detect unnecessary auth adapters\r\n    issues.push(...this.detectUnnecessaryAuthAdapters(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.1: Auth Client Instantiation Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect multiple patterns for creating auth clients\r\n   * Validates Requirements: 2.1\r\n   */\r\n  private detectAuthClientPatterns(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Common auth client creation patterns\r\n    const authClientPatterns = [\r\n      \"createClient\",\r\n      \"getSupabaseClient\",\r\n      \"initSupabase\",\r\n      \"createSupabaseClient\",\r\n      \"getAuthClient\",\r\n      \"initAuth\",\r\n      \"createAuthClient\",\r\n      \"supabaseClient\",\r\n      \"getClient\",\r\n      \"initClient\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Check if this is an auth client creation call\r\n      for (const pattern of authClientPatterns) {\r\n        if (callText.includes(pattern)) {\r\n          // Track this pattern\r\n          this.authClientPatterns.push({\r\n            functionName: pattern,\r\n            node: call,\r\n            file: file.relativePath,\r\n          });\r\n\r\n          // If we've seen multiple different patterns, flag as inconsistent\r\n          const uniquePatterns = new Set(\r\n            this.authClientPatterns.map((p) => p.functionName),\r\n          );\r\n          if (uniquePatterns.size > 1) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: \"inconsistent-pattern\",\r\n                severity: \"medium\",\r\n                category: \"authentication\",\r\n                file: file.relativePath,\r\n                node: call,\r\n                description: `Inconsistent auth client instantiation pattern detected. Found ${uniquePatterns.size} different patterns: ${Array.from(uniquePatterns).join(\", \")}`,\r\n                recommendation:\r\n                  \"Standardize auth client creation to use a single pattern across the codebase. Consider creating a centralized auth client factory function.\",\r\n                estimatedEffort: \"medium\",\r\n                tags: [\"auth\", \"inconsistency\", \"client-instantiation\"],\r\n              }),\r\n            );\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.2: Auth Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent permission checking, session management, and redundant middleware\r\n   * Validates Requirements: 2.2, 2.3, 2.4\r\n   */\r\n  private detectAuthInconsistencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect inconsistent permission checking\r\n    issues.push(...this.detectInconsistentPermissionChecks(file, ast));\r\n\r\n    // Detect inconsistent session management\r\n    issues.push(...this.detectInconsistentSessionManagement(file, ast));\r\n\r\n    // Detect redundant auth middleware\r\n    issues.push(...this.detectRedundantAuthMiddleware(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent permission checking patterns\r\n   * Validates Requirements: 2.2\r\n   */\r\n  private detectInconsistentPermissionChecks(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Permission checking patterns\r\n    const roleCheckPatterns = [\r\n      \"checkRole\",\r\n      \"hasRole\",\r\n      \"isRole\",\r\n      \"role ===\",\r\n      \"role ==\",\r\n    ];\r\n    const permissionCheckPatterns = [\r\n      \"checkPermission\",\r\n      \"hasPermission\",\r\n      \"can\",\r\n      \"permissions.includes\",\r\n    ];\r\n    const customCheckPatterns = [\r\n      \"checkAuth\",\r\n      \"isAuthorized\",\r\n      \"authorize\",\r\n      \"verifyAccess\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of permission check\r\n      let checkType: \"role\" | \"permission\" | \"custom\" | null = null;\r\n\r\n      if (roleCheckPatterns.some((pattern) => callText.includes(pattern))) {\r\n        checkType = \"role\";\r\n      } else if (\r\n        permissionCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"permission\";\r\n      } else if (\r\n        customCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"custom\";\r\n      }\r\n\r\n      if (checkType) {\r\n        this.permissionCheckPatterns.push({\r\n          type: checkType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different check types, flag as inconsistent\r\n        const uniqueCheckTypes = new Set(\r\n          this.permissionCheckPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueCheckTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent permission checking approach detected. Found ${uniqueCheckTypes.size} different approaches: ${Array.from(uniqueCheckTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize permission checking to use a single approach (either role-based, permission-based, or a custom unified approach). This improves maintainability and reduces security risks.\",\r\n              estimatedEffort: \"medium\",\r\n              tags: [\"auth\", \"permissions\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent session management\r\n   * Validates Requirements: 2.4\r\n   */\r\n  private detectInconsistentSessionManagement(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Session management patterns\r\n    const cookiePatterns = [\"cookies()\", \"getCookie\", \"setCookie\", \"cookie.\"];\r\n    const tokenPatterns = [\"getToken\", \"setToken\", \"token\", \"jwt\", \"bearer\"];\r\n    const supabasePatterns = [\r\n      \"getSession\",\r\n      \"setSession\",\r\n      \"session.user\",\r\n      \"auth.getUser\",\r\n    ];\r\n    const customPatterns = [\"getAuth\", \"setAuth\", \"authSession\"];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of session management\r\n      let sessionType: \"cookie\" | \"token\" | \"supabase\" | \"custom\" | null = null;\r\n\r\n      if (cookiePatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"cookie\";\r\n      } else if (tokenPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"token\";\r\n      } else if (\r\n        supabasePatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        sessionType = \"supabase\";\r\n      } else if (customPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"custom\";\r\n      }\r\n\r\n      if (sessionType) {\r\n        this.sessionPatterns.push({\r\n          type: sessionType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different session types, flag as inconsistent\r\n        const uniqueSessionTypes = new Set(\r\n          this.sessionPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueSessionTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent session management detected. Found ${uniqueSessionTypes.size} different approaches: ${Array.from(uniqueSessionTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize session management to use a single approach. For Supabase projects, prefer using Supabase's built-in session management.\",\r\n              estimatedEffort: \"large\",\r\n              tags: [\"auth\", \"session\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect redundant auth middleware\r\n   * Validates Requirements: 2.3\r\n   */\r\n  private detectRedundantAuthMiddleware(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Only check middleware files\r\n    if (\r\n      file.category !== \"middleware\" &&\r\n      !file.relativePath.includes(\"middleware\")\r\n    ) {\r\n      return issues;\r\n    }\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    // Track middleware functions that perform auth checks\r\n    const authMiddlewareFunctions: Node[] = [];\r\n\r\n    for (const func of functions) {\r\n      const funcText = func.getText();\r\n\r\n      // Check if this function performs auth checks\r\n      const authKeywords = [\r\n        \"auth\",\r\n        \"authenticate\",\r\n        \"authorize\",\r\n        \"checkAuth\",\r\n        \"verifyAuth\",\r\n        \"getUser\",\r\n        \"getSession\",\r\n        \"checkPermission\",\r\n        \"checkRole\",\r\n      ];\r\n\r\n      if (\r\n        authKeywords.some((keyword) =>\r\n          funcText.toLowerCase().includes(keyword.toLowerCase()),\r\n        )\r\n      ) {\r\n        authMiddlewareFunctions.push(func);\r\n      }\r\n    }\r\n\r\n    // If we have multiple auth middleware functions in the same file, flag as redundant\r\n    if (authMiddlewareFunctions.length > 1) {\r\n      for (const func of authMiddlewareFunctions) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"code-duplication\",\r\n            severity: \"medium\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Redundant auth middleware detected. Found ${authMiddlewareFunctions.length} auth middleware functions in the same file.`,\r\n            recommendation:\r\n              \"Consolidate auth middleware into a single, reusable function. Consider creating a composable middleware pattern if different auth checks are needed.\",\r\n            estimatedEffort: \"small\",\r\n            tags: [\"auth\", \"middleware\", \"duplication\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.3: Unnecessary Auth Adapter Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect simple pass-through auth wrapper functions\r\n   * Validates Requirements: 2.5\r\n   */\r\n  private detectUnnecessaryAuthAdapters(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const _funcText = func.getText();\r\n      const funcName = this.getNodeName(func);\r\n\r\n      // Skip if no name or not auth-related\r\n      if (!funcName || !this.isAuthRelated(funcName)) {\r\n        continue;\r\n      }\r\n\r\n      // Check if this is a simple pass-through wrapper\r\n      if (this.isPassThroughWrapper(func)) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"unnecessary-adapter\",\r\n            severity: \"low\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Unnecessary auth adapter detected: \"${funcName}\". This function appears to be a simple pass-through wrapper that adds no meaningful value.`,\r\n            recommendation:\r\n              \"Remove this wrapper function and call the underlying auth function directly. This reduces code complexity and improves maintainability.\",\r\n            estimatedEffort: \"trivial\",\r\n            tags: [\"auth\", \"adapter\", \"unnecessary\", \"wrapper\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Check if a function name is auth-related\r\n   */\r\n  private isAuthRelated(name: string): boolean {\r\n    const authKeywords = [\r\n      \"auth\",\r\n      \"authenticate\",\r\n      \"authorize\",\r\n      \"login\",\r\n      \"logout\",\r\n      \"session\",\r\n      \"user\",\r\n      \"permission\",\r\n      \"role\",\r\n      \"access\",\r\n      \"token\",\r\n      \"credential\",\r\n    ];\r\n\r\n    const lowerName = name.toLowerCase();\r\n    return authKeywords.some((keyword) => lowerName.includes(keyword));\r\n  }\r\n\r\n  /**\r\n   * Check if a function is a simple pass-through wrapper\r\n   */\r\n  private isPassThroughWrapper(func: Node): boolean {\r\n    const funcText = func.getText();\r\n\r\n    // Get the function body\r\n    let body: Node | undefined;\r\n\r\n    if (Node.isFunctionDeclaration(func) || Node.isFunctionExpression(func)) {\r\n      body = (func as any).getBody();\r\n    } else if (Node.isArrowFunction(func)) {\r\n      const _arrowBody = (func as ArrowFunction).getBody();\r\n    }\r\n\r\n    if (!body) {\r\n      return false;\r\n    }\r\n\r\n    const bodyText = body.getText().trim();\r\n\r\n    // Check for simple pass-through patterns:\r\n    // 1. Single return statement with a function call\r\n    // 2. Single line arrow function that just calls another function\r\n    // 3. Function that just returns the result of another function call\r\n\r\n    // Pattern 1: { return someFunction(...) }\r\n    const singleReturnPattern = /^\\{\\s*return\\s+\\w+\\([^)]*\\)\\s*;?\\s*\\}$/;\r\n    if (singleReturnPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 2: Arrow function: (...) => someFunction(...)\r\n    const arrowPassThroughPattern = /^\\w+\\([^)]*\\)$/;\r\n    if (Node.isArrowFunction(func) && arrowPassThroughPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 3: Check if body has only one statement that's a return with a call\r\n    if (Node.isBlock(body)) {\r\n      const statements = body.getStatements();\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        if (Node.isReturnStatement(statement)) {\r\n          const expression = statement.getExpression();\r\n          if (expression && Node.isCallExpression(expression)) {\r\n            // This is a simple pass-through: just returns a function call\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Pattern 4: Arrow function with single call expression\r\n    if (Node.isArrowFunction(func)) {\r\n      const arrowBody = (func as ArrowFunction).getBody();\r\n      if (Node.isCallExpression(arrowBody)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\component-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":810,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":810,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24922,24925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24922,24925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":865,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":865,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27036,27039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27036,27039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":917,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":917,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29027,29030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29027,29030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Component Pattern Analyzer\r\n *\r\n * Analyzes React component structure and patterns in the codebase to identify\r\n * component quality issues and inconsistencies.\r\n *\r\n * Detects:\r\n * - React function components\r\n * - React class components\r\n * - Component categorization by type\r\n * - Components with business logic that should be in services\r\n * - Excessive prop drilling (more than 3 levels)\r\n * - Duplicate component logic\r\n * - Inconsistent component composition patterns\r\n * - Components mixing concerns (UI + data fetching + business logic)\r\n */\r\n\r\nimport {\r\n  SourceFile,\r\n  Node,\r\n  FunctionDeclaration,\r\n  ArrowFunction,\r\n  ClassDeclaration,\r\n  VariableDeclaration,\r\n} from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Information about a discovered React component\r\n */\r\ninterface ComponentInfo {\r\n  name: string;\r\n  type: \"function\" | \"class\" | \"arrow\";\r\n  node: Node;\r\n  file: string;\r\n  isExported: boolean;\r\n  hasProps: boolean;\r\n  usesHooks: boolean;\r\n  usesState: boolean;\r\n}\r\n\r\n/**\r\n * Information about a prop chain through component hierarchy\r\n */\r\ninterface PropChain {\r\n  propName: string;\r\n  depth: number;\r\n  componentPath: string[];\r\n  startNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for React component patterns\r\n */\r\nexport class ComponentPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"ComponentPatternAnalyzer\";\r\n\r\n  private discoveredComponents: ComponentInfo[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"component\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for component-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    // Reset state for each file analysis\r\n    this.discoveredComponents = [];\r\n\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 7.1: Discover and categorize React components\r\n    issues.push(...this.discoverComponents(file, ast));\r\n\r\n    // Task 7.2: Detect prop drilling\r\n    issues.push(...this.detectPropDrilling(file, ast));\r\n\r\n    // Task 7.3: Detect component pattern inconsistencies and duplicate logic\r\n    issues.push(...this.detectComponentPatternInconsistencies(file, ast));\r\n    issues.push(...this.detectDuplicateComponentLogic(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.1: Component Discovery and Categorization\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover all React components (function and class components) and categorize them\r\n   * Validates Requirements: 6.1\r\n   */\r\n  private discoverComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Discover function components\r\n    issues.push(...this.discoverFunctionComponents(file, ast));\r\n\r\n    // Discover class components\r\n    issues.push(...this.discoverClassComponents(file, ast));\r\n\r\n    // Discover arrow function components\r\n    issues.push(...this.discoverArrowFunctionComponents(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React function components (function declarations)\r\n   */\r\n  private discoverFunctionComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const functionDeclarations = ast.getFunctions();\r\n\r\n    for (const func of functionDeclarations) {\r\n      const funcName = func.getName();\r\n      if (!funcName) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(func, funcName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: funcName,\r\n          type: \"function\",\r\n          node: func,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(func),\r\n          hasProps: this.hasParameters(func),\r\n          usesHooks: this.usesReactHooks(func),\r\n          usesState: this.usesStateHook(func),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Log discovery (not an issue, just tracking)\r\n        // We don't create issues for valid components, only for problems\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React class components\r\n   */\r\n  private discoverClassComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const classDeclarations = this.getClassDeclarations(ast);\r\n\r\n    for (const classDecl of classDeclarations) {\r\n      const className = this.getNodeName(classDecl);\r\n      if (!className) continue;\r\n\r\n      // Cast to ClassDeclaration for type safety\r\n      if (!Node.isClassDeclaration(classDecl)) continue;\r\n\r\n      // Check if this class extends React.Component or React.PureComponent\r\n      if (this.isReactClassComponent(classDecl)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: className,\r\n          type: \"class\",\r\n          node: classDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(classDecl),\r\n          hasProps: this.classHasProps(classDecl),\r\n          usesHooks: false, // Class components don't use hooks\r\n          usesState: this.classHasState(classDecl),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Flag class components as potentially outdated pattern\r\n        // Modern React prefers function components with hooks\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"legacy-code\",\r\n            severity: \"low\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: classDecl,\r\n            description: `Class component '${className}' detected. Modern React development favors function components with hooks for better code reuse and simpler patterns.`,\r\n            recommendation: `Consider refactoring '${className}' to a function component using hooks (useState, useEffect, etc.). This improves code readability and enables better composition with custom hooks.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\"component\", \"class-component\", \"modernization\", \"hooks\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React arrow function components (variable declarations with arrow functions)\r\n   */\r\n  private discoverArrowFunctionComponents(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n\r\n    for (const varDecl of variableDeclarations) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (!varName) continue;\r\n\r\n      // Cast to VariableDeclaration to access getInitializer\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const initializer = varDecl.getInitializer();\r\n      if (!initializer || !Node.isArrowFunction(initializer)) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(initializer, varName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: varName,\r\n          type: \"arrow\",\r\n          node: varDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(varDecl),\r\n          hasProps: this.hasParameters(initializer),\r\n          usesHooks: this.usesReactHooks(initializer),\r\n          usesState: this.usesStateHook(initializer),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Component Detection Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a function/arrow function is a React component\r\n   * React components:\r\n   * - Start with uppercase letter (PascalCase)\r\n   * - Return JSX (contains JSX elements)\r\n   * - May use React hooks\r\n   */\r\n  private isReactComponent(node: Node, name: string): boolean {\r\n    // Check 1: Name starts with uppercase (PascalCase convention)\r\n    if (!this.isPascalCase(name)) {\r\n      return false;\r\n    }\r\n\r\n    // Check 2: Returns JSX or uses React hooks\r\n    const returnsJSX = this.returnsJSX(node);\r\n    const usesHooks = this.usesReactHooks(node);\r\n\r\n    return returnsJSX || usesHooks;\r\n  }\r\n\r\n  /**\r\n   * Check if a class is a React component\r\n   */\r\n  private isReactClassComponent(classDecl: ClassDeclaration): boolean {\r\n    const heritage = classDecl.getExtends();\r\n    if (!heritage) return false;\r\n\r\n    const heritageText = heritage.getText();\r\n\r\n    // Check if extends React.Component, React.PureComponent, Component, or PureComponent\r\n    return (\r\n      heritageText.includes(\"React.Component\") ||\r\n      heritageText.includes(\"React.PureComponent\") ||\r\n      heritageText === \"Component\" ||\r\n      heritageText === \"PureComponent\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if a name follows PascalCase convention\r\n   */\r\n  private isPascalCase(name: string): boolean {\r\n    // PascalCase: starts with uppercase, contains at least one letter\r\n    return /^[A-Z][a-zA-Z0-9]*$/.test(name) && name.length > 1;\r\n  }\r\n\r\n  /**\r\n   * Check if a function returns JSX\r\n   */\r\n  private returnsJSX(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Look for JSX patterns:\r\n    // - JSX elements: <div>, <Component>\r\n    // - JSX fragments: <>, </>\r\n    // - Return statements with JSX\r\n    const jsxPatterns = [\r\n      /<[A-Z][a-zA-Z0-9]*[\\s>\\/]/, // Component tags: <MyComponent\r\n      /<[a-z][a-zA-Z0-9]*[\\s>\\/]/, // HTML tags: <div\r\n      /<>/, // Fragment opening\r\n      /<\\/>/, // Fragment closing\r\n      /return\\s*\\(/, // Return with parentheses (common for JSX)\r\n    ];\r\n\r\n    return jsxPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses React hooks\r\n   */\r\n  private usesReactHooks(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Common React hooks\r\n    const hookPatterns = [\r\n      /\\buse[A-Z][a-zA-Z0-9]*\\(/, // Any hook: useState, useEffect, useCustomHook\r\n      /\\buseState\\(/,\r\n      /\\buseEffect\\(/,\r\n      /\\buseContext\\(/,\r\n      /\\buseReducer\\(/,\r\n      /\\buseCallback\\(/,\r\n      /\\buseMemo\\(/,\r\n      /\\buseRef\\(/,\r\n      /\\buseImperativeHandle\\(/,\r\n      /\\buseLayoutEffect\\(/,\r\n      /\\buseDebugValue\\(/,\r\n    ];\r\n\r\n    return hookPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses useState hook\r\n   */\r\n  private usesStateHook(node: Node): boolean {\r\n    const text = node.getText();\r\n    return /\\buseState\\(/.test(text);\r\n  }\r\n\r\n  /**\r\n   * Check if a function has parameters\r\n   */\r\n  private hasParameters(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      return node.getParameters().length > 0;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has props\r\n   */\r\n  private classHasProps(classDecl: ClassDeclaration): boolean {\r\n    // Check constructor parameters\r\n    const constructors = classDecl.getConstructors();\r\n    for (const constructor of constructors) {\r\n      if (constructor.getParameters().length > 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check if props are accessed in the class\r\n    const classText = classDecl.getText();\r\n    return classText.includes(\"this.props\");\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has state\r\n   */\r\n  private classHasState(classDecl: ClassDeclaration): boolean {\r\n    const classText = classDecl.getText();\r\n\r\n    // Check for state initialization or usage\r\n    return classText.includes(\"this.state\") || classText.includes(\"setState(\");\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.2: Prop Drilling Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive prop drilling (props passed through more than 3 levels)\r\n   * Validates Requirements: 6.3\r\n   */\r\n  private detectPropDrilling(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all JSX elements in the file\r\n    const jsxElements = this.findJSXElements(ast);\r\n\r\n    // Track prop chains through component hierarchy\r\n    const propChains = this.buildPropChains(jsxElements, ast);\r\n\r\n    // Flag chains exceeding 3 levels\r\n    for (const chain of propChains) {\r\n      if (chain.depth > 3) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"confusing-logic\",\r\n            severity: \"medium\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: chain.startNode,\r\n            description: `Prop drilling detected: prop '${chain.propName}' is passed through ${chain.depth} levels of components (${chain.componentPath.join(\" ‚Üí \")}). This makes the code harder to maintain and understand.`,\r\n            recommendation: `Consider using React Context, a state management library (Redux, Zustand), or component composition patterns to avoid passing '${chain.propName}' through ${chain.depth} levels. This will make the code more maintainable and reduce coupling between components.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\r\n              \"component\",\r\n              \"prop-drilling\",\r\n              \"state-management\",\r\n              \"refactoring\",\r\n            ],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in the AST\r\n   */\r\n  private findJSXElements(ast: SourceFile): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (node: Node) => {\r\n      const kind = node.getKind();\r\n\r\n      // JSX element types\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement ||\r\n        kind === SyntaxKind.JsxFragment\r\n      ) {\r\n        jsxElements.push(node);\r\n      }\r\n\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Build prop chains by tracking props through component hierarchy\r\n   */\r\n  private buildPropChains(jsxElements: Node[], ast: SourceFile): PropChain[] {\r\n    const chains: PropChain[] = [];\r\n\r\n    // For each component in the file, track its props\r\n    for (const component of this.discoveredComponents) {\r\n      const componentNode = component.node;\r\n      const componentName = component.name;\r\n\r\n      // Get the props parameter\r\n      const props = this.getComponentProps(componentNode);\r\n      if (!props || props.length === 0) continue;\r\n\r\n      // For each prop, track where it's passed down\r\n      for (const propName of props) {\r\n        const chain = this.trackPropThroughHierarchy(\r\n          propName,\r\n          componentName,\r\n          componentNode,\r\n          ast,\r\n          1,\r\n        );\r\n\r\n        if (chain && chain.depth > 1) {\r\n          chains.push(chain);\r\n        }\r\n      }\r\n    }\r\n\r\n    return chains;\r\n  }\r\n\r\n  /**\r\n   * Get the props from a component (parameter names)\r\n   */\r\n  private getComponentProps(componentNode: Node): string[] {\r\n    const props: string[] = [];\r\n\r\n    // Handle function components\r\n    if (\r\n      Node.isFunctionDeclaration(componentNode) ||\r\n      Node.isArrowFunction(componentNode)\r\n    ) {\r\n      const params = componentNode.getParameters();\r\n      if (params.length > 0) {\r\n        const propsParam = params[0];\r\n\r\n        // Handle destructured props: function MyComponent({ prop1, prop2 })\r\n        const binding = propsParam.getNameNode();\r\n        if (Node.isObjectBindingPattern(binding)) {\r\n          const elements = binding.getElements();\r\n          for (const element of elements) {\r\n            const name = element.getName();\r\n            if (name) {\r\n              props.push(name);\r\n            }\r\n          }\r\n        } else {\r\n          // Handle props object: function MyComponent(props)\r\n          const paramName = propsParam.getName();\r\n          if (paramName) {\r\n            // Look for props.propName usage in the component\r\n            const componentText = componentNode.getText();\r\n            const propAccessPattern = new RegExp(\r\n              `${paramName}\\\\.([a-zA-Z_$][a-zA-Z0-9_$]*)`,\r\n              \"g\",\r\n            );\r\n            let match;\r\n            while ((match = propAccessPattern.exec(componentText)) !== null) {\r\n              const propName = match[1];\r\n              if (!props.includes(propName)) {\r\n                props.push(propName);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle variable declarations with arrow functions\r\n    if (Node.isVariableDeclaration(componentNode)) {\r\n      const initializer = componentNode.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.getComponentProps(initializer);\r\n      }\r\n    }\r\n\r\n    return props;\r\n  }\r\n\r\n  /**\r\n   * Track a prop through the component hierarchy to detect drilling\r\n   */\r\n  private trackPropThroughHierarchy(\r\n    propName: string,\r\n    currentComponent: string,\r\n    componentNode: Node,\r\n    ast: SourceFile,\r\n    currentDepth: number,\r\n    visitedComponents: Set<string> = new Set(),\r\n  ): PropChain | null {\r\n    // Prevent infinite recursion\r\n    if (visitedComponents.has(currentComponent)) {\r\n      return null;\r\n    }\r\n    visitedComponents.add(currentComponent);\r\n\r\n    // Maximum depth to track (prevent excessive recursion)\r\n    if (currentDepth > 10) {\r\n      return null;\r\n    }\r\n\r\n    const componentPath = [currentComponent];\r\n    let maxDepth = currentDepth;\r\n    let deepestNode = componentNode;\r\n\r\n    // Find JSX elements within this component that pass the prop down\r\n    const jsxElements = this.findJSXElementsInNode(componentNode);\r\n\r\n    for (const jsxElement of jsxElements) {\r\n      const childComponentName = this.getJSXElementName(jsxElement);\r\n      if (!childComponentName) continue;\r\n\r\n      // Check if this JSX element passes the prop down\r\n      if (this.jsxElementPassesProp(jsxElement, propName)) {\r\n        // Find the child component definition\r\n        const childComponent = this.discoveredComponents.find(\r\n          (comp) => comp.name === childComponentName,\r\n        );\r\n\r\n        if (childComponent) {\r\n          // Recursively track the prop in the child component\r\n          const childChain = this.trackPropThroughHierarchy(\r\n            propName,\r\n            childComponentName,\r\n            childComponent.node,\r\n            ast,\r\n            currentDepth + 1,\r\n            new Set(visitedComponents),\r\n          );\r\n\r\n          if (childChain && childChain.depth > maxDepth) {\r\n            maxDepth = childChain.depth;\r\n            componentPath.push(...childChain.componentPath);\r\n            deepestNode = childChain.startNode;\r\n          }\r\n        } else {\r\n          // Child component not found in this file, assume it's passed one more level\r\n          componentPath.push(childComponentName);\r\n          maxDepth = currentDepth + 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxDepth > currentDepth) {\r\n      return {\r\n        propName,\r\n        depth: maxDepth,\r\n        componentPath,\r\n        startNode: deepestNode,\r\n      };\r\n    }\r\n\r\n    return {\r\n      propName,\r\n      depth: currentDepth,\r\n      componentPath,\r\n      startNode: componentNode,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find JSX elements within a specific node\r\n   */\r\n  private findJSXElementsInNode(node: Node): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      const kind = n.getKind();\r\n\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement\r\n      ) {\r\n        jsxElements.push(n);\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Get the component name from a JSX element\r\n   */\r\n  private getJSXElementName(jsxElement: Node): string | null {\r\n    const text = jsxElement.getText();\r\n\r\n    // Match opening tag: <ComponentName or <ComponentName>\r\n    const match = text.match(/^<([A-Z][a-zA-Z0-9]*)/);\r\n    if (match) {\r\n      return match[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if a JSX element passes a specific prop down\r\n   */\r\n  private jsxElementPassesProp(jsxElement: Node, propName: string): boolean {\r\n    const text = jsxElement.getText();\r\n\r\n    // Look for patterns like:\r\n    // - propName={propName}\r\n    // - propName={props.propName}\r\n    // - {...props} (spread operator)\r\n    const patterns = [\r\n      new RegExp(`\\\\b${propName}=\\\\{${propName}\\\\}`), // propName={propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{props\\\\.${propName}\\\\}`), // propName={props.propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{[^}]*${propName}[^}]*\\\\}`), // propName={...propName...}\r\n      /\\{\\.\\.\\.props\\}/, // {...props}\r\n      /\\{\\.\\.\\.rest\\}/, // {...rest}\r\n    ];\r\n\r\n    return patterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing discovered components\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered components\r\n   */\r\n  public getDiscoveredComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents;\r\n  }\r\n\r\n  /**\r\n   * Get components by type\r\n   */\r\n  public getComponentsByType(\r\n    type: \"function\" | \"class\" | \"arrow\",\r\n  ): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.type === type);\r\n  }\r\n\r\n  /**\r\n   * Get exported components\r\n   */\r\n  public getExportedComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.isExported);\r\n  }\r\n\r\n  /**\r\n   * Get components that use hooks\r\n   */\r\n  public getComponentsUsingHooks(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesHooks);\r\n  }\r\n\r\n  /**\r\n   * Get components that use state\r\n   */\r\n  public getComponentsUsingState(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesState);\r\n  }\r\n\r\n  /**\r\n   * Clear discovered components (useful for testing or re-analysis)\r\n   */\r\n  public clearDiscoveredComponents(): void {\r\n    this.discoveredComponents = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Component Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent component composition patterns\r\n   * Validates Requirements: 6.4\r\n   *\r\n   * Detects:\r\n   * - Inconsistent prop passing patterns (destructuring vs object)\r\n   * - Inconsistent export patterns (default vs named)\r\n   * - Inconsistent component definition styles (function vs arrow)\r\n   * - Inconsistent hook usage patterns\r\n   * - Inconsistent event handler naming\r\n   */\r\n  private detectComponentPatternInconsistencies(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Analyze patterns across all components in the file\r\n    const patterns = this.analyzeComponentPatterns();\r\n\r\n    // Detect inconsistent prop patterns\r\n    issues.push(...this.detectInconsistentPropPatterns(file, patterns));\r\n\r\n    // Detect inconsistent export patterns\r\n    issues.push(...this.detectInconsistentExportPatterns(file, patterns));\r\n\r\n    // Detect inconsistent component definition styles\r\n    issues.push(...this.detectInconsistentDefinitionStyles(file, patterns));\r\n\r\n    // Detect inconsistent event handler naming\r\n    issues.push(...this.detectInconsistentEventHandlerNaming(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze patterns across all discovered components\r\n   */\r\n  private analyzeComponentPatterns() {\r\n    const patterns = {\r\n      propDestructuring: 0,\r\n      propObject: 0,\r\n      defaultExports: 0,\r\n      namedExports: 0,\r\n      functionDeclarations: 0,\r\n      arrowFunctions: 0,\r\n      usesTypeScript: 0,\r\n      usesJavaScript: 0,\r\n    };\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      // Count prop patterns\r\n      if (this.usesPropDestructuring(component.node)) {\r\n        patterns.propDestructuring++;\r\n      } else if (component.hasProps) {\r\n        patterns.propObject++;\r\n      }\r\n\r\n      // Count export patterns\r\n      if (this.isDefaultExport(component.node)) {\r\n        patterns.defaultExports++;\r\n      } else if (component.isExported) {\r\n        patterns.namedExports++;\r\n      }\r\n\r\n      // Count definition styles\r\n      if (component.type === \"function\") {\r\n        patterns.functionDeclarations++;\r\n      } else if (component.type === \"arrow\") {\r\n        patterns.arrowFunctions++;\r\n      }\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent prop passing patterns\r\n   */\r\n  private detectInconsistentPropPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both patterns are used, flag inconsistency\r\n    if (patterns.propDestructuring > 0 && patterns.propObject > 0) {\r\n      const total = patterns.propDestructuring + patterns.propObject;\r\n      const destructuringPercent = Math.round(\r\n        (patterns.propDestructuring / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const usesDestructuring = this.usesPropDestructuring(component.node);\r\n        const isMinorityPattern =\r\n          (usesDestructuring && destructuringPercent < 50) ||\r\n          (!usesDestructuring &&\r\n            component.hasProps &&\r\n            destructuringPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            destructuringPercent >= 50 ? \"destructuring\" : \"object\";\r\n          const currentPattern = usesDestructuring ? \"destructuring\" : \"object\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} for props, but ${patterns.propDestructuring} components use destructuring and ${patterns.propObject} use object props. This inconsistency makes the codebase harder to understand.`,\r\n              recommendation: `Consider using ${preferredPattern} pattern for props consistently across all components. This improves code readability and maintainability.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"props\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent export patterns\r\n   */\r\n  private detectInconsistentExportPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both export patterns are used, flag inconsistency\r\n    if (patterns.defaultExports > 0 && patterns.namedExports > 0) {\r\n      const total = patterns.defaultExports + patterns.namedExports;\r\n      const defaultPercent = Math.round(\r\n        (patterns.defaultExports / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const isDefault = this.isDefaultExport(component.node);\r\n        const isMinorityPattern =\r\n          (isDefault && defaultPercent < 50) ||\r\n          (component.isExported && !isDefault && defaultPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern = defaultPercent >= 50 ? \"default\" : \"named\";\r\n          const currentPattern = isDefault ? \"default\" : \"named\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} export, but ${patterns.defaultExports} components use default exports and ${patterns.namedExports} use named exports. This inconsistency can confuse developers.`,\r\n              recommendation: `Consider using ${preferredPattern} exports consistently across all components. This makes imports more predictable and consistent.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"exports\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent component definition styles\r\n   */\r\n  private detectInconsistentDefinitionStyles(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both function and arrow styles are used, flag inconsistency\r\n    if (patterns.functionDeclarations > 0 && patterns.arrowFunctions > 0) {\r\n      const total = patterns.functionDeclarations + patterns.arrowFunctions;\r\n      const functionPercent = Math.round(\r\n        (patterns.functionDeclarations / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        if (component.type === \"class\") continue; // Skip class components\r\n\r\n        const isFunction = component.type === \"function\";\r\n        const isMinorityPattern =\r\n          (isFunction && functionPercent < 50) ||\r\n          (component.type === \"arrow\" && functionPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            functionPercent >= 50 ? \"function declaration\" : \"arrow function\";\r\n          const currentPattern = isFunction\r\n            ? \"function declaration\"\r\n            : \"arrow function\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' is defined as ${currentPattern}, but ${patterns.functionDeclarations} components use function declarations and ${patterns.arrowFunctions} use arrow functions. This inconsistency affects code style uniformity.`,\r\n              recommendation: `Consider using ${preferredPattern} consistently for all function components. This creates a more uniform codebase.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"definition-style\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent event handler naming patterns\r\n   */\r\n  private detectInconsistentEventHandlerNaming(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Track event handler naming patterns\r\n    const handlerPatterns = {\r\n      handlePrefix: 0, // handleClick, handleSubmit\r\n      onPrefix: 0, // onClick, onSubmit\r\n      other: 0, // click, submit, doSomething\r\n    };\r\n\r\n    const inconsistentHandlers: Array<{\r\n      name: string;\r\n      node: Node;\r\n      pattern: string;\r\n    }> = [];\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const handlers = this.findEventHandlers(component.node);\r\n\r\n      for (const handler of handlers) {\r\n        if (handler.name.startsWith(\"handle\")) {\r\n          handlerPatterns.handlePrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"handle\" });\r\n        } else if (handler.name.startsWith(\"on\")) {\r\n          handlerPatterns.onPrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"on\" });\r\n        } else {\r\n          handlerPatterns.other++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"other\" });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If multiple patterns are used, flag inconsistency\r\n    const patternsUsed = [\r\n      handlerPatterns.handlePrefix > 0,\r\n      handlerPatterns.onPrefix > 0,\r\n      handlerPatterns.other > 0,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternsUsed > 1) {\r\n      const total =\r\n        handlerPatterns.handlePrefix +\r\n        handlerPatterns.onPrefix +\r\n        handlerPatterns.other;\r\n      const dominantPattern =\r\n        handlerPatterns.handlePrefix > handlerPatterns.onPrefix &&\r\n        handlerPatterns.handlePrefix > handlerPatterns.other\r\n          ? \"handle\"\r\n          : handlerPatterns.onPrefix > handlerPatterns.other\r\n            ? \"on\"\r\n            : \"other\";\r\n\r\n      // Flag handlers using minority patterns\r\n      for (const handler of inconsistentHandlers) {\r\n        if (handler.pattern !== dominantPattern) {\r\n          const preferredExample =\r\n            dominantPattern === \"handle\"\r\n              ? \"handleClick\"\r\n              : dominantPattern === \"on\"\r\n                ? \"onClick\"\r\n                : \"descriptive names\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: handler.node,\r\n              description: `Event handler '${handler.name}' uses '${handler.pattern}' prefix, but the codebase has ${handlerPatterns.handlePrefix} 'handle' handlers, ${handlerPatterns.onPrefix} 'on' handlers, and ${handlerPatterns.other} other patterns. This inconsistency makes the code less predictable.`,\r\n              recommendation: `Consider using '${dominantPattern}' prefix consistently for event handlers (e.g., ${preferredExample}). This improves code consistency and makes event handlers easier to identify.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"event-handlers\",\r\n                \"naming\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find event handler functions in a component\r\n   */\r\n  private findEventHandlers(node: Node): Array<{ name: string; node: Node }> {\r\n    const handlers: Array<{ name: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common event handler patterns in JSX\r\n    const eventAttributes = [\r\n      \"onClick\",\r\n      \"onChange\",\r\n      \"onSubmit\",\r\n      \"onFocus\",\r\n      \"onBlur\",\r\n      \"onKeyDown\",\r\n      \"onKeyUp\",\r\n      \"onKeyPress\",\r\n      \"onMouseEnter\",\r\n      \"onMouseLeave\",\r\n      \"onMouseDown\",\r\n      \"onMouseUp\",\r\n      \"onInput\",\r\n      \"onScroll\",\r\n      \"onLoad\",\r\n    ];\r\n\r\n    for (const eventAttr of eventAttributes) {\r\n      // Match patterns like onClick={handleClick} or onClick={onClickHandler}\r\n      const pattern = new RegExp(\r\n        `${eventAttr}=\\\\{([a-zA-Z_$][a-zA-Z0-9_$]*)\\\\}`,\r\n        \"g\",\r\n      );\r\n      let match;\r\n\r\n      while ((match = pattern.exec(text)) !== null) {\r\n        const handlerName = match[1];\r\n\r\n        // Find the actual function definition\r\n        const handlerNode = this.findFunctionByName(node, handlerName);\r\n        if (handlerNode) {\r\n          handlers.push({ name: handlerName, node: handlerNode });\r\n        }\r\n      }\r\n    }\r\n\r\n    return handlers;\r\n  }\r\n\r\n  /**\r\n   * Find a function definition by name within a node\r\n   */\r\n  private findFunctionByName(node: Node, name: string): Node | null {\r\n    let foundNode: Node | null = null;\r\n\r\n    const traverse = (n: Node) => {\r\n      if (foundNode) return;\r\n\r\n      // Check function declarations\r\n      if (Node.isFunctionDeclaration(n)) {\r\n        if (n.getName() === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Check variable declarations with arrow functions\r\n      if (Node.isVariableDeclaration(n)) {\r\n        if (this.getNodeName(n) === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return foundNode;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Duplicate Component Logic Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate component logic across components\r\n   * Validates Requirements: 6.5\r\n   *\r\n   * Detects:\r\n   * - Duplicate validation logic\r\n   * - Duplicate data transformation logic\r\n   * - Duplicate effect patterns\r\n   * - Duplicate custom hook patterns\r\n   * - Similar component structures\r\n   */\r\n  private detectDuplicateComponentLogic(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate validation logic\r\n    issues.push(...this.detectDuplicateValidation(file));\r\n\r\n    // Detect duplicate useEffect patterns\r\n    issues.push(...this.detectDuplicateEffects(file));\r\n\r\n    // Detect duplicate data transformations\r\n    issues.push(...this.detectDuplicateTransformations(file));\r\n\r\n    // Detect similar component structures\r\n    issues.push(...this.detectSimilarComponentStructures(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate validation logic across components\r\n   */\r\n  private detectDuplicateValidation(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const validationPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const validations = this.extractValidationLogic(component.node);\r\n\r\n      for (const validation of validations) {\r\n        const pattern = this.normalizeCode(validation.code);\r\n\r\n        if (!validationPatterns.has(pattern)) {\r\n          validationPatterns.set(pattern, []);\r\n        }\r\n\r\n        validationPatterns.get(pattern)!.push({\r\n          component,\r\n          node: validation.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of validationPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate validation logic found in component '${occurrence.component.name}'. This same validation appears in ${occurrences.length} components: ${componentNames}. Duplicated validation logic increases maintenance burden.`,\r\n              recommendation: `Extract this validation logic into a shared utility function or custom hook. This will make the validation logic reusable and easier to maintain. Consider creating a validation utility in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"validation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract validation logic from a component\r\n   */\r\n  private extractValidationLogic(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const validations: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common validation patterns\r\n    const validationKeywords = [\r\n      \"validate\",\r\n      \"isValid\",\r\n      \"check\",\r\n      \"verify\",\r\n      \"test\",\r\n      \"required\",\r\n      \"optional\",\r\n      \"min\",\r\n      \"max\",\r\n      \"pattern\",\r\n      \"email\",\r\n      \"phone\",\r\n      \"url\",\r\n      \"number\",\r\n      \"string\",\r\n    ];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for if statements with validation logic\r\n      if (Node.isIfStatement(n)) {\r\n        const condition = n.getExpression().getText();\r\n\r\n        if (\r\n          validationKeywords.some((keyword) =>\r\n            condition.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Look for validation functions\r\n      if (Node.isFunctionDeclaration(n) || Node.isArrowFunction(n)) {\r\n        const funcText = n.getText();\r\n        const funcName = Node.isFunctionDeclaration(n) ? n.getName() : \"\";\r\n\r\n        if (\r\n          validationKeywords.some(\r\n            (keyword) =>\r\n              funcName?.toLowerCase().includes(keyword) ||\r\n              funcText.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: funcText,\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return validations;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate useEffect patterns\r\n   */\r\n  private detectDuplicateEffects(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const effectPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const effects = this.extractEffects(component.node);\r\n\r\n      for (const effect of effects) {\r\n        const pattern = this.normalizeCode(effect.code);\r\n\r\n        if (!effectPatterns.has(pattern)) {\r\n          effectPatterns.set(pattern, []);\r\n        }\r\n\r\n        effectPatterns.get(pattern)!.push({\r\n          component,\r\n          node: effect.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of effectPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate useEffect logic found in component '${occurrence.component.name}'. This same effect appears in ${occurrences.length} components: ${componentNames}. Duplicated effects increase maintenance burden.`,\r\n              recommendation: `Extract this effect logic into a custom hook. This will make the effect reusable and easier to maintain. Consider creating a custom hook like 'use[DescriptiveName]' in a shared hooks directory.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"hooks\",\r\n                \"useEffect\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract useEffect calls from a component\r\n   */\r\n  private extractEffects(node: Node): Array<{ code: string; node: Node }> {\r\n    const effects: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Find useEffect calls\r\n    const effectPattern = /useEffect\\s*\\(/g;\r\n    let match;\r\n\r\n    while ((match = effectPattern.exec(text)) !== null) {\r\n      // Try to find the actual call expression node\r\n      const traverse = (n: Node) => {\r\n        if (Node.isCallExpression(n)) {\r\n          const expr = n.getExpression();\r\n          if (expr.getText() === \"useEffect\") {\r\n            effects.push({\r\n              code: n.getText(),\r\n              node: n,\r\n            });\r\n          }\r\n        }\r\n        n.forEachChild(traverse);\r\n      };\r\n\r\n      traverse(node);\r\n    }\r\n\r\n    return effects;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate data transformation logic\r\n   */\r\n  private detectDuplicateTransformations(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const transformPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const transforms = this.extractTransformations(component.node);\r\n\r\n      for (const transform of transforms) {\r\n        const pattern = this.normalizeCode(transform.code);\r\n\r\n        if (!transformPatterns.has(pattern)) {\r\n          transformPatterns.set(pattern, []);\r\n        }\r\n\r\n        transformPatterns.get(pattern)!.push({\r\n          component,\r\n          node: transform.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of transformPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate data transformation logic found in component '${occurrence.component.name}'. This same transformation appears in ${occurrences.length} components: ${componentNames}. Duplicated transformations increase maintenance burden.`,\r\n              recommendation: `Extract this transformation logic into a shared utility function. This will make the transformation reusable and easier to maintain. Consider creating a utility function in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"transformation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract data transformation logic from a component\r\n   */\r\n  private extractTransformations(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const transformations: Array<{ code: string; node: Node }> = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for array methods (map, filter, reduce, etc.)\r\n      if (Node.isCallExpression(n)) {\r\n        const expr = n.getExpression();\r\n        const exprText = expr.getText();\r\n\r\n        if (\r\n          exprText.endsWith(\".map\") ||\r\n          exprText.endsWith(\".filter\") ||\r\n          exprText.endsWith(\".reduce\") ||\r\n          exprText.endsWith(\".sort\") ||\r\n          exprText.endsWith(\".find\") ||\r\n          exprText.endsWith(\".findIndex\")\r\n        ) {\r\n          transformations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return transformations;\r\n  }\r\n\r\n  /**\r\n   * Detect similar component structures (potential for abstraction)\r\n   */\r\n  private detectSimilarComponentStructures(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Compare components pairwise for structural similarity\r\n    for (let i = 0; i < this.discoveredComponents.length; i++) {\r\n      for (let j = i + 1; j < this.discoveredComponents.length; j++) {\r\n        const comp1 = this.discoveredComponents[i];\r\n        const comp2 = this.discoveredComponents[j];\r\n\r\n        const similarity = this.calculateStructuralSimilarity(comp1, comp2);\r\n\r\n        // If components are very similar (>70% similar), flag for potential abstraction\r\n        if (similarity > 0.7) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: comp1.node,\r\n              description: `Components '${comp1.name}' and '${comp2.name}' have very similar structures (${Math.round(similarity * 100)}% similar). This suggests they could be abstracted into a single reusable component.`,\r\n              recommendation: `Consider creating a single component that accepts configuration props to handle both use cases. This reduces code duplication and makes the codebase more maintainable. Look for common patterns and extract them into a shared component.`,\r\n              estimatedEffort: \"medium\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"abstraction\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Calculate structural similarity between two components\r\n   */\r\n  private calculateStructuralSimilarity(\r\n    comp1: ComponentInfo,\r\n    comp2: ComponentInfo,\r\n  ): number {\r\n    let similarityScore = 0;\r\n    let totalChecks = 0;\r\n\r\n    // Compare component types\r\n    totalChecks++;\r\n    if (comp1.type === comp2.type) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare hook usage\r\n    totalChecks++;\r\n    if (comp1.usesHooks === comp2.usesHooks) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare state usage\r\n    totalChecks++;\r\n    if (comp1.usesState === comp2.usesState) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare props usage\r\n    totalChecks++;\r\n    if (comp1.hasProps === comp2.hasProps) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare code structure (simplified - count similar patterns)\r\n    const text1 = comp1.node.getText();\r\n    const text2 = comp2.node.getText();\r\n\r\n    // Count common patterns\r\n    const patterns = [\r\n      /useEffect/g,\r\n      /useState/g,\r\n      /useCallback/g,\r\n      /useMemo/g,\r\n      /return\\s*\\(/g,\r\n      /onClick/g,\r\n      /onChange/g,\r\n      /className/g,\r\n    ];\r\n\r\n    for (const pattern of patterns) {\r\n      totalChecks++;\r\n      const count1 = (text1.match(pattern) || []).length;\r\n      const count2 = (text2.match(pattern) || []).length;\r\n\r\n      if (count1 > 0 && count2 > 0) {\r\n        // Both use this pattern\r\n        const ratio = Math.min(count1, count2) / Math.max(count1, count2);\r\n        similarityScore += ratio;\r\n      }\r\n    }\r\n\r\n    return similarityScore / totalChecks;\r\n  }\r\n\r\n  /**\r\n   * Normalize code for comparison (remove whitespace, comments, etc.)\r\n   */\r\n  private normalizeCode(code: string): string {\r\n    return code\r\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Remove block comments\r\n      .replace(/\\/\\/.*/g, \"\") // Remove line comments\r\n      .replace(/\\s+/g, \" \") // Normalize whitespace\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods for Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a component uses prop destructuring\r\n   */\r\n  private usesPropDestructuring(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      const params = node.getParameters();\r\n      if (params.length > 0) {\r\n        const binding = params[0].getNameNode();\r\n        return Node.isObjectBindingPattern(binding);\r\n      }\r\n    }\r\n\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const initializer = node.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.usesPropDestructuring(initializer);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a component uses default export\r\n   */\r\n  private isDefaultExport(node: Node): boolean {\r\n    const parent = node.getParent();\r\n\r\n    // Check if this is a default export declaration\r\n    if (parent && Node.isExportAssignment(parent)) {\r\n      return true;\r\n    }\r\n\r\n    // Check if there's a separate default export statement\r\n    const sourceFile = node.getSourceFile();\r\n    const defaultExports = sourceFile.getExportAssignments();\r\n\r\n    for (const exportAssignment of defaultExports) {\r\n      const expr = exportAssignment.getExpression();\r\n      const nodeName = this.getNodeName(node);\r\n\r\n      if (nodeName && expr.getText() === nodeName) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check for \"export default\" syntax\r\n    const text = node.getText();\r\n    const fullText = node.getFullText();\r\n\r\n    return (\r\n      fullText.includes(\"export default\") || text.startsWith(\"export default\")\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9497,9500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9497,9500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10041,10044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10041,10044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10222,10225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10222,10225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10614,10617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10614,10617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":358,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10678,10681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10678,10681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10736,10739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10736,10739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Abstract base class for all pattern analyzers\r\n * Provides common utilities for AST traversal and issue creation\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { randomUUID } from 'crypto';\r\nimport type {\r\n  PatternAnalyzer,\r\n  FileInfo,\r\n  Issue,\r\n  IssueType,\r\n  IssueCategory,\r\n  Severity,\r\n  EffortLevel,\r\n  CodeLocation,\r\n  FileCategory,\r\n} from '../types.js';\r\n\r\n/**\r\n * Abstract base class that all pattern analyzers must extend\r\n */\r\nexport abstract class BasePatternAnalyzer implements PatternAnalyzer {\r\n  /**\r\n   * Name of the analyzer (must be implemented by subclasses)\r\n   */\r\n  abstract readonly name: string;\r\n\r\n  /**\r\n   * Analyze a file and return detected issues\r\n   * @param file File information\r\n   * @param ast Parsed AST of the file\r\n   * @returns Array of detected issues\r\n   */\r\n  abstract analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]>;\r\n\r\n  /**\r\n   * Get the file types this analyzer supports\r\n   * @returns Array of supported file categories\r\n   */\r\n  abstract getSupportedFileTypes(): FileCategory[];\r\n\r\n  // ============================================================================\r\n  // Issue Creation Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Create an issue with proper location tracking\r\n   * @param params Issue parameters\r\n   * @returns Complete Issue object\r\n   */\r\n  protected createIssue(params: {\r\n    type: IssueType;\r\n    severity: Severity;\r\n    category: IssueCategory;\r\n    file: string;\r\n    node: Node;\r\n    description: string;\r\n    recommendation: string;\r\n    estimatedEffort: EffortLevel;\r\n    tags?: string[];\r\n  }): Issue {\r\n    const location = this.getNodeLocation(params.node);\r\n    const codeSnippet = this.getCodeSnippet(params.node);\r\n\r\n    return {\r\n      id: randomUUID(),\r\n      type: params.type,\r\n      severity: params.severity,\r\n      category: params.category,\r\n      file: params.file,\r\n      location,\r\n      description: params.description,\r\n      codeSnippet,\r\n      recommendation: params.recommendation,\r\n      estimatedEffort: params.estimatedEffort,\r\n      tags: params.tags || [],\r\n      detectedBy: this.name,\r\n      detectedAt: new Date(),\r\n      relatedIssues: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the location of a node in the source file\r\n   * @param node AST node\r\n   * @returns Code location with line and column numbers\r\n   */\r\n  protected getNodeLocation(node: Node): CodeLocation {\r\n    const sourceFile = node.getSourceFile();\r\n    const start = node.getStart();\r\n    const end = node.getEnd();\r\n\r\n    const startLineAndColumn = sourceFile.getLineAndColumnAtPos(start);\r\n    const endLineAndColumn = sourceFile.getLineAndColumnAtPos(end);\r\n\r\n    return {\r\n      startLine: startLineAndColumn.line,\r\n      endLine: endLineAndColumn.line,\r\n      startColumn: startLineAndColumn.column,\r\n      endColumn: endLineAndColumn.column,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get a code snippet from a node\r\n   * @param node AST node\r\n   * @param maxLength Maximum length of snippet (default: 200)\r\n   * @returns Code snippet as string\r\n   */\r\n  protected getCodeSnippet(node: Node, maxLength: number = 200): string {\r\n    const text = node.getText();\r\n    if (text.length <= maxLength) {\r\n      return text;\r\n    }\r\n    return text.substring(0, maxLength) + '...';\r\n  }\r\n\r\n  // ============================================================================\r\n  // AST Traversal Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all nodes of a specific kind in the AST\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodesByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (node.getKind() === kind) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes matching a predicate function\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodes(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (predicate(node)) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Get all function declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  protected getFunctionDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all arrow functions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  protected getArrowFunctions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Get all function expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  protected getFunctionExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Get all method declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  protected getMethodDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all class declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  protected getClassDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all interface declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  protected getInterfaceDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all type alias declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  protected getTypeAliases(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all import declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  protected getImportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all export declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  protected getExportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all variable declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  protected getVariableDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all if statements in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  protected getIfStatements(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Get all call expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  protected getCallExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.CallExpression);\r\n  }\r\n\r\n  // ============================================================================\r\n  // Code Analysis Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Nesting depth (0 for top-level)\r\n   */\r\n  protected getNestingDepth(node: Node): number {\r\n    let depth = 0;\r\n    let current = node.getParent();\r\n\r\n    while (current) {\r\n      const kind = current.getKind();\r\n      // Count blocks that increase nesting\r\n      if (\r\n        kind === SyntaxKind.IfStatement ||\r\n        kind === SyntaxKind.ForStatement ||\r\n        kind === SyntaxKind.WhileStatement ||\r\n        kind === SyntaxKind.DoStatement ||\r\n        kind === SyntaxKind.SwitchStatement ||\r\n        kind === SyntaxKind.CaseClause ||\r\n        kind === SyntaxKind.TryStatement ||\r\n        kind === SyntaxKind.CatchClause\r\n      ) {\r\n        depth++;\r\n      }\r\n      current = current.getParent();\r\n    }\r\n\r\n    return depth;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific text pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  protected containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  protected getNodeName(node: Node): string | undefined {\r\n    // Try to get name from various node types\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  protected isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    // First check the node itself\r\n    if (nodeWithModifiers.getModifiers) {\r\n      const modifiers = nodeWithModifiers.getModifiers();\r\n      if (modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword)) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    // For variable declarations, check the parent VariableStatement\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const parent = node.getParent(); // VariableDeclarationList\r\n      const grandParent = parent?.getParent(); // VariableStatement\r\n      if (grandParent && (grandParent as any).getModifiers) {\r\n        const modifiers = (grandParent as any).getModifiers();\r\n        return modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get all comments associated with a node\r\n   * @param node AST node\r\n   * @returns Array of comment texts\r\n   */\r\n  protected getComments(node: Node): string[] {\r\n    const comments: string[] = [];\r\n    const sourceFile = node.getSourceFile();\r\n    const fullText = sourceFile.getFullText();\r\n    \r\n    // Get leading comments\r\n    const leadingCommentRanges = node.getLeadingCommentRanges();\r\n    for (const range of leadingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    // Get trailing comments\r\n    const trailingCommentRanges = node.getTrailingCommentRanges();\r\n    for (const range of trailingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Count the number of child nodes\r\n   * @param node AST node\r\n   * @returns Number of direct children\r\n   */\r\n  protected getChildCount(node: Node): number {\r\n    return node.getChildCount();\r\n  }\r\n\r\n  /**\r\n   * Get the text length of a node\r\n   * @param node AST node\r\n   * @returns Length in characters\r\n   */\r\n  protected getTextLength(node: Node): number {\r\n    return node.getText().length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\service-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":385,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13740,13743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13740,13743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Service Pattern Analyzer\r\n * \r\n * Analyzes service layer architecture in the codebase to identify\r\n * inconsistencies, circular dependencies, and unnecessary complexity.\r\n * \r\n * Detects:\r\n * - All service modules in the codebase\r\n * - Service dependencies and import relationships\r\n * - Circular dependencies between services\r\n * - Inconsistent service initialization patterns\r\n * - Unnecessary service abstraction layers\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Pattern for tracking service modules\r\n */\r\ninterface ServiceModule {\r\n  name: string;\r\n  path: string;\r\n  imports: string[];\r\n  exports: string[];\r\n  node: Node;\r\n}\r\n\r\n/**\r\n * Pattern for tracking service dependencies\r\n */\r\ninterface ServiceDependency {\r\n  from: string;\r\n  to: string;\r\n  importNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for service layer patterns\r\n */\r\nexport class ServicePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'ServicePatternAnalyzer';\r\n\r\n  // Track all discovered services across files\r\n  private services: Map<string, ServiceModule> = new Map();\r\n  private dependencies: ServiceDependency[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['service'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for service-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 10.1: Discover service modules and analyze dependencies\r\n    issues.push(...this.discoverServiceModule(file, ast));\r\n    issues.push(...this.analyzeServiceDependencies(file, ast));\r\n    issues.push(...this.analyzeServiceImports(file, ast));\r\n\r\n    // Task 10.2: Detect circular dependencies\r\n    // Note: This should be called after all services have been discovered\r\n    // Typically called once after analyzing all files\r\n    issues.push(...this.detectCircularDependencies(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.1: Service Discovery and Analysis\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover and catalog service modules\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private discoverServiceModule(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Extract service name from file path\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    \r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get all imports from this service\r\n    const imports = this.getImportDeclarations(ast);\r\n    const importedServices: string[] = [];\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access getModuleSpecifierValue\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Check if this import is from another service\r\n      if (this.isServiceImport(moduleSpecifier)) {\r\n        const importedServiceName = this.extractServiceNameFromImport(moduleSpecifier);\r\n        if (importedServiceName) {\r\n          importedServices.push(importedServiceName);\r\n          \r\n          // Track dependency\r\n          this.dependencies.push({\r\n            from: serviceName,\r\n            to: importedServiceName,\r\n            importNode: importDecl,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get all exports from this service\r\n    const exports = this.getExportDeclarations(ast);\r\n    const exportedNames: string[] = [];\r\n\r\n    // Get named exports\r\n    for (const exportDecl of exports) {\r\n      // Cast to ExportDeclaration to access getNamedExports\r\n      if (!Node.isExportDeclaration(exportDecl)) continue;\r\n      const namedExports = exportDecl.getNamedExports();\r\n      for (const namedExport of namedExports) {\r\n        exportedNames.push(namedExport.getName());\r\n      }\r\n    }\r\n\r\n    // Get exported functions, classes, and variables\r\n    const functions = ast.getFunctions();\r\n    const classes = this.getClassDeclarations(ast);\r\n    const variables = this.getVariableDeclarations(ast);\r\n\r\n    for (const func of functions) {\r\n      if (this.isExported(func)) {\r\n        const funcName = this.getNodeName(func);\r\n        if (funcName) {\r\n          exportedNames.push(funcName);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        const className = this.getNodeName(cls);\r\n        if (className) {\r\n          exportedNames.push(className);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Store service information\r\n    const serviceModule: ServiceModule = {\r\n      name: serviceName,\r\n      path: file.relativePath,\r\n      imports: importedServices,\r\n      exports: exportedNames,\r\n      node: ast,\r\n    };\r\n\r\n    this.services.set(serviceName, serviceModule);\r\n\r\n    // Check if service has no exports (might be incomplete or unused)\r\n    if (exportedNames.length === 0) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service module '${serviceName}' has no exports. This might indicate an incomplete implementation or an unused service file.`,\r\n          recommendation: 'Either add exports to make this service usable, or remove the file if it\\'s no longer needed. Services should export functions, classes, or objects that provide specific functionality.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'architecture', 'unused-code'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service dependencies for patterns and issues\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceDependencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get dependencies for this service\r\n    const serviceDeps = this.dependencies.filter(dep => dep.from === serviceName);\r\n\r\n    // Check for excessive dependencies (might indicate poor separation of concerns)\r\n    if (serviceDeps.length > 5) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' depends on ${serviceDeps.length} other services. This high number of dependencies suggests the service might have unclear responsibilities or be doing too much.`,\r\n          recommendation: 'Consider breaking this service into smaller, more focused services with clearer responsibilities. Each service should have a single, well-defined purpose. Review the dependencies to see if some functionality could be consolidated or if the service is mixing concerns.',\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'separation-of-concerns'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for duplicate imports (same service imported multiple times)\r\n    const importCounts = new Map<string, number>();\r\n    for (const dep of serviceDeps) {\r\n      importCounts.set(dep.to, (importCounts.get(dep.to) || 0) + 1);\r\n    }\r\n\r\n    for (const [importedService, count] of importCounts.entries()) {\r\n      if (count > 1) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Service '${importedService}' is imported ${count} times in this file. This might indicate duplicate import statements or inconsistent import patterns.`,\r\n            recommendation: 'Consolidate imports from the same service into a single import statement. This improves code readability and reduces redundancy.',\r\n            estimatedEffort: 'trivial',\r\n            tags: ['service', 'imports', 'code-quality'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service import patterns and relationships\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceImports(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const imports = this.getImportDeclarations(ast);\r\n    \r\n    // Track import patterns\r\n    const importPatterns = {\r\n      defaultImports: 0,\r\n      namedImports: 0,\r\n      namespaceImports: 0,\r\n      sideEffectImports: 0,\r\n    };\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access import methods\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Only analyze service imports\r\n      if (!this.isServiceImport(moduleSpecifier)) {\r\n        continue;\r\n      }\r\n\r\n      // Check import type\r\n      const defaultImport = importDecl.getDefaultImport();\r\n      const namedImports = importDecl.getNamedImports();\r\n      const namespaceImport = importDecl.getNamespaceImport();\r\n\r\n      if (defaultImport) {\r\n        importPatterns.defaultImports++;\r\n      }\r\n      \r\n      if (namedImports.length > 0) {\r\n        importPatterns.namedImports++;\r\n      }\r\n      \r\n      if (namespaceImport) {\r\n        importPatterns.namespaceImports++;\r\n      }\r\n      \r\n      if (!defaultImport && namedImports.length === 0 && !namespaceImport) {\r\n        importPatterns.sideEffectImports++;\r\n      }\r\n\r\n      // Check for relative imports that go up multiple levels\r\n      if (moduleSpecifier.startsWith('../')) {\r\n        const levels = (moduleSpecifier.match(/\\.\\.\\//g) || []).length;\r\n        \r\n        if (levels > 2) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: 'inconsistent-pattern',\r\n              severity: 'low',\r\n              category: 'services',\r\n              file: file.relativePath,\r\n              node: importDecl,\r\n              description: `Import uses ${levels} levels of relative path traversal (${moduleSpecifier}). This makes the code harder to refactor and understand.`,\r\n              recommendation: 'Consider using absolute imports or path aliases (e.g., @/services/...) instead of deep relative imports. This makes imports more maintainable and less fragile during refactoring.',\r\n              estimatedEffort: 'trivial',\r\n              tags: ['service', 'imports', 'maintainability'],\r\n            })\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for inconsistent import patterns\r\n    const totalServiceImports = importPatterns.defaultImports + \r\n                                importPatterns.namedImports + \r\n                                importPatterns.namespaceImports;\r\n\r\n    if (totalServiceImports > 2) {\r\n      // If we have a mix of default and named imports, flag it\r\n      if (importPatterns.defaultImports > 0 && importPatterns.namedImports > 0) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Inconsistent import patterns detected: ${importPatterns.defaultImports} default imports and ${importPatterns.namedImports} named imports from services. This inconsistency can make the codebase harder to understand.`,\r\n            recommendation: 'Standardize on either default exports or named exports for services. Named exports are generally preferred as they provide better IDE support and make refactoring easier.',\r\n            estimatedEffort: 'small',\r\n            tags: ['service', 'imports', 'consistency'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.2: Circular Dependency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect circular dependencies between services\r\n   * Validates Requirements: 5.3\r\n   * \r\n   * Uses depth-first search to detect cycles in the dependency graph.\r\n   * A circular dependency exists when service A depends on service B,\r\n   * and service B (directly or indirectly) depends on service A.\r\n   */\r\n  private detectCircularDependencies(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Build dependency graph\r\n    const graph = this.buildDependencyGraph();\r\n\r\n    // Find all cycles that include this service\r\n    const cycles = this.findCyclesInGraph(graph, serviceName);\r\n\r\n    // Create issues for each unique cycle\r\n    for (const cycle of cycles) {\r\n      // Only report the cycle once (from the first service in the cycle alphabetically)\r\n      // This prevents duplicate reports for the same cycle\r\n      const sortedCycle = [...cycle].sort();\r\n      if (sortedCycle[0] !== serviceName) {\r\n        continue;\r\n      }\r\n\r\n      const cycleDescription = cycle.join(' ‚Üí ') + ' ‚Üí ' + cycle[0];\r\n      \r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'high',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: this.services.get(serviceName)?.node || file as any,\r\n          description: `Circular dependency detected: ${cycleDescription}. This creates tight coupling between services and can lead to initialization problems, testing difficulties, and maintenance issues.`,\r\n          recommendation: `Break the circular dependency by:\r\n1. Extracting shared functionality into a separate service that both services can depend on\r\n2. Using dependency injection to invert the dependency\r\n3. Refactoring to remove the need for one of the dependencies\r\n4. Using events or a message bus to decouple the services\r\n\r\nCircular dependencies are a serious architectural issue that should be resolved to improve code maintainability and testability.`,\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'circular-dependency', 'coupling'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Build a dependency graph from discovered services\r\n   * Returns a Map where keys are service names and values are arrays of dependent service names\r\n   */\r\n  private buildDependencyGraph(): Map<string, string[]> {\r\n    const graph = new Map<string, string[]>();\r\n\r\n    // Initialize graph with all services\r\n    for (const serviceName of this.services.keys()) {\r\n      graph.set(serviceName, []);\r\n    }\r\n\r\n    // Add dependencies\r\n    for (const dep of this.dependencies) {\r\n      const deps = graph.get(dep.from) || [];\r\n      // Only add if the target service exists in our discovered services\r\n      if (this.services.has(dep.to)) {\r\n        deps.push(dep.to);\r\n        graph.set(dep.from, deps);\r\n      }\r\n    }\r\n\r\n    return graph;\r\n  }\r\n\r\n  /**\r\n   * Find all cycles in the dependency graph that include the given service\r\n   * Uses depth-first search with cycle detection\r\n   */\r\n  private findCyclesInGraph(graph: Map<string, string[]>, startService: string): string[][] {\r\n    const cycles: string[][] = [];\r\n    const visited = new Set<string>();\r\n    const recursionStack = new Set<string>();\r\n    const path: string[] = [];\r\n\r\n    /**\r\n     * Depth-first search to detect cycles\r\n     */\r\n    const dfs = (service: string): void => {\r\n      visited.add(service);\r\n      recursionStack.add(service);\r\n      path.push(service);\r\n\r\n      const dependencies = graph.get(service) || [];\r\n\r\n      for (const dep of dependencies) {\r\n        if (!visited.has(dep)) {\r\n          // Continue DFS\r\n          dfs(dep);\r\n        } else if (recursionStack.has(dep)) {\r\n          // Found a cycle!\r\n          // Extract the cycle from the path\r\n          const cycleStartIndex = path.indexOf(dep);\r\n          if (cycleStartIndex !== -1) {\r\n            const cycle = path.slice(cycleStartIndex);\r\n            \r\n            // Only include cycles that contain the start service\r\n            if (cycle.includes(startService)) {\r\n              // Normalize the cycle to start with the lexicographically smallest service\r\n              // This helps with deduplication\r\n              const minIndex = cycle.indexOf(\r\n                cycle.reduce((min, curr) => (curr < min ? curr : min))\r\n              );\r\n              const normalizedCycle = [\r\n                ...cycle.slice(minIndex),\r\n                ...cycle.slice(0, minIndex),\r\n              ];\r\n              \r\n              // Check if we've already found this cycle\r\n              const cycleKey = normalizedCycle.join('‚Üí');\r\n              const isDuplicate = cycles.some(\r\n                existingCycle => existingCycle.join('‚Üí') === cycleKey\r\n              );\r\n              \r\n              if (!isDuplicate) {\r\n                cycles.push(normalizedCycle);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      path.pop();\r\n      recursionStack.delete(service);\r\n    };\r\n\r\n    // Start DFS from the given service\r\n    dfs(startService);\r\n\r\n    return cycles;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.3: Service Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent service initialization and configuration patterns\r\n   * Validates Requirements: 5.4\r\n   */\r\n  private detectInconsistentInitialization(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Track initialization patterns found in this service\r\n    const initPatterns = {\r\n      hasConstructor: false,\r\n      hasInitFunction: false,\r\n      hasConfigObject: false,\r\n      hasFactoryFunction: false,\r\n      hasSingletonPattern: false,\r\n      hasDirectExports: false,\r\n    };\r\n\r\n    // Check for class-based services with constructors\r\n    const classes = this.getClassDeclarations(ast);\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        // Cast to ClassDeclaration to access getConstructors\r\n        if (!Node.isClassDeclaration(cls)) continue;\r\n        const constructors = cls.getConstructors();\r\n        if (constructors.length > 0) {\r\n          initPatterns.hasConstructor = true;\r\n          \r\n          // Check if constructor has parameters (dependency injection)\r\n          const constructor = constructors[0];\r\n          const params = constructor.getParameters();\r\n          \r\n          // Flag constructors with too many parameters (poor design)\r\n          if (params.length > 5) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'medium',\r\n                category: 'services',\r\n                file: file.relativePath,\r\n                node: constructor,\r\n                description: `Service class constructor has ${params.length} parameters. This high number of dependencies suggests the service might be doing too much or have unclear responsibilities.`,\r\n                recommendation: 'Consider breaking this service into smaller, more focused services. Use the Single Responsibility Principle: each service should have one clear purpose. If many dependencies are needed, consider using a configuration object or builder pattern instead of individual parameters.',\r\n                estimatedEffort: 'medium',\r\n                tags: ['service', 'initialization', 'constructor', 'dependencies'],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for init/initialize/setup functions\r\n    const functions = ast.getFunctions();\r\n    for (const func of functions) {\r\n      const funcName = this.getNodeName(func);\r\n      if (funcName && /^(init|initialize|setup|configure|config)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasInitFunction = true;\r\n        }\r\n      }\r\n      \r\n      // Check for factory functions (create*, make*, build*)\r\n      if (funcName && /^(create|make|build|get)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasFactoryFunction = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for configuration objects\r\n    const variables = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variables) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (varName && /config|options|settings/i.test(varName)) {\r\n        if (this.isExported(varDecl)) {\r\n          initPatterns.hasConfigObject = true;\r\n        }\r\n      }\r\n      \r\n      // Check for singleton pattern (instance variable)\r\n      if (varName && /instance|singleton/i.test(varName)) {\r\n        initPatterns.hasSingletonPattern = true;\r\n      }\r\n    }\r\n\r\n    // Check for direct function exports (functional style)\r\n    const exportedFunctions = functions.filter(f => this.isExported(f));\r\n    if (exportedFunctions.length > 0 && !initPatterns.hasConstructor) {\r\n      initPatterns.hasDirectExports = true;\r\n    }\r\n\r\n    // Detect mixed initialization patterns (inconsistency)\r\n    const patternCount = [\r\n      initPatterns.hasConstructor,\r\n      initPatterns.hasInitFunction,\r\n      initPatterns.hasFactoryFunction,\r\n      initPatterns.hasSingletonPattern,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternCount > 1) {\r\n      const patterns: string[] = [];\r\n      if (initPatterns.hasConstructor) patterns.push('class constructor');\r\n      if (initPatterns.hasInitFunction) patterns.push('init/setup function');\r\n      if (initPatterns.hasFactoryFunction) patterns.push('factory function');\r\n      if (initPatterns.hasSingletonPattern) patterns.push('singleton pattern');\r\n\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' uses multiple initialization patterns: ${patterns.join(', ')}. This inconsistency makes the service harder to understand and use correctly.`,\r\n          recommendation: 'Standardize on a single initialization pattern for this service. Choose one approach:\\n1. Class-based with constructor injection (good for stateful services)\\n2. Factory functions (good for creating instances)\\n3. Direct function exports (good for stateless utilities)\\n4. Singleton pattern (use sparingly, only when truly needed)\\n\\nConsistency in initialization patterns makes the codebase more predictable and easier to maintain.',\r\n          estimatedEffort: 'medium',\r\n          tags: ['service', 'initialization', 'consistency', 'pattern'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for services with no clear initialization pattern\r\n    if (patternCount === 0 && !initPatterns.hasDirectExports) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'low',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' has no clear initialization pattern. It's unclear how this service should be instantiated or configured.`,\r\n          recommendation: 'Add a clear initialization pattern to this service. Consider:\\n1. Exporting a class with a constructor\\n2. Exporting a factory function (e.g., createService())\\n3. Exporting direct functions if this is a stateless utility\\n\\nClear initialization patterns make services easier to use and test.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'initialization', 'clarity'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary service abstraction layers\r\n   * Validates Requirements: 5.5\r\n   */\r\n  private detectUnnecessaryAbstractions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Check all exported functions for pass-through behavior\r\n    const functions = ast.getFunctions();\r\n    \r\n    for (const func of functions) {\r\n      if (!this.isExported(func)) {\r\n        continue;\r\n      }\r\n\r\n      const funcName = this.getNodeName(func);\r\n      if (!funcName) {\r\n        continue;\r\n      }\r\n\r\n      // Get function body\r\n      const body = func.getBody();\r\n      if (!body || !Node.isBlock(body)) {\r\n        continue;\r\n      }\r\n\r\n      const statements = body.getStatements();\r\n      \r\n      // Check for single-statement functions (potential pass-through)\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        \r\n        // Check if it's a return statement\r\n        if (Node.isReturnStatement(statement)) {\r\n          const returnExpr = statement.getExpression();\r\n          \r\n          if (returnExpr) {\r\n            // Check if it's a simple call expression (pass-through)\r\n            if (Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if parameters are just passed through\r\n              const funcParams = func.getParameters();\r\n              const callArgs = callExpr.getArguments();\r\n              \r\n              // Simple heuristic: if parameter count matches and function just calls another function\r\n              if (funcParams.length === callArgs.length) {\r\n                // Check if all arguments are simple identifiers matching parameters\r\n                let isSimplePassThrough = true;\r\n                const paramNames = funcParams.map(p => p.getName());\r\n                \r\n                for (let i = 0; i < callArgs.length; i++) {\r\n                  const arg = callArgs[i];\r\n                  if (Node.isIdentifier(arg)) {\r\n                    if (arg.getText() !== paramNames[i]) {\r\n                      isSimplePassThrough = false;\r\n                      break;\r\n                    }\r\n                  } else {\r\n                    // Argument is not a simple identifier\r\n                    isSimplePassThrough = false;\r\n                    break;\r\n                  }\r\n                }\r\n                \r\n                if (isSimplePassThrough) {\r\n                  const calledFunctionName = calledExpr.getText();\r\n                  \r\n                  issues.push(\r\n                    this.createIssue({\r\n                      type: 'unnecessary-adapter',\r\n                      severity: 'low',\r\n                      category: 'services',\r\n                      file: file.relativePath,\r\n                      node: func,\r\n                      description: `Function '${funcName}' is a simple pass-through wrapper that just calls '${calledFunctionName}' with the same parameters. This abstraction layer adds no value and increases code complexity.`,\r\n                      recommendation: `Consider removing this wrapper function and using '${calledFunctionName}' directly. If this wrapper exists for a specific reason (e.g., to provide a stable API while the implementation changes), document that reason clearly. Otherwise, unnecessary abstraction layers make code harder to navigate and maintain.`,\r\n                      estimatedEffort: 'trivial',\r\n                      tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                    })\r\n                  );\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Check for simple property access pass-through\r\n            if (Node.isPropertyAccessExpression(returnExpr)) {\r\n              issues.push(\r\n                this.createIssue({\r\n                  type: 'unnecessary-adapter',\r\n                  severity: 'low',\r\n                  category: 'services',\r\n                  file: file.relativePath,\r\n                  node: func,\r\n                  description: `Function '${funcName}' simply returns a property access (${returnExpr.getText()}). This adds an unnecessary abstraction layer.`,\r\n                  recommendation: 'Consider exposing the property directly or removing this wrapper function. Simple property access wrappers add little value and make code harder to follow.',\r\n                  estimatedEffort: 'trivial',\r\n                  tags: ['service', 'abstraction', 'wrapper', 'property-access'],\r\n                })\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Check for functions with only trivial transformations\r\n      if (statements.length === 2) {\r\n        // Pattern: const result = someCall(); return result;\r\n        const firstStmt = statements[0];\r\n        const secondStmt = statements[1];\r\n        \r\n        if (Node.isVariableStatement(firstStmt) && Node.isReturnStatement(secondStmt)) {\r\n          const varDecls = firstStmt.getDeclarations();\r\n          if (varDecls.length === 1) {\r\n            const varDecl = varDecls[0];\r\n            const varName = varDecl.getName();\r\n            const returnExpr = secondStmt.getExpression();\r\n            \r\n            // Check if return statement just returns the variable\r\n            if (returnExpr && Node.isIdentifier(returnExpr) && returnExpr.getText() === varName) {\r\n              const initializer = varDecl.getInitializer();\r\n              \r\n              if (initializer && Node.isCallExpression(initializer)) {\r\n                // This is a pass-through with an intermediate variable\r\n                issues.push(\r\n                  this.createIssue({\r\n                    type: 'unnecessary-adapter',\r\n                    severity: 'low',\r\n                    category: 'services',\r\n                    file: file.relativePath,\r\n                    node: func,\r\n                    description: `Function '${funcName}' is a pass-through wrapper that calls another function and immediately returns the result without any transformation or additional logic.`,\r\n                    recommendation: 'Consider removing this wrapper function unless it serves a specific architectural purpose (e.g., providing a stable API, adding logging, or handling errors). Document the reason if the wrapper is intentional.',\r\n                    estimatedEffort: 'trivial',\r\n                    tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                  })\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for wrapper classes that just delegate to another class\r\n    const classes = this.getClassDeclarations(ast);\r\n    \r\n    for (const cls of classes) {\r\n      if (!this.isExported(cls)) {\r\n        continue;\r\n      }\r\n\r\n      const className = this.getNodeName(cls);\r\n      if (!className) {\r\n        continue;\r\n      }\r\n\r\n      // Cast to ClassDeclaration to access getMethods\r\n      if (!Node.isClassDeclaration(cls)) continue;\r\n      const methods = cls.getMethods();\r\n      let passThroughMethodCount = 0;\r\n      \r\n      for (const method of methods) {\r\n        const methodBody = method.getBody();\r\n        if (!methodBody || !Node.isBlock(methodBody)) {\r\n          continue;\r\n        }\r\n\r\n        const statements = methodBody.getStatements();\r\n        \r\n        // Check for single-statement methods that just delegate\r\n        if (statements.length === 1) {\r\n          const statement = statements[0];\r\n          \r\n          if (Node.isReturnStatement(statement)) {\r\n            const returnExpr = statement.getExpression();\r\n            \r\n            if (returnExpr && Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if it's calling a method on a member variable (delegation)\r\n              if (Node.isPropertyAccessExpression(calledExpr)) {\r\n                passThroughMethodCount++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If most methods are pass-through, flag the class as unnecessary abstraction\r\n      if (methods.length > 0 && passThroughMethodCount / methods.length > 0.7) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'unnecessary-adapter',\r\n            severity: 'medium',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: cls,\r\n            description: `Class '${className}' appears to be a wrapper class where ${passThroughMethodCount} out of ${methods.length} methods simply delegate to another object. This abstraction layer may be unnecessary.`,\r\n            recommendation: 'Consider whether this wrapper class is needed. If it\\'s just delegating calls without adding value (no error handling, logging, transformation, or business logic), consider using the wrapped class directly. If the wrapper serves a specific purpose (e.g., adapter pattern for third-party libraries, providing a stable API), document that clearly.',\r\n            estimatedEffort: 'medium',\r\n            tags: ['service', 'abstraction', 'wrapper', 'delegation', 'class'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Extract service name from file path\r\n   * Examples:\r\n   *   backend/services/user/index.ts -> user\r\n   *   backend/services/auth/auth-service.ts -> auth\r\n   *   services/database/db.ts -> database\r\n   */\r\n  private extractServiceName(filePath: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: backend/services/NAME/... or services/NAME/...\r\n    const serviceMatch = normalizedPath.match(/(?:backend\\/)?services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if an import is from a service module\r\n   */\r\n  private isServiceImport(moduleSpecifier: string): boolean {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Check for service imports\r\n    return normalizedPath.includes('/services/') || \r\n           normalizedPath.includes('services/') ||\r\n           normalizedPath.startsWith('@/services/') ||\r\n           normalizedPath.startsWith('~/services/');\r\n  }\r\n\r\n  /**\r\n   * Extract service name from import path\r\n   */\r\n  private extractServiceNameFromImport(moduleSpecifier: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: ../services/NAME or @/services/NAME\r\n    const serviceMatch = normalizedPath.match(/services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get all discovered services\r\n   * This can be used by other analyzers or for reporting\r\n   */\r\n  public getDiscoveredServices(): Map<string, ServiceModule> {\r\n    return this.services;\r\n  }\r\n\r\n  /**\r\n   * Get all service dependencies\r\n   * This can be used for circular dependency detection\r\n   */\r\n  public getServiceDependencies(): ServiceDependency[] {\r\n    return this.dependencies;\r\n  }\r\n\r\n  /**\r\n   * Clear the analyzer state (useful for testing or re-analysis)\r\n   */\r\n  public reset(): void {\r\n    this.services.clear();\r\n    this.dependencies = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\type-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":327,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10170,10173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10170,10173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":756,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":756,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26109,26112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26109,26112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Type Pattern Analyzer\r\n * \r\n * Analyzes TypeScript type definitions and usage patterns in the codebase\r\n * to identify inconsistencies, redundancies, and type safety issues.\r\n * \r\n * Detects:\r\n * - All type definitions (interfaces, types, enums)\r\n * - Type usage across files\r\n * - Duplicate type definitions\r\n * - Inconsistent type definitions for same entities\r\n * - Excessive 'any' type usage\r\n * - Type assertions that could be avoided\r\n * - Mismatches between Supabase generated types and manual types\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Information about a type definition\r\n */\r\ninterface TypeDefinition {\r\n  name: string;\r\n  kind: 'interface' | 'type' | 'enum';\r\n  node: Node;\r\n  file: string;\r\n  definition: string;\r\n}\r\n\r\n/**\r\n * Information about type usage\r\n */\r\ninterface TypeUsage {\r\n  typeName: string;\r\n  node: Node;\r\n  file: string;\r\n  context: string; // 'variable' | 'parameter' | 'return' | 'property'\r\n}\r\n\r\n/**\r\n * Analyzer for TypeScript type patterns\r\n */\r\nexport class TypePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'TypePatternAnalyzer';\r\n\r\n  // Track type definitions across files for cross-file analysis\r\n  private typeDefinitions: TypeDefinition[] = [];\r\n  private typeUsages: TypeUsage[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['type', 'component', 'api-route', 'service', 'util'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for type-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 8.1: Find all type definitions and track type usage\r\n    this.discoverTypeDefinitions(file, ast);\r\n    this.trackTypeUsage(file, ast);\r\n\r\n    // Task 8.2: Detect type inconsistencies\r\n    // Note: This requires cross-file analysis, so we detect issues after all files are analyzed\r\n    // The detectTypeInconsistencies() method should be called after analyzing all files\r\n\r\n    // Task 8.3: Detect type safety issues\r\n    issues.push(...this.detectExcessiveAnyUsage(file, ast));\r\n    issues.push(...this.detectUnnecessaryTypeAssertions(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect type inconsistencies across all analyzed files\r\n   * This method should be called after all files have been analyzed\r\n   * Validates Requirements: 7.2, 7.4, 7.5\r\n   */\r\n  public detectTypeInconsistencies(): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate type definitions for the same entities\r\n    issues.push(...this.detectDuplicateTypeDefinitions());\r\n\r\n    // Detect mismatches between Supabase types and manual types\r\n    issues.push(...this.detectSupabaseTypeMismatches());\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.1: Type Definition Discovery\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all type definitions (interfaces, types, enums) in the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private discoverTypeDefinitions(file: FileInfo, ast: SourceFile): void {\r\n    // Find all interface declarations\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const name = interfaceDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'interface',\r\n        node: interfaceDecl,\r\n        file: file.relativePath,\r\n        definition: interfaceDecl.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all type alias declarations\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const name = typeAlias.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'type',\r\n        node: typeAlias,\r\n        file: file.relativePath,\r\n        definition: typeAlias.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all enum declarations\r\n    const enums = ast.getEnums();\r\n    for (const enumDecl of enums) {\r\n      const name = enumDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'enum',\r\n        node: enumDecl,\r\n        file: file.relativePath,\r\n        definition: enumDecl.getText(),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track type usage across the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private trackTypeUsage(file: FileInfo, ast: SourceFile): void {\r\n    // Track type usage in variable declarations\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variableDeclarations) {\r\n      // Cast to VariableDeclaration to access getTypeNode\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const typeNode = varDecl.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: varDecl,\r\n            file: file.relativePath,\r\n            context: 'variable',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in function parameters\r\n    const functions = [\r\n      ...ast.getFunctions(),\r\n      ...this.findNodesByKind(ast, SyntaxKind.ArrowFunction),\r\n      ...this.findNodesByKind(ast, SyntaxKind.FunctionExpression),\r\n      ...this.findNodesByKind(ast, SyntaxKind.MethodDeclaration),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const parameters = this.getFunctionParameters(func);\r\n      for (const param of parameters) {\r\n        // Cast to ParameterDeclaration to access getTypeNode\r\n        if (!Node.isParameterDeclaration(param)) continue;\r\n        const typeNode = param.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: param,\r\n              file: file.relativePath,\r\n              context: 'parameter',\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Track return type usage\r\n      // Check if this is a function-like node with getReturnTypeNode\r\n      let returnTypeNode: Node | undefined;\r\n      if (Node.isFunctionDeclaration(func) || Node.isArrowFunction(func) || \r\n          Node.isFunctionExpression(func) || Node.isMethodDeclaration(func)) {\r\n        returnTypeNode = func.getReturnTypeNode();\r\n      }\r\n      if (returnTypeNode) {\r\n        const typeName = this.extractTypeName(returnTypeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: func,\r\n            file: file.relativePath,\r\n            context: 'return',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in interface/type properties\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const properties = interfaceDecl.getProperties();\r\n      for (const prop of properties) {\r\n        const typeNode = prop.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: prop,\r\n              file: file.relativePath,\r\n              context: 'property',\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const typeNode = typeAlias.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: typeAlias,\r\n            file: file.relativePath,\r\n            context: 'property',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract the type name from a type node\r\n   * Handles simple types, generic types, and complex type expressions\r\n   */\r\n  private extractTypeName(typeNode: Node): string | null {\r\n    const typeText = typeNode.getText();\r\n\r\n    // Handle simple type references (e.g., \"User\", \"string\", \"number\")\r\n    if (/^[A-Z][a-zA-Z0-9_]*$/.test(typeText)) {\r\n      return typeText;\r\n    }\r\n\r\n    // Handle generic types (e.g., \"Array<User>\", \"Promise<User>\")\r\n    const genericMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)<(.+)>$/);\r\n    if (genericMatch) {\r\n      // Return the inner type for tracking\r\n      return this.extractTypeName({ getText: () => genericMatch[2] } as Node);\r\n    }\r\n\r\n    // Handle union types (e.g., \"User | null\")\r\n    if (typeText.includes('|')) {\r\n      const types = typeText.split('|').map(t => t.trim());\r\n      // Return the first non-primitive type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle intersection types (e.g., \"User & Timestamps\")\r\n    if (typeText.includes('&')) {\r\n      const types = typeText.split('&').map(t => t.trim());\r\n      // Return the first type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle array types (e.g., \"User[]\")\r\n    const arrayMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)\\[\\]$/);\r\n    if (arrayMatch) {\r\n      return arrayMatch[1];\r\n    }\r\n\r\n    // Handle Supabase Database types (e.g., \"Database['public']['Tables']['users']['Row']\")\r\n    if (typeText.includes('Database[')) {\r\n      const tableMatch = typeText.match(/\\['Tables'\\]\\['([^']+)'\\]/);\r\n      if (tableMatch) {\r\n        // Return a normalized name for the table type\r\n        return `Db${this.capitalize(tableMatch[1])}`;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Capitalize the first letter of a string\r\n   */\r\n  private capitalize(str: string): string {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n  }\r\n\r\n  /**\r\n   * Get parameters from a function node\r\n   */\r\n  private getFunctionParameters(func: Node): Node[] {\r\n    const funcWithParams = func as any;\r\n    if (funcWithParams.getParameters && typeof funcWithParams.getParameters === 'function') {\r\n      return funcWithParams.getParameters();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing tracked data\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered type definitions\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeDefinitions(): TypeDefinition[] {\r\n    return this.typeDefinitions;\r\n  }\r\n\r\n  /**\r\n   * Get all tracked type usages\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeUsages(): TypeUsage[] {\r\n    return this.typeUsages;\r\n  }\r\n\r\n  /**\r\n   * Get type definitions by name\r\n   */\r\n  public getTypeDefinitionsByName(name: string): TypeDefinition[] {\r\n    return this.typeDefinitions.filter(def => def.name === name);\r\n  }\r\n\r\n  /**\r\n   * Get type usages by name\r\n   */\r\n  public getTypeUsagesByName(name: string): TypeUsage[] {\r\n    return this.typeUsages.filter(usage => usage.typeName === name);\r\n  }\r\n\r\n  /**\r\n   * Clear tracked data (useful for testing or re-analysis)\r\n   */\r\n  public clearTrackedData(): void {\r\n    this.typeDefinitions = [];\r\n    this.typeUsages = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.2: Type Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate type definitions for the same entities\r\n   * Validates Requirements: 7.2, 7.4\r\n   */\r\n  private detectDuplicateTypeDefinitions(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const typesByName = new Map<string, TypeDefinition[]>();\r\n\r\n    // Group type definitions by name\r\n    for (const typeDef of this.typeDefinitions) {\r\n      const existing = typesByName.get(typeDef.name) || [];\r\n      existing.push(typeDef);\r\n      typesByName.set(typeDef.name, existing);\r\n    }\r\n\r\n    // Check for duplicates\r\n    for (const [typeName, definitions] of typesByName.entries()) {\r\n      if (definitions.length > 1) {\r\n        // We have duplicate type definitions\r\n        const files = definitions.map(d => d.file).join(', ');\r\n        \r\n        // Check if definitions are identical or different\r\n        const uniqueDefinitions = new Set(definitions.map(d => this.normalizeTypeDefinition(d.definition)));\r\n        \r\n        if (uniqueDefinitions.size === 1) {\r\n          // Identical definitions - code duplication\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'code-duplication',\r\n                severity: 'medium',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Duplicate type definition '${typeName}' found in ${definitions.length} files: ${files}`,\r\n                recommendation: `Consolidate the type definition '${typeName}' into a single shared type file and import it where needed. This reduces maintenance burden and ensures consistency.`,\r\n                estimatedEffort: 'small',\r\n                tags: ['duplicate-type', 'type-consolidation', typeName],\r\n              })\r\n            );\r\n          }\r\n        } else {\r\n          // Different definitions - inconsistent types\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'high',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Inconsistent type definition for '${typeName}' found across ${definitions.length} files: ${files}. The definitions differ in structure or properties.`,\r\n                recommendation: `Review all definitions of '${typeName}' and establish a single canonical definition. Ensure all usages align with the canonical type. Consider if these should be different types with different names.`,\r\n                estimatedEffort: 'medium',\r\n                tags: ['inconsistent-type', 'type-mismatch', typeName],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect mismatches between Supabase generated types and manual type definitions\r\n   * Validates Requirements: 7.5\r\n   */\r\n  private detectSupabaseTypeMismatches(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    \r\n    // Find Supabase database type definitions\r\n    const supabaseTypes = this.typeDefinitions.filter(def => \r\n      def.file.includes('database.types') || \r\n      def.file.includes('supabase') ||\r\n      def.definition.includes(\"Database['public']['Tables']\")\r\n    );\r\n\r\n    // Find manual type definitions that might correspond to database entities\r\n    const manualTypes = this.typeDefinitions.filter(def => \r\n      !def.file.includes('database.types') && \r\n      !def.file.includes('supabase')\r\n    );\r\n\r\n    // Check for potential mismatches\r\n    for (const manualType of manualTypes) {\r\n      // Check if there's a corresponding Supabase type\r\n      const potentialSupabaseType = this.findCorrespondingSupabaseType(manualType, supabaseTypes);\r\n      \r\n      if (potentialSupabaseType) {\r\n        // We found a potential mismatch - manual type exists alongside Supabase type\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'high',\r\n            category: 'types',\r\n            file: manualType.file,\r\n            node: manualType.node,\r\n            description: `Manual type definition '${manualType.name}' may conflict with Supabase generated type. Found potential Supabase type in ${potentialSupabaseType.file}.`,\r\n            recommendation: `Use Supabase generated types instead of manual definitions to ensure type safety with the database schema. Import the type from the generated types file: import type { ${manualType.name} } from '@/types/database.types'`,\r\n            estimatedEffort: 'small',\r\n            tags: ['supabase-type-mismatch', 'database-type', manualType.name],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for usage of Database['public']['Tables'] pattern outside of type files\r\n    for (const usage of this.typeUsages) {\r\n      if (usage.typeName.startsWith('Db') && !usage.file.includes('database.types')) {\r\n        // This is likely a Supabase type being used directly\r\n        // Check if there's a manual type that should be used instead\r\n        const manualType = this.typeDefinitions.find(def => \r\n          def.name === usage.typeName && \r\n          !def.file.includes('database.types')\r\n        );\r\n\r\n        if (!manualType) {\r\n          // Using Supabase type directly without a proper type alias\r\n          // This is actually good practice, so we don't flag it as an issue\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find a corresponding Supabase type for a manual type definition\r\n   */\r\n  private findCorrespondingSupabaseType(\r\n    manualType: TypeDefinition, \r\n    supabaseTypes: TypeDefinition[]\r\n  ): TypeDefinition | null {\r\n    // Look for Supabase types with similar names\r\n    const manualName = manualType.name.toLowerCase();\r\n    \r\n    for (const supabaseType of supabaseTypes) {\r\n      const supabaseName = supabaseType.name.toLowerCase();\r\n      \r\n      // Check for exact match\r\n      if (manualName === supabaseName) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check for common patterns:\r\n      // - User vs users (singular vs plural)\r\n      // - User vs DbUser\r\n      // - UserProfile vs user_profiles\r\n      \r\n      if (\r\n        manualName === supabaseName + 's' ||\r\n        manualName + 's' === supabaseName ||\r\n        manualName === 'db' + supabaseName ||\r\n        'db' + manualName === supabaseName ||\r\n        manualName.replace(/_/g, '') === supabaseName.replace(/_/g, '')\r\n      ) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check if the Supabase type definition references a table with similar name\r\n      if (supabaseType.definition.includes(`['${manualName}']`) ||\r\n          supabaseType.definition.includes(`['${manualName}s']`) ||\r\n          supabaseType.definition.includes(`['${manualName.replace(/([A-Z])/g, '_$1').toLowerCase()}']`)) {\r\n        return supabaseType;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Normalize a type definition for comparison\r\n   * Removes whitespace and formatting differences\r\n   */\r\n  private normalizeTypeDefinition(definition: string): string {\r\n    return definition\r\n      .replace(/\\s+/g, ' ')  // Normalize whitespace\r\n      .replace(/,\\s*}/g, '}')  // Remove trailing commas\r\n      .replace(/;\\s*}/g, '}')  // Remove trailing semicolons\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.3: Type Safety Issue Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive 'any' type usage\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectExcessiveAnyUsage(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all occurrences of 'any' type in the file\r\n    const anyTypeNodes = this.findAnyTypeUsage(ast);\r\n\r\n    for (const node of anyTypeNodes) {\r\n      // Determine the context of the 'any' usage\r\n      const context = this.getAnyTypeContext(node);\r\n      \r\n      // Create an issue for each 'any' usage\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'type-safety',\r\n          severity: 'medium',\r\n          category: 'types',\r\n          file: file.relativePath,\r\n          node: node,\r\n          description: `Excessive use of 'any' type detected in ${context}. This bypasses TypeScript's type checking and reduces type safety.`,\r\n          recommendation: `Replace 'any' with a specific type. Consider using: 1) A proper interface or type definition, 2) Generic types for flexible but type-safe code, 3) 'unknown' if the type is truly unknown (requires type guards), 4) Union types for multiple possible types.`,\r\n          estimatedEffort: 'small',\r\n          tags: ['any-type', 'type-safety', context],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary type assertions\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectUnnecessaryTypeAssertions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all type assertions (as Type and <Type>)\r\n    const typeAssertions = this.findTypeAssertions(ast);\r\n\r\n    for (const assertion of typeAssertions) {\r\n      // Check if the type assertion is unnecessary\r\n      if (this.isTypeAssertionUnnecessary(assertion)) {\r\n        const assertedType = this.getAssertedType(assertion);\r\n        \r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'type-safety',\r\n            severity: 'low',\r\n            category: 'types',\r\n            file: file.relativePath,\r\n            node: assertion,\r\n            description: `Unnecessary type assertion to '${assertedType}' detected. The expression already has the correct type or TypeScript can infer it.`,\r\n            recommendation: `Remove the type assertion and let TypeScript infer the type naturally. If the assertion is needed for a specific reason, add a comment explaining why. Type assertions should only be used when you have more information about the type than TypeScript can infer.`,\r\n            estimatedEffort: 'trivial',\r\n            tags: ['type-assertion', 'type-safety', 'unnecessary-assertion'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all 'any' type usage in the AST\r\n   */\r\n  private findAnyTypeUsage(ast: SourceFile): Node[] {\r\n    const anyNodes: Node[] = [];\r\n\r\n    // Find nodes with 'any' keyword\r\n    const traverse = (node: Node) => {\r\n      // Check if this is an 'any' type reference\r\n      if (node.getKind() === SyntaxKind.AnyKeyword) {\r\n        anyNodes.push(node);\r\n      }\r\n      \r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return anyNodes;\r\n  }\r\n\r\n  /**\r\n   * Get the context of an 'any' type usage\r\n   */\r\n  private getAnyTypeContext(node: Node): string {\r\n    let parent = node.getParent();\r\n    \r\n    // Traverse up to find the meaningful context\r\n    while (parent) {\r\n      const kind = parent.getKind();\r\n      \r\n      if (kind === SyntaxKind.Parameter) {\r\n        const paramName = this.getNodeName(parent) || 'parameter';\r\n        return `function parameter '${paramName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.VariableDeclaration) {\r\n        const varName = this.getNodeName(parent) || 'variable';\r\n        return `variable declaration '${varName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.PropertySignature || kind === SyntaxKind.PropertyDeclaration) {\r\n        const propName = this.getNodeName(parent) || 'property';\r\n        return `property '${propName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.FunctionDeclaration || \r\n          kind === SyntaxKind.MethodDeclaration ||\r\n          kind === SyntaxKind.ArrowFunction) {\r\n        const funcName = this.getNodeName(parent) || 'function';\r\n        return `return type of '${funcName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.TypeAliasDeclaration) {\r\n        const typeName = this.getNodeName(parent) || 'type';\r\n        return `type alias '${typeName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.InterfaceDeclaration) {\r\n        const interfaceName = this.getNodeName(parent) || 'interface';\r\n        return `interface '${interfaceName}'`;\r\n      }\r\n      \r\n      parent = parent.getParent();\r\n    }\r\n    \r\n    return 'unknown context';\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions in the AST\r\n   */\r\n  private findTypeAssertions(ast: SourceFile): Node[] {\r\n    const assertions: Node[] = [];\r\n\r\n    // Find 'as' type assertions\r\n    const asAssertions = this.findNodesByKind(ast, SyntaxKind.AsExpression);\r\n    assertions.push(...asAssertions);\r\n\r\n    // Find angle bracket type assertions (TypeReference)\r\n    const typeAssertions = this.findNodesByKind(ast, SyntaxKind.TypeAssertionExpression);\r\n    assertions.push(...typeAssertions);\r\n\r\n    // Find non-null assertions (!)\r\n    const nonNullAssertions = this.findNodesByKind(ast, SyntaxKind.NonNullExpression);\r\n    assertions.push(...nonNullAssertions);\r\n\r\n    return assertions;\r\n  }\r\n\r\n  /**\r\n   * Check if a type assertion is unnecessary\r\n   */\r\n  private isTypeAssertionUnnecessary(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for common patterns of unnecessary assertions\r\n    \r\n    // Pattern 1: Asserting to the same type as the literal\r\n    // e.g., \"hello\" as string, 123 as number, true as boolean\r\n    if (this.isLiteralToSameTypeAssertion(assertion)) {\r\n      return true;\r\n    }\r\n    \r\n    // Pattern 2: Double assertions (as any as Type)\r\n    // These are sometimes necessary for complex type conversions, so we're lenient\r\n    if (assertionText.includes(' as any as ')) {\r\n      return false; // Not flagging double assertions as they're often intentional\r\n    }\r\n    \r\n    // Pattern 3: Asserting after a type guard\r\n    // This is harder to detect statically, so we skip it for now\r\n    \r\n    // Pattern 4: Asserting to 'any' (this is caught by excessive any detection)\r\n    if (assertionText.includes(' as any') || assertionText.includes('<any>')) {\r\n      return false; // Let the 'any' detection handle this\r\n    }\r\n    \r\n    // Pattern 5: Non-null assertion on optional chaining result\r\n    // e.g., obj?.prop! - this is often unnecessary\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      const expression = (assertion as any).getExpression?.();\r\n      if (expression) {\r\n        const exprText = expression.getText();\r\n        // Check if the expression uses optional chaining\r\n        if (exprText.includes('?.')) {\r\n          return true; // Likely unnecessary\r\n        }\r\n      }\r\n    }\r\n    \r\n    // For other cases, we need more sophisticated type inference\r\n    // which would require the TypeScript type checker\r\n    // For now, we're conservative and don't flag them\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if an assertion is from a literal to its natural type\r\n   */\r\n  private isLiteralToSameTypeAssertion(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for string literal to string\r\n    if (assertionText.match(/[\"'`][^\"'`]*[\"'`]\\s+as\\s+string/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for number literal to number\r\n    if (assertionText.match(/\\d+(\\.\\d+)?\\s+as\\s+number/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for boolean literal to boolean\r\n    if (assertionText.match(/(true|false)\\s+as\\s+boolean/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for array literal to array type\r\n    if (assertionText.match(/\\[.*\\]\\s+as\\s+.*\\[\\]/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for object literal to object type\r\n    if (assertionText.match(/\\{.*\\}\\s+as\\s+\\{.*\\}/)) {\r\n      // This might be necessary for specific object shapes, so we're lenient\r\n      return false;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the type being asserted to\r\n   */\r\n  private getAssertedType(assertion: Node): string {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Extract type from 'as Type' syntax\r\n    const asMatch = assertionText.match(/\\s+as\\s+(.+)$/);\r\n    if (asMatch) {\r\n      return asMatch[1].trim();\r\n    }\r\n    \r\n    // Extract type from '<Type>' syntax\r\n    const angleMatch = assertionText.match(/^<(.+)>/);\r\n    if (angleMatch) {\r\n      return angleMatch[1].trim();\r\n    }\r\n    \r\n    // Non-null assertion\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      return 'non-null';\r\n    }\r\n    \r\n    return 'unknown';\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\plan.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1664,1667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1664,1667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1738,1741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1738,1741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1810,1813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1810,1813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1881,1884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1881,1884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3415,3418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3415,3418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4381,4384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4381,4384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4616,4619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4616,4619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plan Command\r\n * \r\n * Generates a cleanup plan from analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { CleanupPlanner } from '../../planner/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { ClassifiedIssues } from '../../types.js';\r\n\r\ninterface PlanOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const planCommand = new Command('plan')\r\n  .description('Generate a cleanup plan from analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-plan)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: PlanOptions) => {\r\n    try {\r\n      console.log('üìã Generating cleanup plan from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-plan');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"issues\" field.');\r\n      }\r\n\r\n      // Reconstruct ClassifiedIssues\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate cleanup plan\r\n      console.log('Generating cleanup plan...');\r\n      const planner = new CleanupPlanner();\r\n      const plan = planner.generatePlan(classified, classified.patterns);\r\n\r\n      // Display summary\r\n      console.log('\\nüìä Cleanup Plan Summary:');\r\n      console.log('‚îÄ'.repeat(50));\r\n      console.log(`Total Tasks: ${plan.tasks.length}`);\r\n      console.log(`Phases: ${plan.phases.length}`);\r\n      console.log(`Estimated Duration: ${plan.estimatedDuration}`);\r\n      console.log(`Overall Risk: ${plan.riskAssessment.overallRisk}`);\r\n      console.log('‚îÄ'.repeat(50));\r\n\r\n      // Generate output\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdown = generateMarkdownPlan(plan);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdown, 'utf-8');\r\n        console.log(`‚úÖ Markdown plan saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(plan, null, 2), 'utf-8');\r\n        console.log(`‚úÖ JSON plan saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\n‚úÖ Cleanup plan generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'plan');\r\n    }\r\n  });\r\n\r\n/**\r\n * Generate markdown representation of cleanup plan\r\n */\r\nfunction generateMarkdownPlan(plan: any): string {\r\n  let markdown = '# Codebase Cleanup Plan\\n\\n';\r\n\r\n  // Summary\r\n  markdown += '## Summary\\n\\n';\r\n  markdown += `- **Total Tasks**: ${plan.tasks.length}\\n`;\r\n  markdown += `- **Phases**: ${plan.phases.length}\\n`;\r\n  markdown += `- **Estimated Duration**: ${plan.estimatedDuration}\\n`;\r\n  markdown += `- **Overall Risk**: ${plan.riskAssessment.overallRisk}\\n\\n`;\r\n\r\n  // Risk Assessment\r\n  if (plan.riskAssessment.highRiskTasks.length > 0) {\r\n    markdown += '## Risk Assessment\\n\\n';\r\n    markdown += `**High Risk Tasks**: ${plan.riskAssessment.highRiskTasks.length}\\n\\n`;\r\n    \r\n    if (plan.riskAssessment.mitigationStrategies.length > 0) {\r\n      markdown += '**Mitigation Strategies**:\\n';\r\n      plan.riskAssessment.mitigationStrategies.forEach((strategy: string) => {\r\n        markdown += `- ${strategy}\\n`;\r\n      });\r\n      markdown += '\\n';\r\n    }\r\n  }\r\n\r\n  // Phases\r\n  markdown += '## Execution Phases\\n\\n';\r\n  plan.phases.forEach((phase: any) => {\r\n    markdown += `### Phase ${phase.phaseNumber}: ${phase.phaseName}\\n\\n`;\r\n    markdown += `${phase.description}\\n\\n`;\r\n    markdown += `**Tasks in this phase**: ${phase.tasks.length}\\n\\n`;\r\n\r\n    phase.tasks.forEach((task: any) => {\r\n      markdown += `#### ${task.title}\\n\\n`;\r\n      markdown += `- **ID**: ${task.id}\\n`;\r\n      markdown += `- **Category**: ${task.category}\\n`;\r\n      markdown += `- **Effort**: ${task.estimatedEffort}\\n`;\r\n      markdown += `- **Risk**: ${task.riskLevel}\\n`;\r\n      markdown += `- **Requires Tests**: ${task.requiresTests ? 'Yes' : 'No'}\\n`;\r\n      \r\n      if (task.dependencies.length > 0) {\r\n        markdown += `- **Dependencies**: ${task.dependencies.join(', ')}\\n`;\r\n      }\r\n      \r\n      markdown += `\\n**Description**: ${task.description}\\n\\n`;\r\n      \r\n      if (task.actionSteps.length > 0) {\r\n        markdown += '**Action Steps**:\\n';\r\n        task.actionSteps.forEach((step: string, index: number) => {\r\n          markdown += `${index + 1}. ${step}\\n`;\r\n        });\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      if (task.affectedFiles.length > 0) {\r\n        markdown += '**Affected Files**:\\n';\r\n        task.affectedFiles.slice(0, 10).forEach((file: string) => {\r\n          markdown += `- ${file}\\n`;\r\n        });\r\n        if (task.affectedFiles.length > 10) {\r\n          markdown += `- ... and ${task.affectedFiles.length - 10} more files\\n`;\r\n        }\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      markdown += '---\\n\\n';\r\n    });\r\n  });\r\n\r\n  return markdown;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\report.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2236,2239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2236,2239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2310,2313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2310,2313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2382,2385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2382,2385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2453,2456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2453,2456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Report Command\r\n * \r\n * Generates a report from previously saved analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { createReportGenerator } from '../../reporter/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { AnalysisResult, ClassifiedIssues } from '../../types.js';\r\n\r\ninterface ReportOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const reportCommand = new Command('report')\r\n  .description('Generate a report from saved analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-report)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: ReportOptions) => {\r\n    try {\r\n      console.log('üìÑ Generating report from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-report');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.summary || !data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"summary\" and \"issues\" fields.');\r\n      }\r\n\r\n      // Reconstruct AnalysisResult and ClassifiedIssues\r\n      const analysisResult: AnalysisResult = {\r\n        totalFiles: data.summary.totalFiles || 0,\r\n        analyzedFiles: data.summary.analyzedFiles || 0,\r\n        totalIssues: data.summary.totalIssues || 0,\r\n        issuesByType: new Map(),\r\n        issuesByCategory: new Map(),\r\n        issuesBySeverity: new Map(),\r\n        analysisTimestamp: new Date(data.summary.analysisTimestamp || Date.now()),\r\n        analysisDuration: data.summary.analysisDuration || 0,\r\n      };\r\n\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate report\r\n      const reporter = createReportGenerator();\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdownReport = reporter.generateMarkdownReport(analysisResult, classified);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdownReport, 'utf-8');\r\n        console.log(`‚úÖ Markdown report saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonReport = reporter.generateJsonReport(analysisResult, classified);\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(jsonReport, null, 2), 'utf-8');\r\n        console.log(`‚úÖ JSON report saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\n‚úÖ Report generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'report');\r\n    }\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5126,5129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5126,5129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6203,6206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6203,6206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Core type definitions for the codebase cleanup and refactoring analysis system\r\n */\r\n\r\n// ============================================================================\r\n// File Information Types\r\n// ============================================================================\r\n\r\n/**\r\n * Categorization of files for analysis purposes\r\n */\r\nexport type FileCategory =\r\n  | 'component'      // React components\r\n  | 'api-route'      // Next.js API routes\r\n  | 'service'        // Backend services\r\n  | 'type'           // Type definition files\r\n  | 'util'           // Utility functions\r\n  | 'middleware'     // Middleware files\r\n  | 'config'         // Configuration files\r\n  | 'test'           // Test files\r\n  | 'other';         // Uncategorized\r\n\r\n/**\r\n * Information about a file to be analyzed\r\n */\r\nexport interface FileInfo {\r\n  path: string;              // Absolute path\r\n  relativePath: string;      // Relative to project root\r\n  extension: string;         // '.ts', '.tsx', etc.\r\n  size: number;             // File size in bytes\r\n  category: FileCategory;   // Categorization for analysis\r\n  lastModified: Date;       // File modification timestamp\r\n}\r\n\r\n// ============================================================================\r\n// Issue Types\r\n// ============================================================================\r\n\r\n/**\r\n * Types of issues that can be detected\r\n */\r\nexport type IssueType =\r\n  | 'backward-compatibility'\r\n  | 'legacy-code'\r\n  | 'unnecessary-adapter'\r\n  | 'confusing-logic'\r\n  | 'code-duplication'\r\n  | 'inconsistent-pattern'\r\n  | 'poor-naming'\r\n  | 'missing-error-handling'\r\n  | 'type-safety'\r\n  | 'architectural';\r\n\r\n/**\r\n * Categories for grouping issues\r\n */\r\nexport type IssueCategory =\r\n  | 'authentication'\r\n  | 'database'\r\n  | 'api-routes'\r\n  | 'components'\r\n  | 'services'\r\n  | 'types'\r\n  | 'middleware'\r\n  | 'error-handling'\r\n  | 'general';\r\n\r\n/**\r\n * Severity levels for issues\r\n */\r\nexport type Severity = 'critical' | 'high' | 'medium' | 'low';\r\n\r\n/**\r\n * Effort levels for fixing issues\r\n */\r\nexport type EffortLevel = 'trivial' | 'small' | 'medium' | 'large';\r\n\r\n/**\r\n * Precise location of code within a file\r\n */\r\nexport interface CodeLocation {\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Represents a detected issue in the codebase\r\n */\r\nexport interface Issue {\r\n  id: string;                    // Unique identifier (UUID)\r\n  type: IssueType;              // Type of issue\r\n  severity: Severity;           // Severity level\r\n  category: IssueCategory;      // Category for grouping\r\n  file: string;                 // File path\r\n  location: CodeLocation;       // Precise location in file\r\n  description: string;          // Human-readable description\r\n  codeSnippet: string;         // Relevant code excerpt\r\n  recommendation: string;       // Suggested fix\r\n  estimatedEffort: EffortLevel; // Effort to fix\r\n  tags: string[];              // Additional tags for filtering\r\n  detectedBy: string;          // Analyzer that detected it\r\n  detectedAt: Date;            // Detection timestamp\r\n  relatedIssues: string[];     // IDs of related issues\r\n}\r\n\r\n// ============================================================================\r\n// Pattern Types\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a pattern of related issues across the codebase\r\n */\r\nexport interface IssuePattern {\r\n  patternId: string;           // Unique pattern identifier\r\n  patternName: string;         // Human-readable name\r\n  description: string;         // Pattern description\r\n  occurrences: number;         // Number of times detected\r\n  affectedFiles: string[];     // Files where pattern appears\r\n  relatedIssues: Issue[];      // Issues that match this pattern\r\n  recommendedAction: string;   // How to address the pattern\r\n  priority: number;            // Priority for addressing (1-10)\r\n  category: IssueCategory;     // Category for grouping\r\n}\r\n\r\n// ============================================================================\r\n// Scanner Types\r\n// ============================================================================\r\n\r\n/**\r\n * Options for scanning directories\r\n */\r\nexport interface ScanOptions {\r\n  includePatterns: string[];  // e.g., [\"**/*.ts\", \"**/*.tsx\"]\r\n  excludePatterns: string[];  // e.g., [\"**/node_modules/**\", \"**/.next/**\"]\r\n  maxDepth?: number;          // Maximum directory depth\r\n}\r\n\r\n/**\r\n * Interface for file scanning functionality\r\n */\r\nexport interface FileScanner {\r\n  scanDirectory(rootPath: string, options: ScanOptions): Promise<FileInfo[]>;\r\n  filterByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n  excludeByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n}\r\n\r\n// ============================================================================\r\n// Analyzer Types\r\n// ============================================================================\r\n\r\n/**\r\n * Base interface for all pattern analyzers\r\n */\r\nexport interface PatternAnalyzer {\r\n  name: string;\r\n  analyze(file: FileInfo, ast: any): Promise<Issue[]>;\r\n  getSupportedFileTypes(): FileCategory[];\r\n}\r\n\r\n// ============================================================================\r\n// Analysis Engine Types\r\n// ============================================================================\r\n\r\n/**\r\n * Collection of issues with various groupings\r\n */\r\nexport interface IssueCollection {\r\n  issues: Issue[];\r\n  groupedByFile: Map<string, Issue[]>;\r\n  groupedByType: Map<IssueType, Issue[]>;\r\n  groupedByCategory: Map<IssueCategory, Issue[]>;\r\n}\r\n\r\n/**\r\n * Result of analyzing the codebase\r\n */\r\nexport interface AnalysisResult {\r\n  totalFiles: number;\r\n  analyzedFiles: number;\r\n  totalIssues: number;\r\n  issuesByType: Map<IssueType, Issue[]>;\r\n  issuesByCategory: Map<IssueCategory, Issue[]>;\r\n  issuesBySeverity: Map<Severity, Issue[]>;\r\n  analysisTimestamp: Date;\r\n  analysisDuration: number;\r\n}\r\n\r\n/**\r\n * Interface for the analysis engine\r\n */\r\nexport interface AnalysisEngine {\r\n  analyze(files: FileInfo[], analyzers: PatternAnalyzer[]): Promise<AnalysisResult>;\r\n  parseFile(file: FileInfo): Promise<any>;\r\n  aggregateIssues(issues: Issue[]): IssueCollection;\r\n}\r\n\r\n// ============================================================================\r\n// Classifier Types\r\n// ============================================================================\r\n\r\n/**\r\n * Issues classified by severity\r\n */\r\nexport interface ClassifiedIssues {\r\n  critical: Issue[];\r\n  high: Issue[];\r\n  medium: Issue[];\r\n  low: Issue[];\r\n  patterns: IssuePattern[];\r\n}\r\n\r\n/**\r\n * Interface for issue classification\r\n */\r\nexport interface IssueClassifier {\r\n  classify(issues: Issue[]): ClassifiedIssues;\r\n  prioritize(issues: Issue[]): Issue[];\r\n  detectPatterns(issues: Issue[]): IssuePattern[];\r\n}\r\n\r\n// ============================================================================\r\n// Report Types\r\n// ============================================================================\r\n\r\n/**\r\n * Summary of the analysis report\r\n */\r\nexport interface ReportSummary {\r\n  totalIssues: number;\r\n  criticalIssues: number;\r\n  highIssues: number;\r\n  mediumIssues: number;\r\n  lowIssues: number;\r\n  topPatterns: IssuePattern[];\r\n  mostAffectedFiles: string[];\r\n  estimatedCleanupEffort: string;\r\n}\r\n\r\n/**\r\n * Recommendation for addressing issues\r\n */\r\nexport interface Recommendation {\r\n  priority: number;\r\n  title: string;\r\n  description: string;\r\n  affectedIssues: string[];\r\n  estimatedImpact: string;\r\n  estimatedEffort: string;\r\n}\r\n\r\n/**\r\n * Complete report data structure\r\n */\r\nexport interface ReportData {\r\n  summary: ReportSummary;\r\n  issues: Issue[];\r\n  patterns: IssuePattern[];\r\n  recommendations: Recommendation[];\r\n}\r\n\r\n/**\r\n * Interface for report generation\r\n */\r\nexport interface ReportGenerator {\r\n  generateMarkdownReport(result: AnalysisResult, classified: ClassifiedIssues): string;\r\n  generateJsonReport(result: AnalysisResult, classified: ClassifiedIssues): ReportData;\r\n  generateSummary(result: AnalysisResult): ReportSummary;\r\n}\r\n\r\n// ============================================================================\r\n// Cleanup Planning Types\r\n// ============================================================================\r\n\r\n/**\r\n * Risk levels for cleanup tasks\r\n */\r\nexport type RiskLevel = 'low' | 'medium' | 'high' | 'critical';\r\n\r\n/**\r\n * A specific cleanup task to address issues\r\n */\r\nexport interface CleanupTask {\r\n  id: string;                  // Unique task identifier\r\n  title: string;               // Short task title\r\n  description: string;         // Detailed description\r\n  category: IssueCategory;     // Category for grouping\r\n  relatedIssues: string[];     // Issue IDs this task addresses\r\n  dependencies: string[];      // Task IDs that must complete first\r\n  estimatedEffort: EffortLevel; // Effort estimate\r\n  riskLevel: RiskLevel;        // Risk of making this change\r\n  requiresTests: boolean;      // Whether tests needed before change\r\n  actionSteps: string[];       // Step-by-step instructions\r\n  affectedFiles: string[];     // Files that will be modified\r\n  phase: number;               // Which phase this belongs to\r\n}\r\n\r\n/**\r\n * Dependency relationship between tasks\r\n */\r\nexport interface TaskDependency {\r\n  taskId: string;\r\n  dependsOn: string[];\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * A phase of cleanup work\r\n */\r\nexport interface CleanupPhase {\r\n  phaseNumber: number;\r\n  phaseName: string;\r\n  tasks: CleanupTask[];\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Risk assessment for the cleanup plan\r\n */\r\nexport interface RiskAssessment {\r\n  overallRisk: RiskLevel;\r\n  highRiskTasks: CleanupTask[];\r\n  mitigationStrategies: string[];\r\n}\r\n\r\n/**\r\n * Complete cleanup plan\r\n */\r\nexport interface CleanupPlan {\r\n  tasks: CleanupTask[];\r\n  phases: CleanupPhase[];\r\n  estimatedDuration: string;\r\n  riskAssessment: RiskAssessment;\r\n}\r\n\r\n/**\r\n * Interface for cleanup planning\r\n */\r\nexport interface ICleanupPlanner {\r\n  generatePlan(classified: ClassifiedIssues, patterns: IssuePattern[]): CleanupPlan;\r\n  orderTasks(tasks: CleanupTask[]): CleanupTask[];\r\n  detectDependencies(tasks: CleanupTask[]): TaskDependency[];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\utils\\ast-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7455,7458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7455,7458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":484,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":484,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14001,14004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14001,14004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14542,14545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14542,14545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14721,14724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14721,14724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AST Parsing Utilities\r\n * \r\n * Provides utilities for parsing TypeScript/JavaScript files into ASTs\r\n * and querying AST nodes for common patterns.\r\n */\r\n\r\nimport { Project, SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport type { FileInfo } from '../types';\r\n\r\n/**\r\n * Error thrown when file parsing fails\r\n */\r\nexport class ParseError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly filePath: string,\r\n    public readonly cause?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'ParseError';\r\n  }\r\n}\r\n\r\n/**\r\n * AST Parser class for parsing files and querying AST nodes\r\n */\r\nexport class ASTParser {\r\n  private project: Project;\r\n\r\n  constructor() {\r\n    // Initialize ts-morph Project with TypeScript compiler options\r\n    this.project = new Project({\r\n      compilerOptions: {\r\n        target: 99, // ESNext\r\n        module: 99, // ESNext\r\n        jsx: 2, // React\r\n        allowJs: true,\r\n        skipLibCheck: true,\r\n        skipDefaultLibCheck: true,\r\n        noEmit: true,\r\n      },\r\n      skipAddingFilesFromTsConfig: true,\r\n      skipFileDependencyResolution: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Parse a file into an AST\r\n   * @param file File information\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  async parseFile(file: FileInfo): Promise<SourceFile> {\r\n    try {\r\n      // Add the file to the project\r\n      const sourceFile = this.project.addSourceFileAtPath(file.path);\r\n      \r\n      // Check for syntax errors\r\n      const diagnostics = sourceFile.getPreEmitDiagnostics();\r\n      \r\n      if (diagnostics.length > 0) {\r\n        // Log diagnostics but don't fail - we want to analyze even files with errors\r\n        const errors = diagnostics.map(d => d.getMessageText()).join('\\n');\r\n        console.warn(`Syntax warnings in ${file.relativePath}:\\n${errors}`);\r\n      }\r\n      \r\n      return sourceFile;\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse file: ${file.relativePath}`,\r\n        file.path,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse file content from a string\r\n   * @param content File content as string\r\n   * @param filePath Virtual file path for the content\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  parseContent(content: string, filePath: string): SourceFile {\r\n    try {\r\n      return this.project.createSourceFile(filePath, content, { overwrite: true });\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse content for: ${filePath}`,\r\n        filePath,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a file from the project to free memory\r\n   * @param sourceFile Source file to remove\r\n   */\r\n  removeFile(sourceFile: SourceFile): void {\r\n    sourceFile.forget();\r\n  }\r\n\r\n  /**\r\n   * Clear all files from the project\r\n   */\r\n  clearAll(): void {\r\n    this.project.getSourceFiles().forEach(sf => sf.forget());\r\n  }\r\n\r\n  /**\r\n   * Get the ts-morph Project instance\r\n   * @returns The Project instance\r\n   */\r\n  getProject(): Project {\r\n    return this.project;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// AST Query Helpers\r\n// ============================================================================\r\n\r\n/**\r\n * Query helper functions for common AST operations\r\n */\r\nexport class ASTQueryHelper {\r\n  /**\r\n   * Find all function declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  static findFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all arrow functions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  static findArrowFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Find all function expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  static findFunctionExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all functions (declarations, expressions, and arrow functions)\r\n   * @param ast Source file AST\r\n   * @returns Array of all function nodes\r\n   */\r\n  static findAllFunctions(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all method declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  static findMethods(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all class declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  static findClasses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all interface declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  static findInterfaces(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type alias declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  static findTypeAliases(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type definitions (interfaces and type aliases)\r\n   * @param ast Source file AST\r\n   * @returns Array of type definition nodes\r\n   */\r\n  static findTypes(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findInterfaces(ast),\r\n      ...this.findTypeAliases(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all import declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  static findImports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all export declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  static findExports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all variable declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  static findVariables(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all const declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of const variable declaration nodes\r\n   */\r\n  static findConstants(ast: SourceFile): Node[] {\r\n    const variableStatements = ast.getDescendantsOfKind(SyntaxKind.VariableStatement);\r\n    const constants: Node[] = [];\r\n\r\n    for (const statement of variableStatements) {\r\n      const declarationList = statement.getFirstChildByKind(SyntaxKind.VariableDeclarationList);\r\n      if (declarationList) {\r\n        const flags = (declarationList as any).getDeclarationKind?.();\r\n        if (flags === 2) { // VariableDeclarationKind.Const\r\n          constants.push(...declarationList.getDescendantsOfKind(SyntaxKind.VariableDeclaration));\r\n        }\r\n      }\r\n    }\r\n\r\n    return constants;\r\n  }\r\n\r\n  /**\r\n   * Find all if statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  static findIfStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all for statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of for statement nodes\r\n   */\r\n  static findForStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ForStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all while statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of while statement nodes\r\n   */\r\n  static findWhileStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.WhileStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all switch statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of switch statement nodes\r\n   */\r\n  static findSwitchStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.SwitchStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all try statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of try statement nodes\r\n   */\r\n  static findTryStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TryStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all catch clauses in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of catch clause nodes\r\n   */\r\n  static findCatchClauses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CatchClause);\r\n  }\r\n\r\n  /**\r\n   * Find all call expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  static findCallExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CallExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of JSX element nodes\r\n   */\r\n  static findJSXElements(ast: SourceFile): Node[] {\r\n    return [\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxElement),\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all React component declarations (function components)\r\n   * @param ast Source file AST\r\n   * @returns Array of React component nodes\r\n   */\r\n  static findReactComponents(ast: SourceFile): Node[] {\r\n    const components: Node[] = [];\r\n    \r\n    // Find function declarations that return JSX\r\n    const functions = [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const text = func.getText();\r\n      // Check if function returns JSX (contains JSX syntax)\r\n      if (text.includes('<') && text.includes('/>') || text.includes('</')) {\r\n        components.push(func);\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes with 'any' type annotation\r\n   * @param ast Source file AST\r\n   * @returns Array of nodes with 'any' type\r\n   */\r\n  static findAnyTypes(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AnyKeyword);\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions (as Type)\r\n   * @param ast Source file AST\r\n   * @returns Array of type assertion nodes\r\n   */\r\n  static findTypeAssertions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AsExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all comments in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of comment texts\r\n   */\r\n  static findComments(ast: SourceFile): string[] {\r\n    const comments: string[] = [];\r\n    const fullText = ast.getFullText();\r\n    \r\n    // Get all comment ranges\r\n    ast.forEachDescendant(node => {\r\n      const leadingComments = node.getLeadingCommentRanges();\r\n      const trailingComments = node.getTrailingCommentRanges();\r\n      \r\n      for (const range of [...leadingComments, ...trailingComments]) {\r\n        const commentText = fullText.substring(range.getPos(), range.getEnd());\r\n        comments.push(commentText);\r\n      }\r\n    });\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Find all commented-out code blocks\r\n   * @param ast Source file AST\r\n   * @returns Array of commented code blocks\r\n   */\r\n  static findCommentedCode(ast: SourceFile): string[] {\r\n    const comments = this.findComments(ast);\r\n    const commentedCode: string[] = [];\r\n    \r\n    for (const comment of comments) {\r\n      // Remove comment markers\r\n      const cleaned = comment\r\n        .replace(/^\\/\\*+/, '')\r\n        .replace(/\\*+\\/$/, '')\r\n        .replace(/^\\/\\/+/gm, '')\r\n        .trim();\r\n      \r\n      // Check if it looks like code (has common code patterns)\r\n      const codePatterns = [\r\n        /function\\s+\\w+/,\r\n        /const\\s+\\w+\\s*=/,\r\n        /let\\s+\\w+\\s*=/,\r\n        /var\\s+\\w+\\s*=/,\r\n        /class\\s+\\w+/,\r\n        /interface\\s+\\w+/,\r\n        /type\\s+\\w+\\s*=/,\r\n        /import\\s+.*from/,\r\n        /export\\s+(default|const|function|class)/,\r\n        /if\\s*\\(/,\r\n        /for\\s*\\(/,\r\n        /while\\s*\\(/,\r\n        /=>\\s*{/,\r\n      ];\r\n      \r\n      if (codePatterns.some(pattern => pattern.test(cleaned))) {\r\n        commentedCode.push(comment);\r\n      }\r\n    }\r\n    \r\n    return commentedCode;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by custom predicate\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByPredicate(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const matches: Node[] = [];\r\n    \r\n    ast.forEachDescendant(node => {\r\n      if (predicate(node)) {\r\n        matches.push(node);\r\n      }\r\n    });\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by syntax kind\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    return ast.getDescendantsOfKind(kind);\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  static getNodeName(node: Node): string | undefined {\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  static isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    if (!nodeWithModifiers.getModifiers) {\r\n      return false;\r\n    }\r\n    \r\n    const modifiers = nodeWithModifiers.getModifiers();\r\n    return modifiers.some((mod: any) => \r\n      mod.getKind() === SyntaxKind.ExportKeyword\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculate the cyclomatic complexity of a function\r\n   * @param node Function node\r\n   * @returns Complexity score\r\n   */\r\n  static calculateComplexity(node: Node): number {\r\n    let complexity = 1; // Base complexity\r\n    \r\n    // Count decision points\r\n    const decisionPoints = [\r\n      SyntaxKind.IfStatement,\r\n      SyntaxKind.ConditionalExpression,\r\n      SyntaxKind.CaseClause,\r\n      SyntaxKind.ForStatement,\r\n      SyntaxKind.ForInStatement,\r\n      SyntaxKind.ForOfStatement,\r\n      SyntaxKind.WhileStatement,\r\n      SyntaxKind.DoStatement,\r\n      SyntaxKind.CatchClause,\r\n      SyntaxKind.BinaryExpression, // For && and ||\r\n    ];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (decisionPoints.includes(child.getKind())) {\r\n        // For binary expressions, only count logical operators\r\n        if (child.getKind() === SyntaxKind.BinaryExpression) {\r\n          const text = child.getText();\r\n          if (text.includes('&&') || text.includes('||')) {\r\n            complexity++;\r\n          }\r\n        } else {\r\n          complexity++;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return complexity;\r\n  }\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Maximum nesting depth\r\n   */\r\n  static calculateNestingDepth(node: Node): number {\r\n    let maxDepth = 0;\r\n    \r\n    const traverse = (n: Node, depth: number) => {\r\n      maxDepth = Math.max(maxDepth, depth);\r\n      \r\n      const kind = n.getKind();\r\n      const nestingKinds = [\r\n        SyntaxKind.IfStatement,\r\n        SyntaxKind.ForStatement,\r\n        SyntaxKind.ForInStatement,\r\n        SyntaxKind.ForOfStatement,\r\n        SyntaxKind.WhileStatement,\r\n        SyntaxKind.DoStatement,\r\n        SyntaxKind.SwitchStatement,\r\n        SyntaxKind.TryStatement,\r\n        SyntaxKind.CatchClause,\r\n      ];\r\n      \r\n      const newDepth = nestingKinds.includes(kind) ? depth + 1 : depth;\r\n      \r\n      n.forEachChild(child => traverse(child, newDepth));\r\n    };\r\n    \r\n    traverse(node, 0);\r\n    return maxDepth;\r\n  }\r\n\r\n  /**\r\n   * Get all identifiers in a node\r\n   * @param node AST node\r\n   * @returns Array of identifier names\r\n   */\r\n  static getIdentifiers(node: Node): string[] {\r\n    const identifiers: string[] = [];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (child.getKind() === SyntaxKind.Identifier) {\r\n        identifiers.push(child.getText());\r\n      }\r\n    });\r\n    \r\n    return identifiers;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  static containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n}\r\n\r\n/**\r\n * Export a singleton instance of ASTParser for convenience\r\n */\r\nexport const astParser = new ASTParser();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[572,575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[572,575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1508,1511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1508,1511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2011,2014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2011,2014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test for arrow function detection\r\n */\r\n\r\nimport { Project, Node } from 'ts-morph';\r\n\r\nasync function testArrowFunctionAnalysis() {\r\n  console.log('Detailed arrow function analysis...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Find the arrow function\r\n  let arrowFunc: any = null;\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (Node.isArrowFunction(node)) {\r\n      arrowFunc = node;\r\n    }\r\n  });\r\n\r\n  if (!arrowFunc) {\r\n    console.log('No arrow function found!');\r\n    return;\r\n  }\r\n\r\n  console.log('Arrow function found!');\r\n  console.log('Full text:', arrowFunc.getText());\r\n  \r\n  const body = arrowFunc.getBody();\r\n  console.log('\\nBody kind:', body.getKindName());\r\n  console.log('Body text:', body.getText());\r\n  console.log('Body is Block?', Node.isBlock(body));\r\n  console.log('Body is CallExpression?', Node.isCallExpression(body));\r\n  \r\n  // Check if body is a call expression\r\n  if (Node.isCallExpression(body)) {\r\n    console.log('\\n‚úì Body is a call expression (expression body)');\r\n    console.log('Call text:', body.getText());\r\n    \r\n    const expression = body.getExpression();\r\n    console.log('Expression:', expression.getText());\r\n  }\r\n  \r\n  // Get statements\r\n  let statements: any[] = [];\r\n  if (Node.isBlock(body)) {\r\n    statements = body.getStatements();\r\n    console.log('\\nStatements in block:', statements.length);\r\n  } else {\r\n    statements = [body];\r\n    console.log('\\nExpression body (single statement)');\r\n  }\r\n  \r\n  console.log('Statement count:', statements.length);\r\n  statements.forEach((stmt, i) => {\r\n    console.log(`  Statement ${i}: ${stmt.getKindName()} - ${stmt.getText().substring(0, 50)}`);\r\n  });\r\n  \r\n  // Get call expressions\r\n  const callExpressions: any[] = [];\r\n  body.forEachDescendant((node) => {\r\n    if (Node.isCallExpression(node)) {\r\n      callExpressions.push(node);\r\n    }\r\n  });\r\n  \r\n  console.log('\\nCall expressions found:', callExpressions.length);\r\n  callExpressions.forEach((call, i) => {\r\n    console.log(`  Call ${i}: ${call.getText()}`);\r\n  });\r\n  \r\n  // Get parameters\r\n  const params = arrowFunc.getParameters();\r\n  console.log('\\nParameters:', params.length);\r\n  params.forEach((param: any) => {\r\n    console.log(`  - ${param.getName()}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctionAnalysis().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-function-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1189,1192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1189,1192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1575,1578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1575,1578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug test for arrow function detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { AdapterPatternAnalyzer } from './src/analyzers/adapter-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nfunction createFileInfo(path: string): FileInfo {\r\n  return {\r\n    path: `/test/${path}`,\r\n    relativePath: path,\r\n    extension: '.ts',\r\n    size: 1000,\r\n    category: 'util',\r\n  };\r\n}\r\n\r\nasync function testArrowFunctions() {\r\n  console.log('Testing arrow function detection...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n    \r\n    const checkAuth = (userId: string) => supabase.auth.getUser(userId);\r\n    \r\n    const verifyUser = (id: string) => authService.verify(id);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Check what functions are found\r\n  console.log('Functions found in AST:');\r\n  const functions = sourceFile.getFunctions();\r\n  console.log(`  Regular functions: ${functions.length}`);\r\n  \r\n  const arrowFunctions: any[] = [];\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (node.getKindName() === 'ArrowFunction') {\r\n      arrowFunctions.push(node);\r\n      const parent = node.getParent();\r\n      console.log(`  Arrow function found, parent: ${parent?.getKindName()}`);\r\n      if (parent && parent.getKindName() === 'VariableDeclaration') {\r\n        console.log(`    Variable name: ${(parent as any).getName()}`);\r\n      }\r\n    }\r\n  });\r\n  console.log(`  Arrow functions: ${arrowFunctions.length}\\n`);\r\n\r\n  const analyzer = new AdapterPatternAnalyzer();\r\n  const issues = await analyzer.analyze(createFileInfo('test.ts'), sourceFile);\r\n  \r\n  console.log(`Issues found: ${issues.length}`);\r\n  issues.forEach(issue => {\r\n    console.log(`  - ${issue.description}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctions().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-export-detection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1309,1312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1309,1312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Test export detection for variable declarations\r\n */\r\n\r\nimport { Project, SyntaxKind } from 'ts-morph';\r\n\r\nasync function testExportDetection() {\r\n  console.log('Testing Export Detection...\\n');\r\n\r\n  const project = new Project();\r\n  \r\n  const code = `\r\n    export const passthrough = (req: Request, res: Response, next: NextFunction) => next();\r\n    export const noop = (req: any, res: any, next: any) => next();\r\n    const notExported = () => {};\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  const varDecls = sourceFile.getVariableDeclarations();\r\n  \r\n  console.log('Variable declarations found:');\r\n  varDecls.forEach(varDecl => {\r\n    const name = varDecl.getName();\r\n    console.log(`\\n  Variable: ${name}`);\r\n    \r\n    // Check modifiers on the variable declaration itself\r\n    const declModifiers = (varDecl as any).getModifiers?.() || [];\r\n    console.log(`    Modifiers on declaration: ${declModifiers.length}`);\r\n    \r\n    // Check modifiers on the parent variable statement\r\n    const parent = varDecl.getParent();\r\n    console.log(`    Parent type: ${parent.getKindName()}`);\r\n    \r\n    const parentParent = parent.getParent();\r\n    console.log(`    Parent's parent type: ${parentParent?.getKindName()}`);\r\n    \r\n    if (parentParent && (parentParent as any).getModifiers) {\r\n      const parentModifiers = (parentParent as any).getModifiers();\r\n      console.log(`    Modifiers on parent's parent: ${parentModifiers.length}`);\r\n      const hasExport = parentModifiers.some((mod: any) => \r\n        mod.getKind() === SyntaxKind.ExportKeyword\r\n      );\r\n      console.log(`    Has export keyword: ${hasExport}`);\r\n    }\r\n  });\r\n}\r\n\r\ntestExportDetection().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-middleware-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[432,435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[432,435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2466,2469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2466,2469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2965,2968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2965,2968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3176,3179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3176,3179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3184,3187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3184,3187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3229,3232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3229,3232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test to trace middleware usage extraction\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\n// Extend the analyzer to expose internal state for debugging\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function detailedDebug() {\r\n  console.log('Detailed Middleware Usage Debug...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware library\r\n  const middlewareLib = `\r\n    export function authenticateMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authenticating...');\r\n      next();\r\n    }\r\n\r\n    export function authorizeMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authorizing...');\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/auth.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/auth.ts',\r\n    relativePath: 'middleware/auth.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  console.log('After analyzing middleware library:');\r\n  console.log('Usages:', analyzer.getMiddlewareUsages());\r\n  console.log();\r\n\r\n  // Create route with wrong order\r\n  const routeCode = `\r\n    import { authenticateMiddleware, authorizeMiddleware } from '../middleware/auth';\r\n\r\n    export async function GET(req: Request) {\r\n      // Wrong order: authorize before authenticate\r\n      authorizeMiddleware(req, res, next);\r\n      authenticateMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'success' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  \r\n  console.log('Analyzing route file...');\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('\\nAfter analyzing route:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  console.log(`Total usages tracked: ${usages.length}`);\r\n  usages.forEach((usage: any, idx: number) => {\r\n    console.log(`  Usage ${idx + 1}:`);\r\n    console.log(`    Middleware name: \"${usage.middlewareName}\"`);\r\n    console.log(`    Route file: ${usage.routeFile}`);\r\n    console.log(`    Order: ${usage.order}`);\r\n  });\r\n  console.log();\r\n\r\n  console.log('Route issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  ‚ö†Ô∏è  No issues found!');\r\n    console.log('\\nLet me check what the ordering detection sees:');\r\n    \r\n    const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n    console.log(`  Usages for this route: ${routeUsages.length}`);\r\n    \r\n    if (routeUsages.length > 0) {\r\n      const order = routeUsages\r\n        .sort((a: any, b: any) => a.order - b.order)\r\n        .map((u: any) => u.middlewareName.toLowerCase());\r\n      \r\n      console.log(`  Order array: [${order.join(', ')}]`);\r\n      \r\n      const authIndex = order.findIndex((name: string) => \r\n        name.includes('auth') || name.includes('authenticate')\r\n      );\r\n      const authorizeIndex = order.findIndex((name: string) => \r\n        name.includes('authorize') || name.includes('permission')\r\n      );\r\n      \r\n      console.log(`  Auth index: ${authIndex} (looking for 'auth' or 'authenticate')`);\r\n      console.log(`  Authorize index: ${authorizeIndex} (looking for 'authorize' or 'permission')`);\r\n      console.log(`  Should trigger anti-pattern: ${authIndex > authorizeIndex && authIndex >= 0 && authorizeIndex >= 0}`);\r\n    }\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description}`);\r\n    });\r\n  }\r\n}\r\n\r\ndetailedDebug().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-rate-limit-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[342,345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[342,345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2293,2296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2293,2296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2426,2429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2426,2429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2520,2523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2520,2523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2528,2531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2528,2531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2569,2572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2569,2572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug rate limiting detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function debugRateLimit() {\r\n  console.log('Debugging Rate Limit Detection...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware\r\n  const middlewareLib = `\r\n    export function rateLimitMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic1(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic2(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic3(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/lib.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/lib.ts',\r\n    relativePath: 'middleware/lib.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  // Create route with rate limit at the end\r\n  const routeCode = `\r\n    import { businessLogic1, businessLogic2, businessLogic3, rateLimitMiddleware } from '../middleware/lib';\r\n\r\n    export async function POST(req: Request) {\r\n      businessLogic1(req, res, next);\r\n      businessLogic2(req, res, next);\r\n      businessLogic3(req, res, next);\r\n      rateLimitMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'created' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('Usages tracked:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  usages.forEach((u: any) => {\r\n    console.log(`  ${u.order}: ${u.middlewareName}`);\r\n  });\r\n  console.log();\r\n\r\n  const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n  const order = routeUsages\r\n    .sort((a: any, b: any) => a.order - b.order)\r\n    .map((u: any) => u.middlewareName.toLowerCase());\r\n  \r\n  console.log(`Order array: [${order.join(', ')}]`);\r\n  \r\n  const rateLimitIndex = order.findIndex((name: string) => \r\n    name.includes('ratelimit') || name.includes('rate-limit') || name.includes('throttle')\r\n  );\r\n  \r\n  console.log(`Rate limit index: ${rateLimitIndex}`);\r\n  console.log(`Should trigger (index > 2): ${rateLimitIndex > 2}`);\r\n  console.log();\r\n\r\n  console.log('Issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  ‚ö†Ô∏è  No issues!');\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description.substring(0, 100)}`);\r\n    });\r\n  }\r\n}\r\n\r\ndebugRateLimit().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\content-layout-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport { ToggleGroup, ToggleGroupItem } from \"@/components/ui/toggle-group\";\r\n\r\nexport function ContentLayoutSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  return (\r\n    <div className=\"hidden flex-col gap-4 lg:flex\">\r\n      <Label>Content layout</Label>\r\n      <ToggleGroup\r\n        value={theme.contentLayout}\r\n        type=\"single\"\r\n        onValueChange={(value) => setTheme({ ...theme, contentLayout: value as any })}\r\n        className=\"*:border-input w-full gap-4 *:rounded-md *:border\">\r\n        <ToggleGroupItem variant=\"outline\" value=\"full\">\r\n          Full\r\n        </ToggleGroupItem>\r\n        <ToggleGroupItem\r\n          variant=\"outline\"\r\n          value=\"centered\"\r\n          className=\"data-[variant=outline]:border-l-1\">\r\n          Centered\r\n        </ToggleGroupItem>\r\n      </ToggleGroup>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\preset-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { DEFAULT_THEME, THEMES } from \"@/lib/themes\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue\r\n} from \"@/components/ui/select\";\r\nimport { Label } from \"@/components/ui/label\";\r\n\r\nexport function PresetSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  const handlePreset = (value: string) => {\r\n    setTheme({ ...theme, ...DEFAULT_THEME, preset: value as any });\r\n  };\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-4\">\r\n      <Label>Theme preset:</Label>\r\n      <Select value={theme.preset} onValueChange={(value) => handlePreset(value)}>\r\n        <SelectTrigger className=\"w-full\">\r\n          <SelectValue placeholder=\"Select a theme\" />\r\n        </SelectTrigger>\r\n        <SelectContent align=\"end\">\r\n          {THEMES.map((theme) => (\r\n            <SelectItem key={theme.name} value={theme.value}>\r\n              <div className=\"flex shrink-0 gap-1\">\r\n                {theme.colors.map((color, key) => (\r\n                  <span\r\n                    key={key}\r\n                    className=\"size-2 rounded-full\"\r\n                    style={{ backgroundColor: color }}></span>\r\n                ))}\r\n              </div>\r\n              {theme.name}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\ui\\custom\\minimal-tiptap\\extensions\\code-block-lowlight\\code-block-lowlight.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[325,328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[325,328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CodeBlockLowlight as TiptapCodeBlockLowlight } from \"@tiptap/extension-code-block-lowlight\";\r\nimport { common, createLowlight } from \"lowlight\";\r\n\r\nexport const CodeBlockLowlight = TiptapCodeBlockLowlight.extend({\r\n  addOptions() {\r\n    return {\r\n      ...this.parent?.(),\r\n      lowlight: createLowlight(common) as any,\r\n      defaultLanguage: null,\r\n      HTMLAttributes: {\r\n        class: \"block-node\",\r\n      },\r\n    };\r\n  },\r\n});\r\n\r\nexport default CodeBlockLowlight;\r\n","usedDeprecatedRules":[]}]
