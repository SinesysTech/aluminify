[{"filePath":"E:\\Development\\aluminify\\app\\actions\\agendamentos.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1976,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1976,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[57178,57181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[57178,57181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1002,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1002,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28855,28858],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28855,28858],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1357,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1357,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[39084,39087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[39084,39087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1419,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1419,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[40761,40764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[40761,40764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1563,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1563,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[45147,45150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[45147,45150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2376,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2376,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[68666,68669],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[68666,68669],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2414,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2414,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[69876,69879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[69876,69879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use server\";\r\n\r\nimport { createClient } from \"@/lib/server\";\r\nimport type { Database } from \"@/lib/database.types\";\r\nimport { revalidatePath } from \"next/cache\";\r\nimport {\r\n  validateCancellation,\r\n  validateAppointment,\r\n  generateAvailableSlots,\r\n} from \"@/lib/agendamento-validations\";\r\nimport { generateMeetingLink } from \"@/lib/meeting-providers\";\r\n\r\n// =============================================\r\n// Type Aliases from Generated Database Types\r\n// =============================================\r\n\r\n// Tables that exist in the schema - use these for type inference\r\ntype DbAgendamentoRecorrencia =\r\n  Database[\"public\"][\"Tables\"][\"agendamento_recorrencia\"][\"Row\"];\r\ntype DbAgendamentoBloqueio =\r\n  Database[\"public\"][\"Tables\"][\"agendamento_bloqueios\"][\"Row\"];\r\ntype DbAgendamento = Database[\"public\"][\"Tables\"][\"agendamentos\"][\"Row\"];\r\ntype DbAgendamentoConfiguracoes =\r\n  Database[\"public\"][\"Tables\"][\"agendamento_configuracoes\"][\"Row\"];\r\n\r\n// Enums from schema\r\ntype TipoBloqueioEnum = Database[\"public\"][\"Enums\"][\"enum_tipo_bloqueio\"];\r\ntype TipoServicoEnum =\r\n  Database[\"public\"][\"Enums\"][\"enum_tipo_servico_agendamento\"];\r\n\r\n// Suppress unused variable warnings - these types document the schema\r\nvoid (0 as unknown as DbAgendamento);\r\nvoid (0 as unknown as DbAgendamentoConfiguracoes);\r\nvoid (0 as unknown as TipoBloqueioEnum);\r\nvoid (0 as unknown as TipoServicoEnum);\r\n\r\n// =============================================\r\n// Types for tables NOT in generated schema\r\n// These require 'as any' casts when used with Supabase client\r\n// TODO: Apply migrations and regenerate types to remove these\r\n// =============================================\r\n\r\n/**\r\n * View for company-wide appointments - not in generated schema\r\n * Migration: needs to be created or schema regenerated\r\n */\r\ntype VAgendamentosEmpresa = {\r\n  id: string;\r\n  professor_id: string;\r\n  aluno_id: string;\r\n  data_inicio: string;\r\n  data_fim: string;\r\n  status: string;\r\n  empresa_id: string;\r\n  professor_nome?: string;\r\n  professor_foto?: string;\r\n  aluno_nome?: string;\r\n  aluno_email?: string;\r\n  link_reuniao?: string | null;\r\n  observacoes?: string | null;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n  [key: string]: unknown;\r\n};\r\n\r\n/**\r\n * Professor integrations table - not in generated schema\r\n * Migration: 20260117_create_professor_integracoes.sql needs to be applied\r\n */\r\ntype DbProfessorIntegracao = {\r\n  id: string;\r\n  professor_id: string;\r\n  provider: \"google\" | \"zoom\" | \"default\";\r\n  access_token: string | null;\r\n  refresh_token: string | null;\r\n  token_expiry: string | null;\r\n  created_at: string;\r\n  updated_at: string;\r\n};\r\n\r\n/**\r\n * Reports table - not in generated schema\r\n * Migration: 20260117_create_agendamento_relatorios.sql needs to be applied\r\n */\r\ntype DbAgendamentoRelatorio = {\r\n  id: string;\r\n  empresa_id: string;\r\n  periodo_inicio: string;\r\n  periodo_fim: string;\r\n  tipo: \"mensal\" | \"semanal\" | \"customizado\";\r\n  dados_json: unknown; // Cast to RelatorioDados when using\r\n  gerado_em: string;\r\n  gerado_por: string;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport type Disponibilidade = {\r\n  id?: string;\r\n  professor_id?: string;\r\n  dia_semana: number; // 0-6\r\n  hora_inicio: string; // HH:MM\r\n  hora_fim: string; // HH:MM\r\n  ativo: boolean;\r\n};\r\n\r\nexport type Agendamento = {\r\n  id?: string;\r\n  professor_id: string;\r\n  aluno_id: string;\r\n  data_inicio: string | Date;\r\n  data_fim: string | Date;\r\n  status: \"pendente\" | \"confirmado\" | \"cancelado\" | \"concluido\";\r\n  link_reuniao?: string | null;\r\n  observacoes?: string | null;\r\n  motivo_cancelamento?: string | null;\r\n  cancelado_por?: string | null;\r\n  confirmado_em?: string | null;\r\n  lembrete_enviado?: boolean;\r\n  lembrete_enviado_em?: string | null;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport type AgendamentoComDetalhes = Agendamento & {\r\n  aluno?: {\r\n    id: string;\r\n    nome: string;\r\n    email: string;\r\n    avatar_url?: string | null;\r\n  };\r\n  professor?: {\r\n    id: string;\r\n    nome: string;\r\n    email: string;\r\n    avatar_url?: string | null;\r\n  };\r\n};\r\n\r\nexport type ConfiguracoesProfessor = {\r\n  id?: string;\r\n  professor_id?: string;\r\n  auto_confirmar: boolean;\r\n  tempo_antecedencia_minimo: number; // minutes\r\n  tempo_lembrete_minutos: number; // minutes\r\n  link_reuniao_padrao?: string | null;\r\n  mensagem_confirmacao?: string | null;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport type AgendamentoFilters = {\r\n  status?: string | string[];\r\n  dateStart?: Date;\r\n  dateEnd?: Date;\r\n};\r\n\r\nexport type AgendamentoNotificacao = {\r\n  id?: string;\r\n  agendamento_id: string;\r\n  tipo:\r\n    | \"criacao\"\r\n    | \"confirmacao\"\r\n    | \"cancelamento\"\r\n    | \"lembrete\"\r\n    | \"alteracao\"\r\n    | \"rejeicao\";\r\n  destinatario_id: string;\r\n  enviado: boolean;\r\n  enviado_em?: string | null;\r\n  erro?: string | null;\r\n  created_at?: string;\r\n};\r\n\r\nexport type Recorrencia = {\r\n  id?: string;\r\n  professor_id: string;\r\n  empresa_id: string;\r\n  tipo_servico: \"plantao\" | \"mentoria\";\r\n  data_inicio: string; // YYYY-MM-DD\r\n  data_fim?: string | null; // YYYY-MM-DD, null = indefinida\r\n  dia_semana: number; // 0-6\r\n  hora_inicio: string; // HH:MM\r\n  hora_fim: string; // HH:MM\r\n  duracao_slot_minutos: number; // 15, 30, 45, or 60\r\n  ativo: boolean;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport type Bloqueio = {\r\n  id?: string;\r\n  professor_id?: string | null; // null = bloqueio para toda empresa\r\n  empresa_id: string;\r\n  tipo: \"feriado\" | \"recesso\" | \"imprevisto\" | \"outro\";\r\n  data_inicio: string | Date;\r\n  data_fim: string | Date;\r\n  motivo?: string | null;\r\n  criado_por: string;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport async function getDisponibilidade(professorId: string) {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamento_disponibilidade\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .eq(\"ativo\", true);\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching availability:\", error);\r\n    return [];\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\nexport async function upsertDisponibilidade(data: Disponibilidade) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Fetch professor's empresa_id\r\n  const { data: professor } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"empresa_id\")\r\n    .eq(\"id\", user.id)\r\n    .single();\r\n\r\n  const empresaId = professor?.empresa_id;\r\n\r\n  if (!empresaId) {\r\n    throw new Error(\"Professor company not found\");\r\n  }\r\n\r\n  const payload: Database[\"public\"][\"Tables\"][\"agendamento_disponibilidade\"][\"Insert\"] =\r\n    {\r\n      ...data,\r\n      professor_id: user.id,\r\n      empresa_id: empresaId,\r\n      ativo: data.ativo,\r\n    };\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamento_disponibilidade\")\r\n    .upsert(payload)\r\n    .select();\r\n\r\n  if (error) {\r\n    console.error(\"Error upserting availability:\", error);\r\n    throw new Error(\"Failed to update availability\");\r\n  }\r\n\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\nexport async function getAgendamentos(\r\n  professorId: string,\r\n  start: Date,\r\n  end: Date,\r\n) {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .gte(\"data_inicio\", start.toISOString())\r\n    .lte(\"data_fim\", end.toISOString())\r\n    .neq(\"status\", \"cancelado\"); // Usually want to see occupied slots\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching appointments:\", error);\r\n    return [];\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\nexport async function createAgendamento(\r\n  data: Omit<Agendamento, \"id\" | \"created_at\" | \"updated_at\" | \"status\">,\r\n) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Load professor configuration\r\n  const config = await getConfiguracoesProfessor(data.professor_id);\r\n  const minAdvanceMinutes = config?.tempo_antecedencia_minimo || 60;\r\n\r\n  // Validate appointment using the validation library\r\n  const dataInicio = new Date(data.data_inicio);\r\n  const dataFim = new Date(data.data_fim);\r\n  const dateOnly = dataInicio.toISOString().split(\"T\")[0]; // YYYY-MM-DD format\r\n  const dayOfWeek = dataInicio.getUTCDay();\r\n\r\n  // Get availability rules from agendamento_recorrencia for validation\r\n  // Note: agendamento_recorrencia não está no schema atual, usando tipo genérico\r\n  type RecorrenciaRule = {\r\n    dia_semana: number;\r\n    hora_inicio: string;\r\n    hora_fim: string;\r\n    ativo: boolean;\r\n    data_inicio: string;\r\n    data_fim: string | null;\r\n    professor_id: string;\r\n  };\r\n\r\n  const { data: rulesData } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", data.professor_id)\r\n    .eq(\"dia_semana\", dayOfWeek)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", dateOnly)\r\n    .or(`data_fim.is.null,data_fim.gte.${dateOnly}`);\r\n\r\n  // Filter and map rules to ensure ativo is boolean\r\n  const rules = ((rulesData || []) as RecorrenciaRule[])\r\n    .filter((r) => r.ativo === true)\r\n    .map((r) => ({\r\n      dia_semana: r.dia_semana,\r\n      hora_inicio: r.hora_inicio,\r\n      hora_fim: r.hora_fim,\r\n      ativo: r.ativo,\r\n    }));\r\n\r\n  // Get existing bookings for conflict check\r\n  const { data: bookings } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"data_inicio, data_fim\")\r\n    .eq(\"professor_id\", data.professor_id)\r\n    .neq(\"status\", \"cancelado\");\r\n\r\n  const existingSlots = (bookings || []).map((b) => ({\r\n    start: new Date(b.data_inicio),\r\n    end: new Date(b.data_fim),\r\n  }));\r\n\r\n  // Get bloqueios for this professor and date\r\n  const { data: professor } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"empresa_id\")\r\n    .eq(\"id\", data.professor_id)\r\n    .single();\r\n\r\n  type ProfessorRow = {\r\n    empresa_id: string | null;\r\n  };\r\n  const empresaId = (professor as ProfessorRow)?.empresa_id;\r\n\r\n  if (empresaId) {\r\n    type BloqueioRow = {\r\n      data_inicio: string;\r\n      data_fim: string;\r\n    };\r\n    const { data: bloqueios } = await supabase\r\n      .from(\"agendamento_bloqueios\")\r\n      .select(\"data_inicio, data_fim\")\r\n      .eq(\"empresa_id\", empresaId)\r\n      .or(`professor_id.is.null,professor_id.eq.${data.professor_id}`)\r\n      .lte(\"data_inicio\", dataFim.toISOString())\r\n      .gte(\"data_fim\", dataInicio.toISOString());\r\n\r\n    // Add bloqueios to existing slots to exclude them\r\n    const blockedSlots = ((bloqueios || []) as BloqueioRow[]).map((b) => ({\r\n      start: new Date(b.data_inicio),\r\n      end: new Date(b.data_fim),\r\n    }));\r\n\r\n    existingSlots.push(...blockedSlots);\r\n  }\r\n\r\n  // Validate appointment - filter and map rules to ensure ativo is boolean\r\n  const validRules = rules.filter((r) => r.ativo === true);\r\n\r\n  const validationResult = validateAppointment(\r\n    { start: dataInicio, end: dataFim },\r\n    {\r\n      rules: validRules,\r\n      existingSlots,\r\n      minAdvanceMinutes,\r\n    },\r\n  );\r\n\r\n  if (!validationResult.valid) {\r\n    throw new Error(validationResult.error || \"Invalid appointment\");\r\n  }\r\n\r\n  // Determine initial status based on auto_confirmar setting\r\n  const initialStatus = config?.auto_confirmar ? \"confirmado\" : \"pendente\";\r\n  const confirmadoEm = config?.auto_confirmar ? new Date().toISOString() : null;\r\n\r\n  // Garantir que as datas sejam strings ISO para o banco\r\n  const payload: Database[\"public\"][\"Tables\"][\"agendamentos\"][\"Insert\"] = {\r\n    ...data,\r\n    professor_id: data.professor_id,\r\n    aluno_id: user.id,\r\n    data_inicio:\r\n      typeof data.data_inicio === \"string\"\r\n        ? data.data_inicio\r\n        : dataInicio.toISOString(),\r\n    data_fim:\r\n      typeof data.data_fim === \"string\" ? data.data_fim : dataFim.toISOString(),\r\n    status: initialStatus,\r\n    confirmado_em: confirmadoEm,\r\n    observacoes: data.observacoes || null,\r\n    link_reuniao: data.link_reuniao || null,\r\n    empresa_id: empresaId || \"\",\r\n  };\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .insert(payload)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error creating appointment:\", error);\r\n    throw new Error(error.message || \"Falha ao criar agendamento\");\r\n  }\r\n\r\n  revalidatePath(\"/agendamentos\");\r\n  return result;\r\n}\r\n\r\nexport async function cancelAgendamento(id: string) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership - user must be either aluno or professor of the appointment\r\n  const { data: agendamento } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"professor_id, aluno_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!agendamento) {\r\n    throw new Error(\"Agendamento nao encontrado\");\r\n  }\r\n\r\n  const isOwner =\r\n    agendamento.aluno_id === user.id || agendamento.professor_id === user.id;\r\n  if (!isOwner) {\r\n    throw new Error(\"Voce nao tem permissao para cancelar este agendamento\");\r\n  }\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .update({\r\n      status: \"cancelado\",\r\n      cancelado_por: user.id,\r\n    })\r\n    .eq(\"id\", id);\r\n\r\n  if (error) {\r\n    console.error(\"Error cancelling appointment:\", error);\r\n    throw new Error(\"Falha ao cancelar agendamento\");\r\n  }\r\n\r\n  revalidatePath(\"/agendamentos\");\r\n  revalidatePath(\"/meus-agendamentos\");\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\nexport async function getAvailableSlots(professorId: string, dateStr: string) {\r\n  const supabase = await createClient();\r\n\r\n  const date = new Date(dateStr);\r\n  const dayOfWeek = date.getUTCDay(); // 0-6\r\n  const dateOnly = dateStr.split(\"T\")[0]; // YYYY-MM-DD format\r\n\r\n  // Get professor configuration for minimum advance time\r\n  const config = await getConfiguracoesProfessor(professorId);\r\n  const minAdvanceMinutes = config?.tempo_antecedencia_minimo || 60;\r\n\r\n  // Get availability rules from agendamento_recorrencia\r\n  // Filtrar por data_inicio <= dateStr <= data_fim (ou data_fim IS NULL)\r\n  const { data: rulesData } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .eq(\"dia_semana\", dayOfWeek)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", dateOnly)\r\n    .or(`data_fim.is.null,data_fim.gte.${dateOnly}`);\r\n\r\n  // Filter and map rules to ensure ativo is boolean\r\n  const rules = ((rulesData || []) as DbAgendamentoRecorrencia[])\r\n    .filter((r) => r.ativo === true)\r\n    .map((r) => ({\r\n      dia_semana: r.dia_semana,\r\n      hora_inicio: r.hora_inicio,\r\n      hora_fim: r.hora_fim,\r\n      ativo: r.ativo,\r\n      duracao_slot_minutos: r.duracao_slot_minutos || 30,\r\n    }));\r\n\r\n  if (!rules || rules.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Get existing bookings\r\n  const startOfDay = new Date(dateStr);\r\n  startOfDay.setUTCHours(0, 0, 0, 0);\r\n  const endOfDay = new Date(dateStr);\r\n  endOfDay.setUTCHours(23, 59, 59, 999);\r\n\r\n  const { data: bookings } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .gte(\"data_inicio\", startOfDay.toISOString())\r\n    .lte(\"data_fim\", endOfDay.toISOString())\r\n    .neq(\"status\", \"cancelado\");\r\n\r\n  const existingSlots = (bookings || []).map((b) => ({\r\n    start: new Date(b.data_inicio),\r\n    end: new Date(b.data_fim),\r\n  }));\r\n\r\n  // Get bloqueios for this professor and date\r\n  const { data: professor } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"empresa_id\")\r\n    .eq(\"id\", professorId)\r\n    .single();\r\n\r\n  type ProfessorRow = {\r\n    empresa_id: string | null;\r\n  };\r\n  const empresaId = (professor as ProfessorRow)?.empresa_id;\r\n\r\n  let bloqueios: Array<{ data_inicio: string; data_fim: string }> = [];\r\n  if (empresaId) {\r\n    const { data: bloqueiosData } = await supabase\r\n      .from(\"agendamento_bloqueios\")\r\n      .select(\"data_inicio, data_fim\")\r\n      .eq(\"empresa_id\", empresaId)\r\n      .or(`professor_id.is.null,professor_id.eq.${professorId}`)\r\n      .lte(\"data_inicio\", endOfDay.toISOString())\r\n      .gte(\"data_fim\", startOfDay.toISOString());\r\n\r\n    bloqueios = (bloqueiosData as DbAgendamentoBloqueio[]) || [];\r\n  }\r\n\r\n  // Add bloqueios to existing slots to exclude them\r\n  const blockedSlots = bloqueios.map((b) => ({\r\n    start: new Date(b.data_inicio),\r\n    end: new Date(b.data_fim),\r\n  }));\r\n\r\n  const allBlockedSlots = [...existingSlots, ...blockedSlots];\r\n\r\n  // Use the validation library to generate available slots\r\n  // Filter rules to ensure ativo is boolean\r\n  const validRules = rules.filter((r) => r.ativo === true);\r\n\r\n  // Use the first rule's slot duration (or default to 30)\r\n  const slotDuration = validRules[0]?.duracao_slot_minutos || 30;\r\n\r\n  const slots = generateAvailableSlots(\r\n    date,\r\n    validRules,\r\n    allBlockedSlots,\r\n    slotDuration,\r\n    minAdvanceMinutes,\r\n  );\r\n\r\n  return {\r\n    slots: slots.map((slot) => slot.toISOString()),\r\n    slotDurationMinutes: slotDuration,\r\n  };\r\n}\r\n\r\n// Legacy function for backwards compatibility - returns only slot strings\r\nexport async function getAvailableSlotsLegacy(\r\n  professorId: string,\r\n  dateStr: string,\r\n): Promise<string[]> {\r\n  const result = await getAvailableSlots(professorId, dateStr);\r\n\r\n  // Type guard para garantir que result tem a estrutura esperada\r\n  if (\r\n    result &&\r\n    typeof result === \"object\" &&\r\n    \"slots\" in result &&\r\n    Array.isArray(result.slots)\r\n  ) {\r\n    return result.slots as string[];\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\n// Get availability summary for a month (which days have available slots)\r\nexport async function getAvailabilityForMonth(\r\n  professorId: string,\r\n  year: number,\r\n  month: number, // 1-12\r\n): Promise<{ [date: string]: { hasSlots: boolean; slotCount: number } }> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    return {};\r\n  }\r\n\r\n  // Get professor's empresa_id\r\n  const { data: professor } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"empresa_id\")\r\n    .eq(\"id\", professorId)\r\n    .single();\r\n\r\n  if (!professor?.empresa_id) {\r\n    return {};\r\n  }\r\n\r\n  // Get recorrencias for this professor\r\n  const monthStart = new Date(year, month - 1, 1);\r\n  const monthEnd = new Date(year, month, 0);\r\n\r\n  const { data: recorrencias } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .eq(\"ativo\", true)\r\n    .or(\r\n      `data_fim.is.null,data_fim.gte.${monthStart.toISOString().split(\"T\")[0]}`,\r\n    )\r\n    .lte(\"data_inicio\", monthEnd.toISOString().split(\"T\")[0]);\r\n\r\n  if (!recorrencias || recorrencias.length === 0) {\r\n    return {};\r\n  }\r\n\r\n  // Create a map of day of week -> recorrencias\r\n  const dayRecorrencias: { [dayOfWeek: number]: boolean } = {};\r\n  for (const rec of recorrencias) {\r\n    dayRecorrencias[rec.dia_semana] = true;\r\n  }\r\n\r\n  // Get existing appointments for the month\r\n  const { data: appointments } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"data_inicio\")\r\n    .eq(\"professor_id\", professorId)\r\n    .in(\"status\", [\"pendente\", \"confirmado\"])\r\n    .gte(\"data_inicio\", monthStart.toISOString())\r\n    .lte(\"data_inicio\", monthEnd.toISOString());\r\n\r\n  // Count appointments per date\r\n  const appointmentCounts: { [date: string]: number } = {};\r\n  for (const apt of appointments || []) {\r\n    const dateKey = new Date(apt.data_inicio).toISOString().split(\"T\")[0];\r\n    appointmentCounts[dateKey] = (appointmentCounts[dateKey] || 0) + 1;\r\n  }\r\n\r\n  // Build availability map for each day of the month\r\n  const availability: {\r\n    [date: string]: { hasSlots: boolean; slotCount: number };\r\n  } = {};\r\n  const today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n\r\n  for (let day = 1; day <= monthEnd.getDate(); day++) {\r\n    const date = new Date(year, month - 1, day);\r\n    const dateKey = date.toISOString().split(\"T\")[0];\r\n    const dayOfWeek = date.getUTCDay();\r\n\r\n    // Skip past dates\r\n    if (date < today) {\r\n      continue;\r\n    }\r\n\r\n    // Check if this day has recorrencias\r\n    if (dayRecorrencias[dayOfWeek]) {\r\n      // Estimate slot count (simplified - actual count would need full slot generation)\r\n      const existingCount = appointmentCounts[dateKey] || 0;\r\n      // Assume about 8-16 slots per day on average, minus existing appointments\r\n      const estimatedSlots = Math.max(0, 10 - existingCount);\r\n      availability[dateKey] = {\r\n        hasSlots: estimatedSlots > 0,\r\n        slotCount: estimatedSlots,\r\n      };\r\n    }\r\n  }\r\n\r\n  return availability;\r\n}\r\n\r\n// =============================================\r\n// Professor Dashboard Functions\r\n// =============================================\r\n\r\n// Helper function to check if a value is a valid aluno/professor object\r\nfunction isValidUserObject(obj: unknown): obj is {\r\n  id: string;\r\n  nome: string;\r\n  email: string;\r\n  avatar_url?: string | null;\r\n} {\r\n  return (\r\n    typeof obj === \"object\" &&\r\n    obj !== null &&\r\n    !(\"code\" in obj) &&\r\n    \"id\" in obj &&\r\n    \"nome\" in obj &&\r\n    \"email\" in obj\r\n  );\r\n}\r\n\r\nexport async function getAgendamentosProfessor(\r\n  professorId: string,\r\n  filters?: AgendamentoFilters,\r\n): Promise<AgendamentoComDetalhes[]> {\r\n  const supabase = await createClient();\r\n\r\n  // Primeiro, buscar os agendamentos\r\n  let query = supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .order(\"data_inicio\", { ascending: true });\r\n\r\n  if (filters?.status) {\r\n    if (Array.isArray(filters.status)) {\r\n      query = query.in(\"status\", filters.status);\r\n    } else {\r\n      query = query.eq(\"status\", filters.status);\r\n    }\r\n  }\r\n\r\n  if (filters?.dateStart) {\r\n    query = query.gte(\"data_inicio\", filters.dateStart.toISOString());\r\n  }\r\n\r\n  if (filters?.dateEnd) {\r\n    query = query.lte(\"data_inicio\", filters.dateEnd.toISOString());\r\n  }\r\n\r\n  const { data: agendamentos, error } = await query;\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching professor appointments:\", error);\r\n    return [];\r\n  }\r\n\r\n  if (!agendamentos || agendamentos.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Buscar dados dos alunos em lote\r\n  const alunoIds = [...new Set(agendamentos.map((a) => a.aluno_id))];\r\n  const { data: alunos, error: alunosError } = await supabase\r\n    .from(\"alunos\")\r\n    .select(\"id, nome_completo, email\")\r\n    .in(\"id\", alunoIds);\r\n\r\n  if (alunosError) {\r\n    console.error(\"Error fetching alunos data:\", alunosError);\r\n  }\r\n\r\n  // Criar um mapa de alunos por ID\r\n  const alunosMap = new Map((alunos || []).map((aluno) => [aluno.id, aluno]));\r\n\r\n  // Combinar agendamentos com dados dos alunos\r\n  return agendamentos.map((item) => {\r\n    const aluno = alunosMap.get(item.aluno_id);\r\n    const alunoData = aluno\r\n      ? {\r\n          id: aluno.id,\r\n          nome: aluno.nome_completo || \"\",\r\n          email: aluno.email || \"\",\r\n        }\r\n      : undefined;\r\n\r\n    return {\r\n      ...item,\r\n      status: item.status as Agendamento[\"status\"],\r\n      lembrete_enviado: item.lembrete_enviado ?? undefined,\r\n      created_at: item.created_at ?? undefined,\r\n      updated_at: item.updated_at ?? undefined,\r\n      aluno: alunoData,\r\n      professor: undefined,\r\n    };\r\n  });\r\n}\r\n\r\nexport async function getAgendamentosAluno(\r\n  alunoId: string,\r\n): Promise<AgendamentoComDetalhes[]> {\r\n  const supabase = await createClient();\r\n\r\n  // Verificar autenticação do usuário\r\n  const {\r\n    data: { user },\r\n    error: authError,\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (authError || !user) {\r\n    console.error(\"Authentication error in getAgendamentosAluno:\", authError);\r\n    return [];\r\n  }\r\n\r\n  // Verificar se o usuário autenticado é o mesmo que está buscando os agendamentos\r\n  if (user.id !== alunoId) {\r\n    console.error(\r\n      \"User mismatch: authenticated user is not the same as requested aluno_id\",\r\n    );\r\n    return [];\r\n  }\r\n\r\n  // Buscar agendamentos primeiro\r\n  const { data: agendamentos, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"*\")\r\n    .eq(\"aluno_id\", alunoId)\r\n    .order(\"data_inicio\", { ascending: false });\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching student appointments:\", {\r\n      message: error.message || \"No message\",\r\n      details: error.details || \"No details\",\r\n      hint: error.hint || \"No hint\",\r\n      code: error.code || \"No code\",\r\n      alunoId,\r\n      userId: user.id,\r\n      errorObject: JSON.stringify(error),\r\n    });\r\n    return [];\r\n  }\r\n\r\n  if (!agendamentos || agendamentos.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // Buscar dados dos professores em lote\r\n  const professorIds = [...new Set(agendamentos.map((a) => a.professor_id))];\r\n  const { data: professores, error: professoresError } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"id, nome_completo, email, foto_url\")\r\n    .in(\"id\", professorIds);\r\n\r\n  if (professoresError) {\r\n    console.error(\"Error fetching professores data:\", professoresError);\r\n  }\r\n\r\n  // Criar um mapa de professores por ID\r\n  const professoresMap = new Map(\r\n    (professores || []).map((professor) => [professor.id, professor]),\r\n  );\r\n\r\n  // Combinar agendamentos com dados dos professores\r\n  return agendamentos.map((item) => {\r\n    const professor = professoresMap.get(item.professor_id);\r\n    const professorData = professor\r\n      ? {\r\n          id: professor.id,\r\n          nome: professor.nome_completo || \"\",\r\n          email: professor.email || \"\",\r\n          avatar_url: professor.foto_url || undefined,\r\n        }\r\n      : undefined;\r\n\r\n    return {\r\n      ...item,\r\n      status: item.status as Agendamento[\"status\"],\r\n      lembrete_enviado: item.lembrete_enviado ?? undefined,\r\n      created_at: item.created_at ?? undefined,\r\n      updated_at: item.updated_at ?? undefined,\r\n      aluno: undefined,\r\n      professor: professorData,\r\n    };\r\n  });\r\n}\r\n\r\nexport async function getAgendamentoById(\r\n  id: string,\r\n): Promise<AgendamentoComDetalhes | null> {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\r\n      `\r\n      *,\r\n      aluno:alunos!agendamentos_aluno_id_fkey(\r\n        id, \r\n        nome_completo,\r\n        email\r\n      ),\r\n      professor:professores!agendamentos_professor_id_fkey(\r\n        id, \r\n        nome_completo,\r\n        email, \r\n        foto_url\r\n      )\r\n    `,\r\n    )\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching appointment:\", error);\r\n    return null;\r\n  }\r\n\r\n  if (!data) return null;\r\n\r\n  const aluno = isValidUserObject(data.aluno) ? data.aluno : undefined;\r\n  const professor = isValidUserObject(data.professor)\r\n    ? data.professor\r\n    : undefined;\r\n\r\n  return {\r\n    ...data,\r\n    status: data.status as Agendamento[\"status\"],\r\n    lembrete_enviado: data.lembrete_enviado ?? undefined,\r\n    created_at: data.created_at ?? undefined,\r\n    updated_at: data.updated_at ?? undefined,\r\n    aluno,\r\n    professor,\r\n  };\r\n}\r\n\r\n// =============================================\r\n// Appointment Status Management\r\n// =============================================\r\n\r\nexport async function confirmarAgendamento(id: string, linkReuniao?: string) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Get agendamento details for meeting link generation\r\n  const { data: agendamento } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\r\n      `\r\n      id,\r\n      data_inicio,\r\n      data_fim,\r\n      professor_id,\r\n      aluno_id,\r\n      aluno:alunos!agendamentos_aluno_id_fkey(nome, email)\r\n    `,\r\n    )\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!agendamento) {\r\n    throw new Error(\"Agendamento nao encontrado\");\r\n  }\r\n\r\n  // Verify that user is the professor of this appointment\r\n  if (agendamento.professor_id !== user.id) {\r\n    throw new Error(\"Apenas o professor pode confirmar este agendamento\");\r\n  }\r\n\r\n  let linkToUse = linkReuniao;\r\n\r\n  // If no explicit link provided, try to generate one or use default\r\n  if (!linkToUse) {\r\n    // Load professor configuration for default link\r\n    const config = await getConfiguracoesProfessor(user.id);\r\n\r\n    // Load professor integration settings\r\n    const { data: integration } = await supabase\r\n      // Next build estava falhando porque os tipos do Supabase não incluem essa tabela\r\n      // (provavelmente o `Database` gerado está desatualizado). Em runtime a tabela existe.\r\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n      .from(\"professor_integracoes\" as any)\r\n      .select(\"*\")\r\n      .eq(\"professor_id\", user.id)\r\n      .single();\r\n\r\n    // Try to generate meeting link if provider is configured\r\n    const validIntegration =\r\n      integration && !(\"code\" in integration)\r\n        ? (integration as unknown as { provider: string; access_token: string })\r\n        : null;\r\n    if (\r\n      validIntegration &&\r\n      validIntegration.provider !== \"default\" &&\r\n      validIntegration.access_token\r\n    ) {\r\n      try {\r\n        type AlunoData = {\r\n          nome: string;\r\n          email: string;\r\n        } | null;\r\n        // A tipagem do Supabase pode retornar SelectQueryError quando a relation não está no `Database` gerado.\r\n        // Em runtime, quando vem corretamente, é um objeto com { nome, email }.\r\n        const alunoRaw = agendamento.aluno as unknown;\r\n        const alunoData: AlunoData =\r\n          alunoRaw &&\r\n          typeof alunoRaw === \"object\" &&\r\n          !(\"code\" in (alunoRaw as Record<string, unknown>))\r\n            ? (alunoRaw as AlunoData)\r\n            : null;\r\n        const meetingLink = await generateMeetingLink(\r\n          validIntegration.provider as \"google\" | \"zoom\" | \"default\",\r\n          {\r\n            title: `Mentoria com ${alunoData?.nome || \"Aluno\"}`,\r\n            startTime: new Date(agendamento.data_inicio),\r\n            endTime: new Date(agendamento.data_fim),\r\n            description: \"Sessão de mentoria agendada via Aluminify\",\r\n            attendees: alunoData?.email ? [alunoData.email] : [],\r\n          },\r\n          {\r\n            accessToken: validIntegration.access_token,\r\n            defaultLink: config?.link_reuniao_padrao || undefined,\r\n          },\r\n        );\r\n\r\n        if (meetingLink) {\r\n          linkToUse = meetingLink.url;\r\n        }\r\n      } catch (error) {\r\n        console.error(\"Error generating meeting link:\", error);\r\n        // Fall back to default link if generation fails\r\n      }\r\n    }\r\n\r\n    // Use default link if no link was generated\r\n    if (!linkToUse && config?.link_reuniao_padrao) {\r\n      linkToUse = config.link_reuniao_padrao;\r\n    }\r\n  }\r\n\r\n  const updateData: Record<string, unknown> = {\r\n    status: \"confirmado\",\r\n    confirmado_em: new Date().toISOString(),\r\n  };\r\n\r\n  if (linkToUse) {\r\n    updateData.link_reuniao = linkToUse;\r\n  }\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .update(updateData)\r\n    .eq(\"id\", id)\r\n    .eq(\"professor_id\", user.id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error confirming appointment:\", error);\r\n    throw new Error(\"Failed to confirm appointment\");\r\n  }\r\n\r\n  // Notification is created by database trigger notify_agendamento_change()\r\n  // No need to create manually here to avoid duplicates\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/meus-agendamentos\");\r\n  return data;\r\n}\r\n\r\nexport async function rejeitarAgendamento(id: string, motivo: string) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership first for better error message\r\n  const { data: agendamento } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"professor_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!agendamento) {\r\n    throw new Error(\"Agendamento nao encontrado\");\r\n  }\r\n\r\n  if (agendamento.professor_id !== user.id) {\r\n    throw new Error(\"Apenas o professor pode rejeitar este agendamento\");\r\n  }\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .update({\r\n      status: \"cancelado\",\r\n      motivo_cancelamento: motivo,\r\n      cancelado_por: user.id,\r\n    })\r\n    .eq(\"id\", id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error rejecting appointment:\", error);\r\n    throw new Error(\"Falha ao rejeitar agendamento\");\r\n  }\r\n\r\n  // Notification is created by database trigger notify_agendamento_change()\r\n  // No need to create manually here to avoid duplicates\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/meus-agendamentos\");\r\n  return data;\r\n}\r\n\r\nexport async function cancelAgendamentoWithReason(id: string, motivo?: string) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // First get the agendamento to validate cancellation and ownership\r\n  const { data: agendamento } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"professor_id, aluno_id, data_inicio, status\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!agendamento) {\r\n    throw new Error(\"Agendamento nao encontrado\");\r\n  }\r\n\r\n  // Verify ownership - user must be either aluno or professor of the appointment\r\n  const isOwner =\r\n    agendamento.aluno_id === user.id || agendamento.professor_id === user.id;\r\n  if (!isOwner) {\r\n    throw new Error(\"Voce nao tem permissao para cancelar este agendamento\");\r\n  }\r\n\r\n  // Validate cancellation timing (2 hours minimum)\r\n  const validationResult = validateCancellation(\r\n    new Date(agendamento.data_inicio),\r\n    2,\r\n  );\r\n  if (!validationResult.valid) {\r\n    throw new Error(\r\n      validationResult.error || \"Nao e possivel cancelar este agendamento\",\r\n    );\r\n  }\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .update({\r\n      status: \"cancelado\",\r\n      motivo_cancelamento: motivo || null,\r\n      cancelado_por: user.id,\r\n    })\r\n    .eq(\"id\", id);\r\n\r\n  if (error) {\r\n    console.error(\"Error cancelling appointment:\", error);\r\n    throw new Error(\"Falha ao cancelar agendamento\");\r\n  }\r\n\r\n  // Notification is created by database trigger notify_agendamento_change()\r\n  // No need to create manually here to avoid duplicates\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/meus-agendamentos\");\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\nexport async function updateAgendamento(\r\n  id: string,\r\n  data: Partial<Agendamento>,\r\n) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Remove fields that shouldn't be updated directly and convert dates to strings\r\n  const {\r\n    id: _id,\r\n    created_at: _created_at,\r\n    updated_at: _updated_at,\r\n    ...restData\r\n  } = data;\r\n  void _id;\r\n  void _created_at;\r\n  void _updated_at;\r\n\r\n  const updateData: Record<string, unknown> = { ...restData };\r\n  if (updateData.data_inicio instanceof Date) {\r\n    updateData.data_inicio = updateData.data_inicio.toISOString();\r\n  }\r\n  if (updateData.data_fim instanceof Date) {\r\n    updateData.data_fim = updateData.data_fim.toISOString();\r\n  }\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .update(updateData)\r\n    .eq(\"id\", id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error updating appointment:\", error);\r\n    throw new Error(\"Failed to update appointment\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/meus-agendamentos\");\r\n  return result;\r\n}\r\n\r\n// =============================================\r\n// Professor Configuration Functions\r\n// =============================================\r\n\r\nexport type ProfessorIntegracao = {\r\n  id?: string;\r\n  professor_id?: string;\r\n  provider: \"google\" | \"zoom\" | \"default\";\r\n  access_token?: string | null;\r\n  refresh_token?: string | null;\r\n  token_expiry?: string | null;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport async function getConfiguracoesProfessor(\r\n  professorId: string,\r\n): Promise<ConfiguracoesProfessor | null> {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamento_configuracoes\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .single();\r\n\r\n  if (error && error.code !== \"PGRST116\") {\r\n    console.error(\"Error fetching professor config:\", error);\r\n    return null;\r\n  }\r\n\r\n  // Return defaults if no config exists\r\n  if (!data) {\r\n    return {\r\n      professor_id: professorId,\r\n      auto_confirmar: false,\r\n      tempo_antecedencia_minimo: 60,\r\n      tempo_lembrete_minutos: 1440,\r\n      link_reuniao_padrao: null,\r\n      mensagem_confirmacao: null,\r\n    };\r\n  }\r\n\r\n  // Map database data to ensure non-nullable fields have defaults\r\n  return {\r\n    id: data.id,\r\n    professor_id: data.professor_id,\r\n    auto_confirmar: data.auto_confirmar ?? false,\r\n    tempo_antecedencia_minimo: data.tempo_antecedencia_minimo ?? 60,\r\n    tempo_lembrete_minutos: data.tempo_lembrete_minutos ?? 1440,\r\n    link_reuniao_padrao: data.link_reuniao_padrao,\r\n    mensagem_confirmacao: data.mensagem_confirmacao,\r\n    created_at: data.created_at ?? undefined,\r\n    updated_at: data.updated_at ?? undefined,\r\n  };\r\n}\r\n\r\nexport async function updateConfiguracoesProfessor(\r\n  professorId: string,\r\n  config: Partial<ConfiguracoesProfessor>,\r\n) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user || user.id !== professorId) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const {\r\n    id: _id,\r\n    created_at: _created_at,\r\n    updated_at: _updated_at,\r\n    ...configData\r\n  } = config;\r\n  void _id;\r\n  void _created_at;\r\n  void _updated_at;\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamento_configuracoes\")\r\n    .upsert({\r\n      ...configData,\r\n      professor_id: professorId,\r\n    } as Database[\"public\"][\"Tables\"][\"agendamento_configuracoes\"][\"Insert\"])\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error updating professor config:\", error);\r\n    throw new Error(\"Failed to update configuration\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/configuracoes\");\r\n  return data;\r\n}\r\n\r\nexport async function getIntegracaoProfessor(\r\n  professorId: string,\r\n): Promise<ProfessorIntegracao | null> {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    // Tipos do Supabase podem estar desatualizados e não conter essa tabela\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    .from(\"professor_integracoes\" as any)\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .single();\r\n\r\n  if (error && error.code !== \"PGRST116\") {\r\n    console.error(\"Error fetching professor integration:\", error);\r\n    return null;\r\n  }\r\n\r\n  // Return defaults if no integration exists\r\n  if (!data) {\r\n    return {\r\n      professor_id: professorId,\r\n      provider: \"default\",\r\n      access_token: null,\r\n      refresh_token: null,\r\n      token_expiry: null,\r\n    };\r\n  }\r\n\r\n  // Map database data to ProfessorIntegracao type\r\n  // Table not in generated schema, using local type definition\r\n  const row = data as unknown as DbProfessorIntegracao;\r\n  return {\r\n    id: row.id,\r\n    professor_id: row.professor_id,\r\n    provider: row.provider,\r\n    access_token: row.access_token,\r\n    refresh_token: row.refresh_token,\r\n    token_expiry: row.token_expiry,\r\n    created_at: row.created_at ?? undefined,\r\n    updated_at: row.updated_at ?? undefined,\r\n  };\r\n}\r\n\r\nexport async function updateIntegracaoProfessor(\r\n  professorId: string,\r\n  integration: Partial<ProfessorIntegracao>,\r\n) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user || user.id !== professorId) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const {\r\n    id: _id,\r\n    created_at: _created_at,\r\n    updated_at: _updated_at,\r\n    ...integrationData\r\n  } = integration;\r\n  void _id;\r\n  void _created_at;\r\n  void _updated_at;\r\n\r\n  const { data, error } = await supabase\r\n    // Tipos do Supabase podem estar desatualizados e não conter essa tabela\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    .from(\"professor_integracoes\" as any)\r\n    .upsert({\r\n      ...integrationData,\r\n      professor_id: professorId,\r\n      provider: integrationData.provider || \"default\",\r\n    })\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error updating professor integration:\", error);\r\n    throw new Error(\"Failed to update integration\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/configuracoes\");\r\n  return data;\r\n}\r\n\r\n// =============================================\r\n// Shared Calendar Functions\r\n// =============================================\r\n\r\nexport async function getProfessoresDisponibilidade(\r\n  empresaId: string,\r\n  date: Date,\r\n) {\r\n  const supabase = await createClient();\r\n  const dateStr = date.toISOString().split(\"T\")[0];\r\n  const dayOfWeek = date.getUTCDay();\r\n\r\n  // Get all professors from the company\r\n  const { data: professores } = await supabase\r\n    .from(\"professores\")\r\n    .select(\"id, nome_completo, foto_url\")\r\n    .eq(\"empresa_id\", empresaId);\r\n\r\n  if (!professores || professores.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const professorIds = professores.map((p) => p.id);\r\n\r\n  // Get availability patterns for all professors\r\n  const { data: recorrencias } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .in(\"professor_id\", professorIds)\r\n    .eq(\"dia_semana\", dayOfWeek)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", dateStr)\r\n    .or(`data_fim.is.null,data_fim.gte.${dateStr}`);\r\n\r\n  // Get bloqueios for all professors\r\n  const startOfDay = new Date(date);\r\n  startOfDay.setUTCHours(0, 0, 0, 0);\r\n  const endOfDay = new Date(date);\r\n  endOfDay.setUTCHours(23, 59, 59, 999);\r\n\r\n  const { data: bloqueios } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"professor_id, data_inicio, data_fim\")\r\n    .eq(\"empresa_id\", empresaId)\r\n    .or(`professor_id.is.null,professor_id.in.(${professorIds.join(\",\")})`)\r\n    .lte(\"data_inicio\", endOfDay.toISOString())\r\n    .gte(\"data_fim\", startOfDay.toISOString());\r\n\r\n  // Get existing appointments (reuse startOfDay and endOfDay from above)\r\n\r\n  const { data: agendamentos } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"professor_id, data_inicio, data_fim\")\r\n    .in(\"professor_id\", professorIds)\r\n    .gte(\"data_inicio\", startOfDay.toISOString())\r\n    .lte(\"data_fim\", endOfDay.toISOString())\r\n    .neq(\"status\", \"cancelado\");\r\n\r\n  // Build result for each professor\r\n  const result = professores.map((professor) => {\r\n    const profRecorrencias = (\r\n      (recorrencias || []) as DbAgendamentoRecorrencia[]\r\n    ).filter((r) => r.professor_id === professor.id);\r\n    const profBloqueios = ((bloqueios || []) as DbAgendamentoBloqueio[]).filter(\r\n      (b) => !b.professor_id || b.professor_id === professor.id,\r\n    );\r\n    type AgendamentoRow = {\r\n      professor_id: string;\r\n      data_inicio: string;\r\n      data_fim: string;\r\n    };\r\n    const profAgendamentos = ((agendamentos || []) as AgendamentoRow[]).filter(\r\n      (a) => a.professor_id === professor.id,\r\n    );\r\n\r\n    // Generate available slots for this professor\r\n    const rules = profRecorrencias.map((r) => ({\r\n      dia_semana: r.dia_semana,\r\n      hora_inicio: r.hora_inicio,\r\n      hora_fim: r.hora_fim,\r\n      ativo: r.ativo,\r\n    }));\r\n\r\n    const existingSlots = profAgendamentos.map((a) => ({\r\n      start: new Date(a.data_inicio),\r\n      end: new Date(a.data_fim),\r\n    }));\r\n\r\n    const blockedSlots = profBloqueios.map((b) => ({\r\n      start: new Date(b.data_inicio),\r\n      end: new Date(b.data_fim),\r\n    }));\r\n\r\n    const allBlockedSlots = [...existingSlots, ...blockedSlots];\r\n\r\n    const slotDuration = profRecorrencias[0]?.duracao_slot_minutos || 30;\r\n\r\n    const slots = generateAvailableSlots(\r\n      date,\r\n      rules,\r\n      allBlockedSlots,\r\n      slotDuration,\r\n      60, // min advance\r\n    );\r\n\r\n    return {\r\n      professor_id: professor.id,\r\n      nome: professor.nome_completo,\r\n      foto: professor.foto_url,\r\n      slots_disponiveis: slots.map((s) => s.toISOString()),\r\n    };\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\nexport async function getAgendamentosEmpresa(\r\n  empresaId: string,\r\n  dateStart: Date,\r\n  dateEnd: Date,\r\n) {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    // View pode não estar presente no `Database` gerado\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    .from(\"v_agendamentos_empresa\" as any)\r\n    .select(\"*\")\r\n    .eq(\"empresa_id\", empresaId)\r\n    .gte(\"data_inicio\", dateStart.toISOString())\r\n    .lte(\"data_fim\", dateEnd.toISOString())\r\n    .order(\"data_inicio\", { ascending: true });\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching company appointments:\", error);\r\n    return [];\r\n  }\r\n\r\n  return ((data || []) as unknown as VAgendamentosEmpresa[]).map((item) => ({\r\n    id: item.id,\r\n    professor_id: item.professor_id,\r\n    professor_nome: item.professor_nome,\r\n    professor_foto: item.professor_foto as string | undefined,\r\n    aluno_nome: item.aluno_nome,\r\n    aluno_email: item.aluno_email as string | undefined,\r\n    data_inicio: item.data_inicio,\r\n    data_fim: item.data_fim,\r\n    status: item.status as Agendamento[\"status\"],\r\n    link_reuniao: item.link_reuniao,\r\n    observacoes: item.observacoes,\r\n    created_at: item.created_at,\r\n    updated_at: item.updated_at,\r\n  }));\r\n}\r\n\r\n// =============================================\r\n// Availability Management\r\n// =============================================\r\n\r\nexport async function deleteDisponibilidade(id: string) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamento_disponibilidade\")\r\n    .delete()\r\n    .eq(\"id\", id)\r\n    .eq(\"professor_id\", user.id);\r\n\r\n  if (error) {\r\n    console.error(\"Error deleting availability:\", error);\r\n    throw new Error(\"Failed to delete availability\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/disponibilidade\");\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\nexport async function bulkUpsertDisponibilidade(items: Disponibilidade[]) {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const payload = items.map((item) => ({\r\n    ...item,\r\n    professor_id: user.id,\r\n  }));\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamento_disponibilidade\")\r\n    .upsert(\r\n      payload as Database[\"public\"][\"Tables\"][\"agendamento_disponibilidade\"][\"Insert\"][],\r\n    );\r\n\r\n  if (error) {\r\n    console.error(\"Error bulk upserting availability:\", error);\r\n    throw new Error(\"Failed to update availability\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/disponibilidade\");\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\n// =============================================\r\n// Recorrência Management\r\n// =============================================\r\n\r\nexport async function getRecorrencias(\r\n  professorId: string,\r\n): Promise<Recorrencia[]> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user || user.id !== professorId) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .order(\"dia_semana\", { ascending: true })\r\n    .order(\"hora_inicio\", { ascending: true });\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching recorrencias:\", error);\r\n    throw new Error(\"Failed to fetch recorrencias\");\r\n  }\r\n\r\n  type RecorrenciaRow = DbAgendamentoRecorrencia & {\r\n    empresa_id: string;\r\n    tipo_servico: \"plantao\" | \"mentoria\";\r\n    created_at?: string | null;\r\n    updated_at?: string | null;\r\n  };\r\n  return ((data || []) as unknown as RecorrenciaRow[]).map((item) => ({\r\n    id: item.id,\r\n    professor_id: item.professor_id,\r\n    empresa_id: item.empresa_id,\r\n    tipo_servico: item.tipo_servico as \"plantao\" | \"mentoria\",\r\n    data_inicio: item.data_inicio,\r\n    data_fim: item.data_fim,\r\n    dia_semana: item.dia_semana,\r\n    hora_inicio: item.hora_inicio,\r\n    hora_fim: item.hora_fim,\r\n    duracao_slot_minutos: item.duracao_slot_minutos as number,\r\n    ativo: item.ativo,\r\n    created_at: item.created_at ?? undefined,\r\n    updated_at: item.updated_at ?? undefined,\r\n  }));\r\n}\r\n\r\nexport async function createRecorrencia(\r\n  data: Omit<Recorrencia, \"id\" | \"created_at\" | \"updated_at\">,\r\n): Promise<Recorrencia> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user || user.id !== data.professor_id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const payload = {\r\n    professor_id: data.professor_id,\r\n    empresa_id: data.empresa_id,\r\n    tipo_servico: data.tipo_servico,\r\n    data_inicio: data.data_inicio,\r\n    data_fim: data.data_fim || null,\r\n    dia_semana: data.dia_semana,\r\n    hora_inicio: data.hora_inicio,\r\n    hora_fim: data.hora_fim,\r\n    duracao_slot_minutos: data.duracao_slot_minutos,\r\n    ativo: data.ativo ?? true,\r\n  };\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .insert(\r\n      payload as Database[\"public\"][\"Tables\"][\"agendamento_recorrencia\"][\"Insert\"],\r\n    )\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error creating recorrencia:\", error);\r\n    throw new Error(\"Failed to create recorrencia\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/disponibilidade\");\r\n  revalidatePath(\"/agendamentos\");\r\n\r\n  type RecorrenciaRow = DbAgendamentoRecorrencia & {\r\n    empresa_id: string;\r\n    tipo_servico: \"plantao\" | \"mentoria\";\r\n    created_at?: string | null;\r\n    updated_at?: string | null;\r\n  };\r\n  const typedResult = result as unknown as RecorrenciaRow;\r\n  return {\r\n    id: typedResult.id,\r\n    professor_id: typedResult.professor_id,\r\n    empresa_id: typedResult.empresa_id,\r\n    tipo_servico: typedResult.tipo_servico as \"plantao\" | \"mentoria\",\r\n    data_inicio: typedResult.data_inicio,\r\n    data_fim: typedResult.data_fim,\r\n    dia_semana: typedResult.dia_semana,\r\n    hora_inicio: typedResult.hora_inicio,\r\n    hora_fim: typedResult.hora_fim,\r\n    duracao_slot_minutos: typedResult.duracao_slot_minutos as number,\r\n    ativo: typedResult.ativo,\r\n    created_at: typedResult.created_at ?? undefined,\r\n    updated_at: typedResult.updated_at ?? undefined,\r\n  };\r\n}\r\n\r\nexport async function updateRecorrencia(\r\n  id: string,\r\n  data: Partial<\r\n    Omit<\r\n      Recorrencia,\r\n      \"id\" | \"professor_id\" | \"empresa_id\" | \"created_at\" | \"updated_at\"\r\n    >\r\n  >,\r\n): Promise<Recorrencia> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership\r\n  const { data: existing } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"professor_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!existing || existing.professor_id !== user.id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const updateData: Record<string, unknown> = {};\r\n  if (data.tipo_servico !== undefined)\r\n    updateData.tipo_servico = data.tipo_servico;\r\n  if (data.data_inicio !== undefined) updateData.data_inicio = data.data_inicio;\r\n  if (data.data_fim !== undefined) updateData.data_fim = data.data_fim;\r\n  if (data.dia_semana !== undefined) updateData.dia_semana = data.dia_semana;\r\n  if (data.hora_inicio !== undefined) updateData.hora_inicio = data.hora_inicio;\r\n  if (data.hora_fim !== undefined) updateData.hora_fim = data.hora_fim;\r\n  if (data.duracao_slot_minutos !== undefined)\r\n    updateData.duracao_slot_minutos = data.duracao_slot_minutos;\r\n  if (data.ativo !== undefined) updateData.ativo = data.ativo;\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .update(updateData)\r\n    .eq(\"id\", id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error updating recorrencia:\", error);\r\n    throw new Error(\"Failed to update recorrencia\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/disponibilidade\");\r\n  revalidatePath(\"/agendamentos\");\r\n\r\n  type RecorrenciaRow = DbAgendamentoRecorrencia & {\r\n    empresa_id: string;\r\n    tipo_servico: \"plantao\" | \"mentoria\";\r\n    created_at?: string | null;\r\n    updated_at?: string | null;\r\n  };\r\n  const typedResult = result as unknown as RecorrenciaRow;\r\n  return {\r\n    id: typedResult.id,\r\n    professor_id: typedResult.professor_id,\r\n    empresa_id: typedResult.empresa_id,\r\n    tipo_servico: typedResult.tipo_servico,\r\n    data_inicio: typedResult.data_inicio,\r\n    data_fim: typedResult.data_fim,\r\n    dia_semana: typedResult.dia_semana,\r\n    hora_inicio: typedResult.hora_inicio,\r\n    hora_fim: typedResult.hora_fim,\r\n    duracao_slot_minutos: typedResult.duracao_slot_minutos as number,\r\n    ativo: typedResult.ativo,\r\n    created_at: typedResult.created_at ?? undefined,\r\n    updated_at: typedResult.updated_at ?? undefined,\r\n  };\r\n}\r\n\r\nexport async function deleteRecorrencia(\r\n  id: string,\r\n): Promise<{ success: boolean }> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership\r\n  const { data: existing } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"professor_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!existing || existing.professor_id !== user.id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .delete()\r\n    .eq(\"id\", id);\r\n\r\n  if (error) {\r\n    console.error(\"Error deleting recorrencia:\", error);\r\n    throw new Error(\"Failed to delete recorrencia\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/disponibilidade\");\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\n// =============================================\r\n// Bloqueios Management\r\n// =============================================\r\n\r\nexport async function getBloqueios(\r\n  professorId?: string,\r\n  empresaId?: string,\r\n): Promise<Bloqueio[]> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  let query = supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"*\")\r\n    .order(\"data_inicio\", { ascending: true });\r\n\r\n  if (empresaId) {\r\n    query = query.eq(\"empresa_id\", empresaId);\r\n  }\r\n\r\n  if (professorId) {\r\n    query = query.or(`professor_id.is.null,professor_id.eq.${professorId}`);\r\n  }\r\n\r\n  const { data, error } = await query;\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching bloqueios:\", error);\r\n    throw new Error(\"Failed to fetch bloqueios\");\r\n  }\r\n\r\n  return (data || []).map((item) => ({\r\n    id: item.id,\r\n    professor_id: item.professor_id,\r\n    empresa_id: item.empresa_id,\r\n    tipo: item.tipo as \"feriado\" | \"recesso\" | \"imprevisto\" | \"outro\",\r\n    data_inicio: item.data_inicio,\r\n    data_fim: item.data_fim,\r\n    motivo: item.motivo,\r\n    criado_por: item.criado_por,\r\n    created_at: item.created_at,\r\n    updated_at: item.updated_at,\r\n  }));\r\n}\r\n\r\nexport async function createBloqueio(\r\n  data: Omit<Bloqueio, \"id\" | \"created_at\" | \"updated_at\">,\r\n): Promise<Bloqueio> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify user has permission (professor_id must be null or match user.id)\r\n  if (data.professor_id && data.professor_id !== user.id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const dataInicio =\r\n    typeof data.data_inicio === \"string\"\r\n      ? data.data_inicio\r\n      : data.data_inicio.toISOString();\r\n  const dataFim =\r\n    typeof data.data_fim === \"string\"\r\n      ? data.data_fim\r\n      : data.data_fim.toISOString();\r\n\r\n  const payload = {\r\n    professor_id: data.professor_id || null,\r\n    empresa_id: data.empresa_id,\r\n    tipo: data.tipo,\r\n    data_inicio: dataInicio,\r\n    data_fim: dataFim,\r\n    motivo: data.motivo || null,\r\n    criado_por: user.id,\r\n  };\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .insert(payload as any)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error creating bloqueio:\", error);\r\n    throw new Error(\"Failed to create bloqueio\");\r\n  }\r\n\r\n  // If blocking affects existing appointments, cancel them\r\n  // Proper range overlap check: appointment starts before bloqueio ends AND appointment ends after bloqueio starts\r\n  // This catches all overlap cases: partial start, partial end, full containment, exact match\r\n  if (result.professor_id) {\r\n    const { error: cancelError } = await supabase\r\n      .from(\"agendamentos\")\r\n      .update({\r\n        status: \"cancelado\",\r\n        motivo_cancelamento: `Bloqueio de agenda: ${data.motivo || \"Sem motivo especificado\"}`,\r\n      })\r\n      .eq(\"professor_id\", result.professor_id)\r\n      .in(\"status\", [\"pendente\", \"confirmado\"])\r\n      .lt(\"data_inicio\", dataFim) // Appointment starts before bloqueio ends\r\n      .gt(\"data_fim\", dataInicio); // Appointment ends after bloqueio starts\r\n\r\n    if (cancelError) {\r\n      console.error(\"Error cancelling affected appointments:\", cancelError);\r\n    }\r\n  } else {\r\n    // Company-wide bloqueio - cancel all affected appointments\r\n    const { data: professores } = await supabase\r\n      .from(\"professores\")\r\n      .select(\"id\")\r\n      .eq(\"empresa_id\", data.empresa_id);\r\n\r\n    if (professores && professores.length > 0) {\r\n      const professorIds = professores.map((p) => p.id);\r\n      const { error: cancelError } = await supabase\r\n        .from(\"agendamentos\")\r\n        .update({\r\n          status: \"cancelado\",\r\n          motivo_cancelamento: `Bloqueio de agenda: ${data.motivo || \"Sem motivo especificado\"}`,\r\n        })\r\n        .in(\"professor_id\", professorIds)\r\n        .in(\"status\", [\"pendente\", \"confirmado\"])\r\n        .lt(\"data_inicio\", dataFim) // Appointment starts before bloqueio ends\r\n        .gt(\"data_fim\", dataInicio); // Appointment ends after bloqueio starts\r\n\r\n      if (cancelError) {\r\n        console.error(\"Error cancelling affected appointments:\", cancelError);\r\n      }\r\n    }\r\n  }\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/agendamentos\");\r\n\r\n  return {\r\n    id: result.id,\r\n    professor_id: result.professor_id,\r\n    empresa_id: result.empresa_id,\r\n    tipo: result.tipo as \"feriado\" | \"recesso\" | \"imprevisto\" | \"outro\",\r\n    data_inicio: result.data_inicio,\r\n    data_fim: result.data_fim,\r\n    motivo: result.motivo,\r\n    criado_por: result.criado_por,\r\n    created_at: result.created_at,\r\n    updated_at: result.updated_at,\r\n  };\r\n}\r\n\r\nexport async function updateBloqueio(\r\n  id: string,\r\n  data: Partial<\r\n    Omit<\r\n      Bloqueio,\r\n      \"id\" | \"empresa_id\" | \"criado_por\" | \"created_at\" | \"updated_at\"\r\n    >\r\n  >,\r\n): Promise<Bloqueio> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership\r\n  const { data: existing } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"professor_id, empresa_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!existing) {\r\n    throw new Error(\"Bloqueio not found\");\r\n  }\r\n\r\n  // User must own the bloqueio (professor_id matches) or be admin updating company bloqueio\r\n  if (existing.professor_id && existing.professor_id !== user.id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const updateData: Record<string, unknown> = {};\r\n  if (data.professor_id !== undefined)\r\n    updateData.professor_id = data.professor_id || null;\r\n  if (data.tipo !== undefined) updateData.tipo = data.tipo;\r\n  if (data.data_inicio !== undefined) {\r\n    updateData.data_inicio =\r\n      typeof data.data_inicio === \"string\"\r\n        ? data.data_inicio\r\n        : data.data_inicio.toISOString();\r\n  }\r\n  if (data.data_fim !== undefined) {\r\n    updateData.data_fim =\r\n      typeof data.data_fim === \"string\"\r\n        ? data.data_fim\r\n        : data.data_fim.toISOString();\r\n  }\r\n  if (data.motivo !== undefined) updateData.motivo = data.motivo || null;\r\n\r\n  const { data: result, error } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .update(updateData)\r\n    .eq(\"id\", id)\r\n    .select()\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error updating bloqueio:\", error);\r\n    throw new Error(\"Failed to update bloqueio\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/agendamentos\");\r\n\r\n  return {\r\n    id: result.id,\r\n    professor_id: result.professor_id,\r\n    empresa_id: result.empresa_id,\r\n    tipo: result.tipo as \"feriado\" | \"recesso\" | \"imprevisto\" | \"outro\",\r\n    data_inicio: result.data_inicio,\r\n    data_fim: result.data_fim,\r\n    motivo: result.motivo,\r\n    criado_por: result.criado_por,\r\n    created_at: result.created_at,\r\n    updated_at: result.updated_at,\r\n  };\r\n}\r\n\r\nexport async function deleteBloqueio(\r\n  id: string,\r\n): Promise<{ success: boolean }> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Verify ownership\r\n  const { data: existing } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"professor_id\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (!existing) {\r\n    throw new Error(\"Bloqueio not found\");\r\n  }\r\n\r\n  if (existing.professor_id && existing.professor_id !== user.id) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  const { error } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .delete()\r\n    .eq(\"id\", id);\r\n\r\n  if (error) {\r\n    console.error(\"Error deleting bloqueio:\", error);\r\n    throw new Error(\"Failed to delete bloqueio\");\r\n  }\r\n\r\n  revalidatePath(\"/professor/agendamentos\");\r\n  revalidatePath(\"/agendamentos\");\r\n  return { success: true };\r\n}\r\n\r\n// =============================================\r\n// Conflict Detection & Validation\r\n// =============================================\r\n\r\nexport async function checkConflitos(\r\n  professorId: string,\r\n  dataInicio: Date,\r\n  dataFim: Date,\r\n): Promise<boolean> {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"id\")\r\n    .eq(\"professor_id\", professorId)\r\n    .neq(\"status\", \"cancelado\")\r\n    .or(\r\n      `and(data_inicio.lt.${dataFim.toISOString()},data_fim.gt.${dataInicio.toISOString()})`,\r\n    )\r\n    .limit(1);\r\n\r\n  if (error) {\r\n    console.error(\"Error checking conflicts:\", error);\r\n    return false;\r\n  }\r\n\r\n  return (data?.length || 0) > 0;\r\n}\r\n\r\nexport async function validateAgendamento(\r\n  professorId: string,\r\n  dataInicio: Date,\r\n  dataFim: Date,\r\n): Promise<{ valid: boolean; error?: string }> {\r\n  const supabase = await createClient();\r\n\r\n  // Check minimum advance time\r\n  const config = await getConfiguracoesProfessor(professorId);\r\n  const minAdvanceMinutes = config?.tempo_antecedencia_minimo || 60;\r\n  const now = new Date();\r\n  const minAllowedTime = new Date(\r\n    now.getTime() + minAdvanceMinutes * 60 * 1000,\r\n  );\r\n\r\n  if (dataInicio < minAllowedTime) {\r\n    return {\r\n      valid: false,\r\n      error: `O agendamento deve ser feito com pelo menos ${minAdvanceMinutes} minutos de antecedência.`,\r\n    };\r\n  }\r\n\r\n  // Check for conflicts\r\n  const hasConflict = await checkConflitos(professorId, dataInicio, dataFim);\r\n  if (hasConflict) {\r\n    return {\r\n      valid: false,\r\n      error: \"Já existe um agendamento neste horário.\",\r\n    };\r\n  }\r\n\r\n  // Check if within availability (using agendamento_recorrencia table)\r\n  const dayOfWeek = dataInicio.getUTCDay();\r\n  const dateStr = dataInicio.toISOString().split(\"T\")[0];\r\n\r\n  const { data: recorrencias } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"*\")\r\n    .eq(\"professor_id\", professorId)\r\n    .eq(\"dia_semana\", dayOfWeek)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", dateStr)\r\n    .or(`data_fim.is.null,data_fim.gte.${dateStr}`);\r\n\r\n  if (!recorrencias || recorrencias.length === 0) {\r\n    return {\r\n      valid: false,\r\n      error: \"O professor nao tem disponibilidade neste dia.\",\r\n    };\r\n  }\r\n\r\n  const timeToMinutes = (timeStr: string) => {\r\n    const [h, m] = timeStr.split(\":\").map(Number);\r\n    return h * 60 + m;\r\n  };\r\n\r\n  const startMinutes =\r\n    dataInicio.getUTCHours() * 60 + dataInicio.getUTCMinutes();\r\n  const endMinutes = dataFim.getUTCHours() * 60 + dataFim.getUTCMinutes();\r\n\r\n  const isWithinAvailability = recorrencias.some((rec) => {\r\n    const ruleStart = timeToMinutes(rec.hora_inicio);\r\n    const ruleEnd = timeToMinutes(rec.hora_fim);\r\n    return startMinutes >= ruleStart && endMinutes <= ruleEnd;\r\n  });\r\n\r\n  if (!isWithinAvailability) {\r\n    return {\r\n      valid: false,\r\n      error: \"O horario selecionado esta fora da disponibilidade do professor.\",\r\n    };\r\n  }\r\n\r\n  // Check for bloqueios\r\n  const { data: bloqueios } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"id\")\r\n    .or(`professor_id.is.null,professor_id.eq.${professorId}`)\r\n    .lt(\"data_inicio\", dataFim.toISOString())\r\n    .gt(\"data_fim\", dataInicio.toISOString())\r\n    .limit(1);\r\n\r\n  if (bloqueios && bloqueios.length > 0) {\r\n    return {\r\n      valid: false,\r\n      error: \"O horario selecionado esta bloqueado pelo professor.\",\r\n    };\r\n  }\r\n\r\n  return { valid: true };\r\n}\r\n\r\n// Note: Notifications are now handled by database trigger notify_agendamento_change()\r\n// The manual _createNotificacao function was removed to avoid duplicates\r\n\r\n// =============================================\r\n// Reports Functions\r\n// =============================================\r\n\r\nexport type RelatorioTipo = \"mensal\" | \"semanal\" | \"customizado\";\r\n\r\nexport type RelatorioDados = {\r\n  total_agendamentos: number;\r\n  por_status: {\r\n    confirmado: number;\r\n    cancelado: number;\r\n    concluido: number;\r\n    pendente: number;\r\n  };\r\n  por_professor: Array<{\r\n    professor_id: string;\r\n    nome: string;\r\n    total: number;\r\n    taxa_comparecimento: number;\r\n  }>;\r\n  taxa_ocupacao: number;\r\n  horarios_pico: string[];\r\n  taxa_nao_comparecimento: number;\r\n};\r\n\r\nexport type Relatorio = {\r\n  id: string;\r\n  empresa_id: string;\r\n  periodo_inicio: string;\r\n  periodo_fim: string;\r\n  tipo: RelatorioTipo;\r\n  dados_json: RelatorioDados;\r\n  gerado_em: string;\r\n  gerado_por: string;\r\n  created_at?: string;\r\n  updated_at?: string;\r\n};\r\n\r\nexport async function gerarRelatorio(\r\n  empresaId: string,\r\n  dataInicio: Date,\r\n  dataFim: Date,\r\n  tipo: RelatorioTipo,\r\n): Promise<Relatorio> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // Call Edge Function to generate report\r\n  const { data, error } = await supabase.functions.invoke(\r\n    \"gerar-relatorio-agendamentos\",\r\n    {\r\n      body: {\r\n        empresa_id: empresaId,\r\n        data_inicio: dataInicio.toISOString().split(\"T\")[0],\r\n        data_fim: dataFim.toISOString().split(\"T\")[0],\r\n        tipo,\r\n      },\r\n    },\r\n  );\r\n\r\n  if (error) {\r\n    console.error(\"Error generating report:\", error);\r\n    throw new Error(\"Failed to generate report\");\r\n  }\r\n\r\n  return data.relatorio;\r\n}\r\n\r\nexport async function getRelatorios(\r\n  empresaId: string,\r\n  limit?: number,\r\n): Promise<Relatorio[]> {\r\n  const supabase = await createClient();\r\n\r\n  let query = supabase\r\n    // Tipos do Supabase podem estar desatualizados e não conter essa tabela\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    .from(\"agendamento_relatorios\" as any)\r\n    .select(\"*\")\r\n    .eq(\"empresa_id\", empresaId)\r\n    .order(\"gerado_em\", { ascending: false });\r\n\r\n  if (limit) {\r\n    query = query.limit(limit);\r\n  }\r\n\r\n  const { data, error } = await query;\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching reports:\", error);\r\n    return [];\r\n  }\r\n\r\n  // Table not in generated schema, using local type definition\r\n  const rows = (data || []) as unknown as DbAgendamentoRelatorio[];\r\n  return rows.map((item) => ({\r\n    id: item.id,\r\n    empresa_id: item.empresa_id,\r\n    periodo_inicio: item.periodo_inicio,\r\n    periodo_fim: item.periodo_fim,\r\n    tipo: item.tipo as RelatorioTipo,\r\n    dados_json: item.dados_json as RelatorioDados,\r\n    gerado_em: item.gerado_em,\r\n    gerado_por: item.gerado_por,\r\n    created_at: item.created_at ?? undefined,\r\n    updated_at: item.updated_at ?? undefined,\r\n  }));\r\n}\r\n\r\nexport async function getRelatorioById(id: string): Promise<Relatorio | null> {\r\n  const supabase = await createClient();\r\n\r\n  const { data, error } = await supabase\r\n    // Tipos do Supabase podem estar desatualizados e não conter essa tabela\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    .from(\"agendamento_relatorios\" as any)\r\n    .select(\"*\")\r\n    .eq(\"id\", id)\r\n    .single();\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching report:\", error);\r\n    return null;\r\n  }\r\n\r\n  if (!data) return null;\r\n\r\n  // Table not in generated schema, using local type definition\r\n  const row = data as unknown as DbAgendamentoRelatorio;\r\n  return {\r\n    id: row.id,\r\n    empresa_id: row.empresa_id,\r\n    periodo_inicio: row.periodo_inicio,\r\n    periodo_fim: row.periodo_fim,\r\n    tipo: row.tipo as RelatorioTipo,\r\n    dados_json: row.dados_json as RelatorioDados,\r\n    gerado_em: row.gerado_em,\r\n    gerado_por: row.gerado_por,\r\n    created_at: row.created_at ?? undefined,\r\n    updated_at: row.updated_at ?? undefined,\r\n  };\r\n}\r\n\r\n// =============================================\r\n// Statistics\r\n// =============================================\r\n\r\nexport async function getAgendamentoStats(professorId: string) {\r\n  const supabase = await createClient();\r\n\r\n  const now = new Date();\r\n  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\r\n  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);\r\n\r\n  const { data, error } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"status, data_inicio\")\r\n    .eq(\"professor_id\", professorId)\r\n    .gte(\"data_inicio\", startOfMonth.toISOString())\r\n    .lte(\"data_inicio\", endOfMonth.toISOString());\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching stats:\", error);\r\n    return {\r\n      total: 0,\r\n      pendentes: 0,\r\n      confirmados: 0,\r\n      cancelados: 0,\r\n      concluidos: 0,\r\n    };\r\n  }\r\n\r\n  const stats = {\r\n    total: data?.length || 0,\r\n    pendentes: data?.filter((a) => a.status === \"pendente\").length || 0,\r\n    confirmados: data?.filter((a) => a.status === \"confirmado\").length || 0,\r\n    cancelados: data?.filter((a) => a.status === \"cancelado\").length || 0,\r\n    concluidos: data?.filter((a) => a.status === \"concluido\").length || 0,\r\n  };\r\n\r\n  return stats;\r\n}\r\n\r\n// =============================================\r\n// Professor Selection Functions\r\n// =============================================\r\n\r\nexport type ProfessorDisponivel = {\r\n  id: string;\r\n  nome: string;\r\n  email: string;\r\n  foto_url?: string | null;\r\n  especialidade?: string | null;\r\n  bio?: string | null;\r\n  empresa_id: string;\r\n  proximos_slots: string[]; // ISO strings of next available slots\r\n  tem_disponibilidade: boolean;\r\n};\r\n\r\nexport async function getProfessoresDisponiveis(\r\n  empresaId?: string,\r\n): Promise<ProfessorDisponivel[]> {\r\n  const supabase = await createClient();\r\n  const {\r\n    data: { user },\r\n  } = await supabase.auth.getUser();\r\n\r\n  if (!user) {\r\n    throw new Error(\"Unauthorized\");\r\n  }\r\n\r\n  // If no empresaId provided, try to get from aluno's enrolled courses\r\n  let targetEmpresaId = empresaId;\r\n  if (!targetEmpresaId) {\r\n    const { data: alunoData } = await supabase\r\n      .from(\"alunos\")\r\n      .select(\"empresa_id\")\r\n      .eq(\"id\", user.id)\r\n      .single();\r\n\r\n    if (alunoData?.empresa_id) {\r\n      targetEmpresaId = alunoData.empresa_id;\r\n    } else {\r\n      // Try to get empresa from enrolled courses\r\n      const { data: cursosData } = await supabase\r\n        .from(\"alunos_cursos\")\r\n        .select(\"cursos(empresa_id)\")\r\n        .eq(\"aluno_id\", user.id)\r\n        .limit(1)\r\n        .single();\r\n\r\n      type CursoWithEmpresa = { cursos: { empresa_id: string } | null };\r\n      const cursoData = cursosData as unknown as CursoWithEmpresa;\r\n      if (cursoData?.cursos?.empresa_id) {\r\n        targetEmpresaId = cursoData.cursos.empresa_id;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!targetEmpresaId) {\r\n    console.warn(\"No empresa_id found for user\");\r\n    return [];\r\n  }\r\n\r\n  // Get all professors from the company\r\n  const { data: professores, error } = await supabase\r\n    .from(\"professores\")\r\n    .select(\r\n      \"id, nome_completo, email, foto_url, especialidade, biografia, empresa_id\",\r\n    )\r\n    .eq(\"empresa_id\", targetEmpresaId)\r\n    .order(\"nome_completo\", { ascending: true });\r\n\r\n  if (error) {\r\n    console.error(\"Error fetching professors:\", error);\r\n    return [];\r\n  }\r\n\r\n  if (!professores || professores.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const today = new Date();\r\n  const todayStr = today.toISOString().split(\"T\")[0];\r\n  const nextWeek = new Date(today);\r\n  nextWeek.setDate(nextWeek.getDate() + 7);\r\n  const nextWeekStr = nextWeek.toISOString().split(\"T\")[0];\r\n\r\n  // Get recorrencias for all professors\r\n  const professorIds = professores.map((p) => p.id);\r\n  const { data: recorrencias } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\r\n      \"professor_id, dia_semana, hora_inicio, hora_fim, duracao_slot_minutos, data_inicio, data_fim\",\r\n    )\r\n    .in(\"professor_id\", professorIds)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", nextWeekStr)\r\n    .or(`data_fim.is.null,data_fim.gte.${todayStr}`);\r\n\r\n  // Get existing appointments for next week\r\n  const { data: agendamentos } = await supabase\r\n    .from(\"agendamentos\")\r\n    .select(\"professor_id, data_inicio, data_fim\")\r\n    .in(\"professor_id\", professorIds)\r\n    .gte(\"data_inicio\", today.toISOString())\r\n    .lte(\"data_inicio\", nextWeek.toISOString())\r\n    .neq(\"status\", \"cancelado\");\r\n\r\n  // Get bloqueios for next week\r\n  const { data: bloqueios } = await supabase\r\n    .from(\"agendamento_bloqueios\")\r\n    .select(\"professor_id, data_inicio, data_fim\")\r\n    .eq(\"empresa_id\", targetEmpresaId)\r\n    .lte(\"data_inicio\", nextWeek.toISOString())\r\n    .gte(\"data_fim\", today.toISOString());\r\n\r\n  // Build result for each professor\r\n  const result: ProfessorDisponivel[] = professores.map((professor) => {\r\n    const profRecorrencias = (\r\n      (recorrencias || []) as DbAgendamentoRecorrencia[]\r\n    ).filter((r) => r.professor_id === professor.id);\r\n\r\n    const profAgendamentos = (agendamentos || [])\r\n      .filter((a) => a.professor_id === professor.id)\r\n      .map((a) => ({\r\n        start: new Date(a.data_inicio),\r\n        end: new Date(a.data_fim),\r\n      }));\r\n\r\n    const profBloqueios = ((bloqueios || []) as DbAgendamentoBloqueio[])\r\n      .filter((b) => !b.professor_id || b.professor_id === professor.id)\r\n      .map((b) => ({\r\n        start: new Date(b.data_inicio),\r\n        end: new Date(b.data_fim),\r\n      }));\r\n\r\n    const allBlockedSlots = [...profAgendamentos, ...profBloqueios];\r\n\r\n    // Find next available slots (up to 3)\r\n    const proximosSlots: string[] = [];\r\n    const checkDate = new Date(today);\r\n    let daysChecked = 0;\r\n\r\n    while (proximosSlots.length < 3 && daysChecked < 14) {\r\n      const dayOfWeek = checkDate.getUTCDay();\r\n      const dateStr = checkDate.toISOString().split(\"T\")[0];\r\n\r\n      const dayRules = profRecorrencias.filter(\r\n        (r) =>\r\n          r.dia_semana === dayOfWeek &&\r\n          r.data_inicio <= dateStr &&\r\n          (!r.data_fim || r.data_fim >= dateStr),\r\n      );\r\n\r\n      if (dayRules.length > 0) {\r\n        const rules = dayRules.map((r) => ({\r\n          dia_semana: r.dia_semana,\r\n          hora_inicio: r.hora_inicio,\r\n          hora_fim: r.hora_fim,\r\n          ativo: true,\r\n        }));\r\n\r\n        const slotDuration = dayRules[0]?.duracao_slot_minutos || 30;\r\n        const slots = generateAvailableSlots(\r\n          checkDate,\r\n          rules,\r\n          allBlockedSlots,\r\n          slotDuration,\r\n          60, // min advance\r\n        );\r\n\r\n        for (const slot of slots) {\r\n          if (proximosSlots.length < 3) {\r\n            proximosSlots.push(slot.toISOString());\r\n          }\r\n        }\r\n      }\r\n\r\n      checkDate.setDate(checkDate.getDate() + 1);\r\n      daysChecked++;\r\n    }\r\n\r\n    return {\r\n      id: professor.id,\r\n      nome: professor.nome_completo || \"\",\r\n      email: professor.email || \"\",\r\n      foto_url: professor.foto_url,\r\n      especialidade: professor.especialidade,\r\n      bio: professor.biografia,\r\n      empresa_id: professor.empresa_id,\r\n      proximos_slots: proximosSlots,\r\n      tem_disponibilidade: profRecorrencias.length > 0,\r\n    };\r\n  });\r\n\r\n  // Sort: professors with availability first, then by name\r\n  return result.sort((a, b) => {\r\n    if (a.tem_disponibilidade && !b.tem_disponibilidade) return -1;\r\n    if (!a.tem_disponibilidade && b.tem_disponibilidade) return 1;\r\n    if (a.proximos_slots.length > 0 && b.proximos_slots.length === 0) return -1;\r\n    if (a.proximos_slots.length === 0 && b.proximos_slots.length > 0) return 1;\r\n    return a.nome.localeCompare(b.nome);\r\n  });\r\n}\r\n\r\nexport async function getProfessorById(\r\n  professorId: string,\r\n): Promise<ProfessorDisponivel | null> {\r\n  const supabase = await createClient();\r\n\r\n  const { data: professor, error } = await supabase\r\n    .from(\"professores\")\r\n    .select(\r\n      \"id, nome_completo, email, foto_url, especialidade, biografia, empresa_id\",\r\n    )\r\n    .eq(\"id\", professorId)\r\n    .single();\r\n\r\n  if (error || !professor) {\r\n    console.error(\"Error fetching professor:\", error);\r\n    return null;\r\n  }\r\n\r\n  // Check if professor has any active recorrencias\r\n  const today = new Date();\r\n  const todayStr = today.toISOString().split(\"T\")[0];\r\n\r\n  const { data: recorrencias } = await supabase\r\n    .from(\"agendamento_recorrencia\")\r\n    .select(\"id\")\r\n    .eq(\"professor_id\", professorId)\r\n    .eq(\"ativo\", true)\r\n    .lte(\"data_inicio\", todayStr)\r\n    .or(`data_fim.is.null,data_fim.gte.${todayStr}`)\r\n    .limit(1);\r\n\r\n  return {\r\n    id: professor.id,\r\n    nome: professor.nome_completo || \"\",\r\n    email: professor.email || \"\",\r\n    foto_url: professor.foto_url,\r\n    especialidade: professor.especialidade,\r\n    bio: professor.biografia,\r\n    empresa_id: professor.empresa_id,\r\n    proximos_slots: [],\r\n    tem_disponibilidade: (recorrencias?.length || 0) > 0,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\atividade\\[id]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[398,401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[398,401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  atividadeService,\r\n  AtividadeNotFoundError,\r\n  AtividadeValidationError,\r\n} from '@/backend/services/atividade';\r\nimport { requireAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\n\r\nconst serializeAtividade = (\r\n  atividade: Awaited<ReturnType<typeof atividadeService.getById>>,\r\n) => {\r\n  const a = atividade as any; // Type assertion para contornar incompatibilidade de tipos\r\n  return {\r\n    id: a.id,\r\n    moduloId: a.moduloId || a.modulo_id,\r\n    tipo: a.tipo,\r\n    titulo: a.titulo,\r\n    arquivoUrl: a.arquivoUrl || a.arquivo_url,\r\n    gabaritoUrl: a.gabaritoUrl || a.gabarito_url,\r\n    linkExterno: a.linkExterno || a.link_externo,\r\n    obrigatorio: a.obrigatorio,\r\n    ordemExibicao: a.ordemExibicao || a.ordem_exibicao,\r\n    createdAt: a.createdAt?.toISOString?.() || a.created_at,\r\n    updatedAt: a.updatedAt?.toISOString?.() || a.updated_at,\r\n  };\r\n};\r\n\r\nfunction handleError(error: unknown) {\r\n  if (error instanceof AtividadeNotFoundError) {\r\n    return NextResponse.json({ error: error.message }, { status: 404 });\r\n  }\r\n\r\n  if (error instanceof AtividadeValidationError) {\r\n    return NextResponse.json({ error: error.message }, { status: 400 });\r\n  }\r\n\r\n  console.error(error);\r\n  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n}\r\n\r\ninterface RouteContext {\r\n  params: Promise<{ id: string }>;\r\n}\r\n\r\n// GET - Buscar atividade por ID\r\nexport async function GET(_request: NextRequest, context: RouteContext) {\r\n  try {\r\n    const params = await context.params;\r\n    const atividade = await atividadeService.getById(params.id);\r\n    return NextResponse.json({ data: serializeAtividade(atividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\n// PATCH - Atualizar atividade (especialmente arquivo_url após upload direto)\r\nasync function patchHandler(request: AuthenticatedRequest, params: { id: string }) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n\r\n    const atividade = await atividadeService.update(params.id, {\r\n      arquivoUrl: body?.arquivoUrl,\r\n      gabaritoUrl: body?.gabaritoUrl,\r\n      linkExterno: body?.linkExterno,\r\n      titulo: body?.titulo,\r\n      obrigatorio: body?.obrigatorio,\r\n      ordemExibicao: body?.ordemExibicao,\r\n    });\r\n\r\n    return NextResponse.json({ data: serializeAtividade(atividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport async function PATCH(request: NextRequest, context: RouteContext) {\r\n  const params = await context.params;\r\n  return requireAuth((req) => patchHandler(req, params))(request);\r\n}\r\n\r\nasync function deleteHandler(request: AuthenticatedRequest, params: { id: string }) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    await atividadeService.delete(params.id);\r\n    return NextResponse.json({ message: 'Atividade removida com sucesso' });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport async function DELETE(request: NextRequest, context: RouteContext) {\r\n  const params = await context.params;\r\n  return requireAuth((req) => deleteHandler(req, params))(request);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\atividade\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[371,374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[371,374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  atividadeService,\r\n  AtividadeValidationError,\r\n} from '@/backend/services/atividade';\r\nimport { requireAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\n\r\nconst serializeAtividade = (\r\n  atividade: Awaited<ReturnType<typeof atividadeService.getById>>,\r\n) => {\r\n  const a = atividade as any; // Type assertion para contornar incompatibilidade de tipos\r\n  return {\r\n    id: a.id,\r\n    moduloId: a.moduloId || a.modulo_id,\r\n    tipo: a.tipo,\r\n    titulo: a.titulo,\r\n    arquivoUrl: a.arquivoUrl || a.arquivo_url,\r\n    gabaritoUrl: a.gabaritoUrl || a.gabarito_url,\r\n    linkExterno: a.linkExterno || a.link_externo,\r\n    obrigatorio: a.obrigatorio,\r\n    ordemExibicao: a.ordemExibicao || a.ordem_exibicao,\r\n    createdAt: a.createdAt?.toISOString?.() || a.created_at,\r\n    updatedAt: a.updatedAt?.toISOString?.() || a.updated_at,\r\n  };\r\n};\r\n\r\nfunction handleError(error: unknown) {\r\n  if (error instanceof AtividadeValidationError) {\r\n    return NextResponse.json({ error: error.message }, { status: 400 });\r\n  }\r\n\r\n  console.error(error);\r\n  return NextResponse.json({ error: 'Internal server error' }, { status: 500 });\r\n}\r\n\r\n// GET - Listar atividades (filtro por modulo_id ou frente_id)\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const moduloId = searchParams.get('modulo_id');\r\n    const frenteId = searchParams.get('frente_id');\r\n\r\n    let atividades;\r\n\r\n    if (moduloId) {\r\n      atividades = await atividadeService.listByModulo(moduloId);\r\n    } else if (frenteId) {\r\n      atividades = await atividadeService.listByFrente(frenteId);\r\n    } else {\r\n      return NextResponse.json(\r\n        { error: 'modulo_id or frente_id query parameter is required' },\r\n        { status: 400 },\r\n      );\r\n    }\r\n\r\n    return NextResponse.json({ data: atividades.map(serializeAtividade) });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nasync function postHandler(request: AuthenticatedRequest) {\r\n  if (request.user && request.user.role !== 'professor' && request.user.role !== 'superadmin') {\r\n    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n    const atividade = await atividadeService.create({\r\n      moduloId: body?.modulo_id,\r\n      tipo: body?.tipo,\r\n      titulo: body?.titulo,\r\n      arquivoUrl: body?.arquivo_url,\r\n      gabaritoUrl: body?.gabarito_url,\r\n      linkExterno: body?.link_externo,\r\n      obrigatorio: body?.obrigatorio,\r\n      ordemExibicao: body?.ordem_exibicao,\r\n    });\r\n\r\n    return NextResponse.json({ data: serializeAtividade(atividade) }, { status: 201 });\r\n  } catch (error) {\r\n    return handleError(error);\r\n  }\r\n}\r\n\r\nexport const POST = requireAuth(postHandler);","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\auth\\professor\\signup\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2444,2447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2444,2447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from 'next/server';\r\nimport { getDatabaseClient } from '@/backend/clients/database';\r\n\r\n/**\r\n * POST /api/auth/professor/signup\r\n *\r\n * Cadastro público de professor SEM empresa (onboarding).\r\n * - Cria usuário no Supabase Auth via admin client\r\n * - Insere registro em `public.professores` com `empresa_id = null`\r\n * - Atualiza metadata com `role: 'professor'` (sem disparar trigger de insert)\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const email = String(body?.email ?? '').trim().toLowerCase();\r\n    const password = String(body?.password ?? '');\r\n    const fullName = String(body?.fullName ?? '').trim();\r\n\r\n    if (!email || !password || !fullName) {\r\n      return NextResponse.json(\r\n        { error: 'email, password e fullName são obrigatórios' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    if (password.length < 8) {\r\n      return NextResponse.json(\r\n        { error: 'A senha deve ter pelo menos 8 caracteres' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const adminClient = getDatabaseClient();\r\n\r\n    // 1) Criar usuário sem role no metadata para não exigir empresa_id no trigger de insert\r\n    const { data: createdUser, error: createUserError } = await adminClient.auth.admin.createUser({\r\n      email,\r\n      password,\r\n      email_confirm: true,\r\n      user_metadata: {\r\n        full_name: fullName,\r\n      },\r\n    });\r\n\r\n    if (createUserError || !createdUser.user) {\r\n      if (\r\n        createUserError?.message?.includes('already registered') ||\r\n        createUserError?.message?.includes('already exists') ||\r\n        createUserError?.status === 422\r\n      ) {\r\n        return NextResponse.json({ error: 'Este email já está cadastrado' }, { status: 400 });\r\n      }\r\n\r\n      return NextResponse.json(\r\n        { error: `Erro ao criar usuário: ${createUserError?.message || 'Erro desconhecido'}` },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    const userId = createdUser.user.id;\r\n\r\n    // 2) Criar registro de professor com empresa_id null (apenas admin consegue)\r\n    const { error: insertProfessorError } = await adminClient.from('professores').insert({\r\n      id: userId,\r\n      email,\r\n      nome_completo: fullName,\r\n      empresa_id: null,\r\n      is_admin: false,\r\n      cpf: null,\r\n      telefone: null,\r\n      biografia: null,\r\n      foto_url: null,\r\n      especialidade: null,\r\n    } as any);\r\n\r\n    if (insertProfessorError) {\r\n      // rollback best-effort\r\n      await adminClient.auth.admin.deleteUser(userId);\r\n      return NextResponse.json(\r\n        { error: `Erro ao criar registro de professor: ${insertProfessorError.message}` },\r\n        { status: 500 }\r\n      );\r\n    }\r\n\r\n    // 3) Atualizar metadata para role professor (não dispara trigger de insert)\r\n    await adminClient.auth.admin.updateUserById(userId, {\r\n      user_metadata: {\r\n        role: 'professor',\r\n        full_name: fullName,\r\n        is_admin: false,\r\n      },\r\n    });\r\n\r\n    return NextResponse.json(\r\n      {\r\n        user: { id: userId, email, fullName },\r\n        message: 'Conta de professor criada. Agora você pode cadastrar sua empresa dentro do app.',\r\n      },\r\n      { status: 201 }\r\n    );\r\n  } catch (error) {\r\n    console.error('Error in professor signup:', error);\r\n    const message = error instanceof Error ? error.message : 'Internal server error';\r\n    return NextResponse.json({ error: message }, { status: 500 });\r\n  }\r\n}\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\integrations\\google\\callback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2268,2271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2268,2271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/server\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const code = searchParams.get(\"code\")\r\n  const state = searchParams.get(\"state\")\r\n  const error = searchParams.get(\"error\")\r\n\r\n  // Handle errors from Google\r\n  if (error) {\r\n    console.error(\"Google OAuth error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(error)}`, request.url)\r\n    )\r\n  }\r\n\r\n  if (!code || !state) {\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?error=missing_params\", request.url)\r\n    )\r\n  }\r\n\r\n  try {\r\n    // Parse state to get professorId\r\n    const { professorId } = JSON.parse(decodeURIComponent(state))\r\n\r\n    if (!professorId) {\r\n      throw new Error(\"Missing professorId in state\")\r\n    }\r\n\r\n    // Exchange code for tokens\r\n    const clientId = process.env.NEXT_PUBLIC_GOOGLE_CLIENT_ID\r\n    const clientSecret = process.env.GOOGLE_CLIENT_SECRET\r\n    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL || request.nextUrl.origin}/api/integrations/google/callback`\r\n\r\n    if (!clientId || !clientSecret) {\r\n      throw new Error(\"Google OAuth credentials not configured\")\r\n    }\r\n\r\n    const tokenResponse = await fetch(\"https://oauth2.googleapis.com/token\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: new URLSearchParams({\r\n        code,\r\n        client_id: clientId,\r\n        client_secret: clientSecret,\r\n        redirect_uri: redirectUri,\r\n        grant_type: \"authorization_code\",\r\n      }),\r\n    })\r\n\r\n    if (!tokenResponse.ok) {\r\n      const errorText = await tokenResponse.text()\r\n      console.error(\"Token exchange error:\", errorText)\r\n      throw new Error(\"Failed to exchange code for tokens\")\r\n    }\r\n\r\n    const tokens = await tokenResponse.json()\r\n\r\n    // Calculate token expiry\r\n    const tokenExpiry = new Date(Date.now() + tokens.expires_in * 1000).toISOString()\r\n\r\n    // Save tokens to database\r\n    const supabase = await createClient()\r\n\r\n    const { error: upsertError } = await (supabase as any)\r\n      .from(\"agendamento_integracoes\")\r\n      .upsert({\r\n        professor_id: professorId,\r\n        provider: \"google\",\r\n        access_token: tokens.access_token,\r\n        refresh_token: tokens.refresh_token,\r\n        token_expiry: tokenExpiry,\r\n        updated_at: new Date().toISOString(),\r\n      }, {\r\n        onConflict: \"professor_id\"\r\n      })\r\n\r\n    if (upsertError) {\r\n      console.error(\"Database error:\", upsertError)\r\n      throw new Error(\"Failed to save integration\")\r\n    }\r\n\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?success=google\", request.url)\r\n    )\r\n  } catch (error) {\r\n    console.error(\"Google OAuth callback error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(String(error))}`, request.url)\r\n    )\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\integrations\\zoom\\callback\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2419,2422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2419,2422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextRequest, NextResponse } from \"next/server\"\r\nimport { createClient } from \"@/lib/server\"\r\n\r\nexport async function GET(request: NextRequest) {\r\n  const searchParams = request.nextUrl.searchParams\r\n  const code = searchParams.get(\"code\")\r\n  const state = searchParams.get(\"state\")\r\n  const error = searchParams.get(\"error\")\r\n\r\n  // Handle errors from Zoom\r\n  if (error) {\r\n    console.error(\"Zoom OAuth error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(error)}`, request.url)\r\n    )\r\n  }\r\n\r\n  if (!code || !state) {\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?error=missing_params\", request.url)\r\n    )\r\n  }\r\n\r\n  try {\r\n    // Parse state to get professorId\r\n    const { professorId } = JSON.parse(decodeURIComponent(state))\r\n\r\n    if (!professorId) {\r\n      throw new Error(\"Missing professorId in state\")\r\n    }\r\n\r\n    // Exchange code for tokens\r\n    const clientId = process.env.NEXT_PUBLIC_ZOOM_CLIENT_ID\r\n    const clientSecret = process.env.ZOOM_CLIENT_SECRET\r\n    const redirectUri = `${process.env.NEXT_PUBLIC_APP_URL || request.nextUrl.origin}/api/integrations/zoom/callback`\r\n\r\n    if (!clientId || !clientSecret) {\r\n      throw new Error(\"Zoom OAuth credentials not configured\")\r\n    }\r\n\r\n    // Zoom uses Basic auth with client credentials\r\n    const basicAuth = Buffer.from(`${clientId}:${clientSecret}`).toString(\"base64\")\r\n\r\n    const tokenResponse = await fetch(\"https://zoom.us/oauth/token\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Authorization\": `Basic ${basicAuth}`,\r\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: new URLSearchParams({\r\n        code,\r\n        grant_type: \"authorization_code\",\r\n        redirect_uri: redirectUri,\r\n      }),\r\n    })\r\n\r\n    if (!tokenResponse.ok) {\r\n      const errorText = await tokenResponse.text()\r\n      console.error(\"Zoom token exchange error:\", errorText)\r\n      throw new Error(\"Failed to exchange code for tokens\")\r\n    }\r\n\r\n    const tokens = await tokenResponse.json()\r\n\r\n    // Calculate token expiry (Zoom tokens typically last 1 hour)\r\n    const tokenExpiry = new Date(Date.now() + (tokens.expires_in || 3600) * 1000).toISOString()\r\n\r\n    // Save tokens to database\r\n    const supabase = await createClient()\r\n\r\n    const { error: upsertError } = await (supabase as any)\r\n      .from(\"agendamento_integracoes\")\r\n      .upsert({\r\n        professor_id: professorId,\r\n        provider: \"zoom\",\r\n        access_token: tokens.access_token,\r\n        refresh_token: tokens.refresh_token,\r\n        token_expiry: tokenExpiry,\r\n        updated_at: new Date().toISOString(),\r\n      }, {\r\n        onConflict: \"professor_id\"\r\n      })\r\n\r\n    if (upsertError) {\r\n      console.error(\"Database error:\", upsertError)\r\n      throw new Error(\"Failed to save integration\")\r\n    }\r\n\r\n    return NextResponse.redirect(\r\n      new URL(\"/professor/configuracoes/integracoes?success=zoom\", request.url)\r\n    )\r\n  } catch (error) {\r\n    console.error(\"Zoom OAuth callback error:\", error)\r\n    return NextResponse.redirect(\r\n      new URL(`/professor/configuracoes/integracoes?error=${encodeURIComponent(String(error))}`, request.url)\r\n    )\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\app\\api\\sessao\\finalizar\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[392,395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[392,395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport { requireUserAuth, AuthenticatedRequest } from '@/backend/auth/middleware';\r\nimport {\r\n  sessaoEstudoService,\r\n  SessaoEstudoValidationError,\r\n  SessaoEstudoNotFoundError,\r\n} from '@/backend/services/sessao-estudo';\r\nimport { SessaoEstudo } from '@/types/sessao-estudo';\r\n\r\nfunction serialize(sessao: SessaoEstudo) {\r\n  const s = sessao as any; // Type assertion para compatibilidade\r\n  return {\r\n    id: s.id,\r\n    aluno_id: s.aluno_id || s.alunoId,\r\n    disciplina_id: s.disciplina_id || s.disciplinaId,\r\n    frente_id: s.frente_id || s.frenteId,\r\n    modulo_id: s.modulo_id || s.moduloId,\r\n    atividade_relacionada_id: s.atividade_relacionada_id || s.atividadeRelacionadaId,\r\n    inicio: s.inicio,\r\n    fim: s.fim,\r\n    tempo_total_bruto_segundos: s.tempo_total_bruto_segundos || s.tempoTotalBrutoSegundos,\r\n    tempo_total_liquido_segundos: s.tempo_total_liquido_segundos || s.tempoTotalLiquidoSegundos,\r\n    log_pausas: s.log_pausas || s.logPausas,\r\n    metodo_estudo: s.metodo_estudo || s.metodoEstudo,\r\n    nivel_foco: s.nivel_foco || s.nivelFoco,\r\n    status: s.status,\r\n    created_at: s.created_at || s.createdAt,\r\n  };\r\n}\r\n\r\nasync function handler(request: AuthenticatedRequest) {\r\n  try {\r\n    const body = await request.json();\r\n    const sessao = await sessaoEstudoService.finalizarSessao(request.user!.id, {\r\n      sessaoId: body?.sessao_id,\r\n      logPausas: body?.log_pausas ?? [],\r\n      fimIso: body?.fim ?? undefined,\r\n      nivelFoco: body?.nivel_foco ?? undefined,\r\n      status: body?.status ?? undefined,\r\n    });\r\n\r\n    return NextResponse.json({ data: serialize(sessao) });\r\n  } catch (error) {\r\n    if (error instanceof SessaoEstudoValidationError) {\r\n      return NextResponse.json({ error: error.message }, { status: 400 });\r\n    }\r\n    if (error instanceof SessaoEstudoNotFoundError) {\r\n      return NextResponse.json({ error: error.message }, { status: 404 });\r\n    }\r\n\r\n    console.error('[sessao/finalizar]', error);\r\n    return NextResponse.json({ error: 'Erro interno' }, { status: 500 });\r\n  }\r\n}\r\n\r\nexport const PATCH = requireUserAuth(handler);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\backend\\services\\conversation\\conversation.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":338,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9095,9098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9095,9098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9216,9219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9216,9219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createClient } from \"@/lib/server\";\r\nimport type {\r\n  Conversation,\r\n  ChatMessage,\r\n  CreateConversationRequest,\r\n  UpdateConversationRequest,\r\n  ListConversationsRequest,\r\n  DeleteConversationRequest,\r\n  GetActiveConversationRequest,\r\n} from \"./conversation.types\";\r\n\r\n// Helper function to map database conversation to Conversation type\r\ninterface ConversationRow {\r\n  id: string;\r\n  user_id: string;\r\n  session_id: string;\r\n  title: string;\r\n  messages?: unknown;\r\n  created_at?: string | null;\r\n  updated_at?: string | null;\r\n  is_active?: boolean | null;\r\n  history?: unknown;\r\n  [key: string]: unknown;\r\n}\r\n\r\nfunction mapConversation(data: ConversationRow): Conversation {\r\n  return {\r\n    ...data,\r\n    messages:\r\n      data.messages &&\r\n      typeof data.messages === \"object\" &&\r\n      Array.isArray(data.messages)\r\n        ? (data.messages as unknown as ChatMessage[])\r\n        : null,\r\n    created_at: data.created_at || \"1970-01-01T00:00:00.000Z\",\r\n    updated_at: data.updated_at || \"1970-01-01T00:00:00.000Z\",\r\n    is_active: data.is_active ?? true,\r\n  } as Conversation;\r\n}\r\n\r\nexport class ConversationService {\r\n  /**\r\n   * Criar nova conversa\r\n   */\r\n  async createConversation(\r\n    request: CreateConversationRequest,\r\n  ): Promise<Conversation> {\r\n    const supabase = await createClient();\r\n\r\n    // Gerar session_id único\r\n    const sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .insert({\r\n        user_id: request.userId,\r\n        session_id: sessionId,\r\n        title: request.title || \"Nova Conversa\",\r\n        is_active: true, // Nova conversa sempre começa ativa\r\n      })\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error creating conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to create conversation: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      throw new Error(\"Failed to create conversation: No data returned\");\r\n    }\r\n\r\n    console.log(\"[Conversation Service] ✅ Conversation created:\", data.id);\r\n\r\n    type ConversationRow = {\r\n      id: string;\r\n      user_id: string;\r\n      session_id: string;\r\n      title: string;\r\n      messages: unknown;\r\n      is_active: boolean | null;\r\n      created_at: string | null;\r\n      updated_at: string | null;\r\n    };\r\n    return mapConversation(data as ConversationRow);\r\n  }\r\n\r\n  /**\r\n   * Listar conversas do usuário\r\n   */\r\n  async listConversations(\r\n    request: ListConversationsRequest,\r\n  ): Promise<Conversation[]> {\r\n    const supabase = await createClient();\r\n\r\n    let query = supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", request.userId)\r\n      .order(\"updated_at\", { ascending: false });\r\n\r\n    if (request.limit) {\r\n      query = query.limit(request.limit);\r\n    }\r\n\r\n    if (request.offset) {\r\n      query = query.range(\r\n        request.offset,\r\n        request.offset + (request.limit || 10) - 1,\r\n      );\r\n    }\r\n\r\n    const { data, error } = await query;\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error listing conversations:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to list conversations: ${error.message}`);\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] 📋 Listed\",\r\n      data?.length || 0,\r\n      \"conversations\",\r\n    );\r\n    return (data || []).map(mapConversation);\r\n  }\r\n\r\n  /**\r\n   * Obter conversa ativa do usuário\r\n   */\r\n  async getActiveConversation(\r\n    request: GetActiveConversationRequest,\r\n  ): Promise<Conversation | null> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"user_id\", request.userId)\r\n      .eq(\"is_active\", true)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error getting active conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to get active conversation: ${error.message}`);\r\n    }\r\n\r\n    if (data) {\r\n      console.log(\"[Conversation Service] ✅ Active conversation:\", data.id);\r\n      return mapConversation(data);\r\n    } else {\r\n      console.log(\"[Conversation Service] ℹ️  No active conversation found\");\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obter conversa por ID\r\n   */\r\n  async getConversationById(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<Conversation | null> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .select(\"*\")\r\n      .eq(\"id\", id)\r\n      .eq(\"user_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error getting conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to get conversation: ${error.message}`);\r\n    }\r\n\r\n    return data ? mapConversation(data) : null;\r\n  }\r\n\r\n  /**\r\n   * Atualizar conversa\r\n   */\r\n  async updateConversation(\r\n    request: UpdateConversationRequest,\r\n  ): Promise<Conversation> {\r\n    const supabase = await createClient();\r\n\r\n    const updates: Record<string, unknown> = {};\r\n\r\n    if (request.title !== undefined && request.title !== null) {\r\n      const trimmedTitle = String(request.title).trim();\r\n      if (trimmedTitle.length > 0) {\r\n        updates.title = trimmedTitle;\r\n      } else {\r\n        throw new Error(\"Title cannot be empty\");\r\n      }\r\n    }\r\n\r\n    if (request.is_active !== undefined) {\r\n      updates.is_active = Boolean(request.is_active);\r\n    }\r\n\r\n    // Verificar se há campos para atualizar\r\n    if (Object.keys(updates).length === 0) {\r\n      console.log(\r\n        \"[Conversation Service] No fields to update, returning existing conversation\",\r\n      );\r\n      const existing = await this.getConversationById(\r\n        request.id,\r\n        request.userId,\r\n      );\r\n      if (!existing) {\r\n        throw new Error(\"Conversation not found\");\r\n      }\r\n      return existing;\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] Updating conversation:\",\r\n      request.id,\r\n      \"with:\",\r\n      updates,\r\n    );\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .update(updates)\r\n      .eq(\"id\", request.id)\r\n      .eq(\"user_id\", request.userId)\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error updating conversation:\",\r\n        error,\r\n      );\r\n      console.error(\r\n        \"[Conversation Service] Error details:\",\r\n        JSON.stringify(error, null, 2),\r\n      );\r\n      throw new Error(`Failed to update conversation: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      console.error(\"[Conversation Service] No data returned after update\");\r\n      throw new Error(\"Conversation not found or unauthorized\");\r\n    }\r\n\r\n    console.log(\"[Conversation Service] ✅ Conversation updated:\", data.id);\r\n    return mapConversation(data);\r\n  }\r\n\r\n  /**\r\n   * Marcar conversa como ativa (desmarca outras)\r\n   */\r\n  async setActiveConversation(\r\n    id: string,\r\n    userId: string,\r\n  ): Promise<Conversation> {\r\n    return this.updateConversation({\r\n      id,\r\n      userId,\r\n      is_active: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletar conversa\r\n   */\r\n  async deleteConversation(request: DeleteConversationRequest): Promise<void> {\r\n    const supabase = await createClient();\r\n\r\n    const { error } = await supabase\r\n      .from(\"chat_conversations\")\r\n      .delete()\r\n      .eq(\"id\", request.id)\r\n      .eq(\"user_id\", request.userId);\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error deleting conversation:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to delete conversation: ${error.message}`);\r\n    }\r\n\r\n    console.log(\"[Conversation Service] 🗑️  Conversation deleted:\", request.id);\r\n  }\r\n\r\n  /**\r\n   * Obter ou criar conversa ativa\r\n   * Se não houver conversa ativa, cria uma nova\r\n   */\r\n  async getOrCreateActiveConversation(userId: string): Promise<Conversation> {\r\n    // Tentar obter conversa ativa\r\n    let active = await this.getActiveConversation({ userId });\r\n\r\n    // Se não houver, criar nova\r\n    if (!active) {\r\n      console.log(\r\n        \"[Conversation Service] No active conversation, creating new one\",\r\n      );\r\n      active = await this.createConversation({ userId });\r\n    }\r\n\r\n    return active;\r\n  }\r\n\r\n  /**\r\n   * Atualiza o histórico completo da conversa (JSONB)\r\n   */\r\n  async updateConversationHistory(\r\n    conversationId: string,\r\n    userId: string,\r\n    history: ChatMessage[],\r\n  ): Promise<void> {\r\n    const supabase = await createClient();\r\n\r\n    // `history` é persistido em JSONB. O tipo `Json` do Supabase é bem estrito e não aceita `ChatMessage[]` diretamente.\r\n    // Em runtime isso é serializável, então fazemos cast controlado para evitar ruído de typecheck.\r\n    const payload = {\r\n      conversation_id: conversationId,\r\n      user_id: userId,\r\n      history: history as any,\r\n    };\r\n\r\n    const { error } = await supabase\r\n      .from(\"chat_conversation_history\")\r\n      .upsert(payload as any, { onConflict: \"conversation_id\" });\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error updating conversation history:\",\r\n        error,\r\n      );\r\n      throw new Error(\r\n        `Failed to update conversation history: ${error.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\r\n      \"[Conversation Service] ✅ Conversation history saved:\",\r\n      conversationId,\r\n    );\r\n  }\r\n\r\n  async getConversationHistory(\r\n    conversationId: string,\r\n    userId: string,\r\n  ): Promise<ChatMessage[]> {\r\n    const supabase = await createClient();\r\n\r\n    const { data, error } = await supabase\r\n      .from(\"chat_conversation_history\")\r\n      .select(\"history\")\r\n      .eq(\"conversation_id\", conversationId)\r\n      .eq(\"user_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[Conversation Service] Error fetching conversation history:\",\r\n        error,\r\n      );\r\n      throw new Error(`Failed to fetch conversation history: ${error.message}`);\r\n    }\r\n\r\n    if (Array.isArray(data?.history)) {\r\n      return data?.history as unknown as ChatMessage[];\r\n    }\r\n\r\n    return [];\r\n  }\r\n}\r\n\r\nexport const conversationService = new ConversationService();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\backend\\services\\cronograma\\cronograma.service.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2416,2419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2416,2419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1953,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1953,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[67416,67419],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[67416,67419],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  getDatabaseClient,\r\n  clearDatabaseClientCache,\r\n} from \"@/backend/clients/database\";\r\nimport type { Database } from \"@/lib/database.types\";\r\nimport {\r\n  GerarCronogramaInput,\r\n  GerarCronogramaResult,\r\n  AulaCompleta,\r\n  FrenteDistribuicao,\r\n  SemanaInfo,\r\n  ItemDistribuicao,\r\n  CronogramaSemanasDias,\r\n  AtualizarDistribuicaoDiasInput,\r\n  RecalcularDatasResult,\r\n  SemanaEstatisticas,\r\n  EstatisticasSemanasResult,\r\n  CronogramaDetalhado,\r\n  FeriasPeriodo,\r\n} from \"./cronograma.types\";\r\nimport {\r\n  FrenteValidacaoResult,\r\n  FrenteStatsAccumulator,\r\n  FrenteCountAccumulator,\r\n  FrenteComCursoDiferenteAccumulator,\r\n  AulaQueryResult,\r\n  ModuloQueryResult,\r\n  DiagnosticoFrente,\r\n  FrenteInfo,\r\n  ModuloInfo,\r\n  ModuloSelecionadoQueryResult,\r\n  FrenteQueryResult,\r\n  getFirst,\r\n  getDisciplinaNome,\r\n  getFrenteInfo,\r\n  getModuloInfo,\r\n} from \"./cronograma.query-types\";\r\nimport {\r\n  CronogramaValidationError,\r\n  CronogramaTempoInsuficienteError,\r\n  CronogramaConflictError,\r\n} from \"./errors\";\r\n\r\nconst TEMPO_PADRAO_MINUTOS = 10;\r\nconst FATOR_MULTIPLICADOR = 1.5;\r\n\r\n// Helper para logs que só aparecem em desenvolvimento\r\nconst logDebug = (...args: unknown[]) => {\r\n  if (process.env.NODE_ENV === \"development\") {\r\n    console.log(...args);\r\n  }\r\n};\r\n\r\nconst logError = (...args: unknown[]) => {\r\n  console.error(...args);\r\n};\r\n\r\n// Helper to map database row to CronogramaDetalhado\r\nfunction mapToCronogramaDetalhado(\r\n  row: Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Row\"],\r\n): CronogramaDetalhado {\r\n  return {\r\n    id: row.id,\r\n    aluno_id: row.aluno_id,\r\n    curso_alvo_id: row.curso_alvo_id,\r\n    nome: row.nome ?? \"Meu Cronograma\",\r\n    data_inicio: row.data_inicio,\r\n    data_fim: row.data_fim,\r\n    dias_estudo_semana: row.dias_estudo_semana,\r\n    horas_estudo_dia: row.horas_estudo_dia,\r\n    periodos_ferias: (row.periodos_ferias as unknown as FeriasPeriodo[]) ?? [],\r\n    prioridade_minima: row.prioridade_minima,\r\n    modalidade_estudo: row.modalidade_estudo as \"paralelo\" | \"sequencial\",\r\n    disciplinas_selecionadas:\r\n      (row.disciplinas_selecionadas as unknown as string[]) ?? [],\r\n    ordem_frentes_preferencia:\r\n      (row.ordem_frentes_preferencia as unknown as string[]) ?? null,\r\n    modulos_selecionados:\r\n      (row.modulos_selecionados as unknown as string[]) ?? null,\r\n    excluir_aulas_concluidas: row.excluir_aulas_concluidas,\r\n    velocidade_reproducao: (row as any).velocidade_reproducao ?? 1.0,\r\n    created_at: row.created_at ?? new Date().toISOString(),\r\n    updated_at: row.updated_at ?? new Date().toISOString(),\r\n  };\r\n}\r\n\r\nexport class CronogramaService {\r\n  async gerarCronograma(\r\n    input: GerarCronogramaInput,\r\n    userId: string,\r\n    userEmail?: string,\r\n    empresaId?: string,\r\n  ): Promise<GerarCronogramaResult> {\r\n    logDebug(\"[CronogramaService] Iniciando geração de cronograma:\", {\r\n      aluno_id: input.aluno_id,\r\n      userId,\r\n      userEmail,\r\n      data_inicio: input.data_inicio,\r\n      data_fim: input.data_fim,\r\n      disciplinas_count: input.disciplinas_ids?.length || 0,\r\n    });\r\n\r\n    // Validações básicas\r\n    if (!input.aluno_id || !input.data_inicio || !input.data_fim) {\r\n      throw new CronogramaValidationError(\r\n        \"Campos obrigatórios: aluno_id, data_inicio, data_fim\",\r\n      );\r\n    }\r\n\r\n    // Verificar se aluno_id corresponde ao usuário autenticado\r\n    if (input.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Você só pode criar cronogramas para si mesmo\",\r\n      );\r\n    }\r\n\r\n    // Validar datas\r\n    const dataInicio = new Date(input.data_inicio);\r\n    const dataFim = new Date(input.data_fim);\r\n\r\n    if (isNaN(dataInicio.getTime()) || isNaN(dataFim.getTime())) {\r\n      throw new CronogramaValidationError(\"Datas inválidas\");\r\n    }\r\n\r\n    if (dataFim <= dataInicio) {\r\n      throw new CronogramaValidationError(\r\n        \"data_fim deve ser posterior a data_inicio\",\r\n      );\r\n    }\r\n\r\n    const client = getDatabaseClient();\r\n\r\n    // Resolver empresa_id (prioriza metadata; faz fallback para tabela alunos)\r\n    const resolvedEmpresaId = await this.resolveEmpresaId(\r\n      client,\r\n      userId,\r\n      empresaId,\r\n    );\r\n    if (!resolvedEmpresaId) {\r\n      throw new CronogramaValidationError(\r\n        \"Empresa não encontrada para o usuário autenticado (empresa_id ausente).\",\r\n      );\r\n    }\r\n\r\n    // Verificar se aluno_id corresponde ao usuário autenticado, se não existir, criar\r\n    await this.ensureAlunoExists(client, userId, userEmail, resolvedEmpresaId);\r\n\r\n    // Deletar cronograma anterior do aluno (se existir)\r\n    await this.deletarCronogramaAnterior(client, userId);\r\n\r\n    const excluirConcluidas = input.excluir_aulas_concluidas !== false;\r\n    const aulasConcluidas = excluirConcluidas\r\n      ? await this.buscarAulasConcluidas(\r\n          client,\r\n          input.aluno_id,\r\n          input.curso_alvo_id,\r\n        )\r\n      : new Set<string>();\r\n\r\n    // ============================================\r\n    // ETAPA 1: Cálculo de Capacidade\r\n    // ============================================\r\n\r\n    const semanas = this.calcularSemanas(\r\n      dataInicio,\r\n      dataFim,\r\n      input.ferias,\r\n      input.horas_dia,\r\n      input.dias_semana,\r\n    );\r\n    const capacidadeTotal = semanas\r\n      .filter((s) => !s.is_ferias)\r\n      .reduce((acc, s) => acc + s.capacidade_minutos, 0);\r\n\r\n    // ============================================\r\n    // ETAPA 2: Busca e Filtragem de Aulas\r\n    // ============================================\r\n\r\n    const aulasBase = await this.buscarAulas(\r\n      client,\r\n      input.disciplinas_ids,\r\n      input.prioridade_minima,\r\n      input.curso_alvo_id,\r\n      input.modulos_ids,\r\n    );\r\n\r\n    const aulas = excluirConcluidas\r\n      ? aulasBase.filter((aula) => !aulasConcluidas.has(aula.id))\r\n      : aulasBase;\r\n\r\n    if (!aulas.length) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula disponível após aplicar os filtros selecionados.\",\r\n      );\r\n    }\r\n\r\n    // Validar que todas as frentes das disciplinas selecionadas têm aulas\r\n    // Buscar todas as frentes das disciplinas selecionadas para validação\r\n    let validacaoFrentesQuery = client\r\n      .from(\"frentes\")\r\n      .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n      .in(\"disciplina_id\", input.disciplinas_ids);\r\n\r\n    if (input.curso_alvo_id) {\r\n      validacaoFrentesQuery = validacaoFrentesQuery.eq(\r\n        \"curso_id\",\r\n        input.curso_alvo_id,\r\n      );\r\n    }\r\n\r\n    const { data: todasFrentes, error: frentesError } =\r\n      await validacaoFrentesQuery;\r\n\r\n    // Type assertion needed: Supabase doesn't infer join types automatically\r\n    // The query joins frentes with disciplinas table to get disciplina name\r\n    type FrenteWithDisciplina = {\r\n      id: string;\r\n      nome: string;\r\n      disciplina_id: string;\r\n      curso_id: string;\r\n      disciplinas: { nome: string } | null;\r\n    };\r\n\r\n    if (!frentesError && todasFrentes && todasFrentes.length > 0) {\r\n      const typedFrentes = todasFrentes as unknown as FrenteWithDisciplina[];\r\n      const frentesComAulas = new Set(aulas.map((a) => a.frente_id));\r\n      const frentesSemAulas = typedFrentes.filter(\r\n        (f) => !frentesComAulas.has(f.id),\r\n      );\r\n\r\n      if (frentesSemAulas.length > 0) {\r\n        console.warn(\r\n          \"[CronogramaService] ⚠️ Frentes sem aulas no cronograma gerado:\",\r\n          {\r\n            total_frentes_sem_aulas: frentesSemAulas.length,\r\n            total_frentes_esperadas: todasFrentes.length,\r\n            total_frentes_com_aulas: frentesComAulas.size,\r\n            frentes: frentesSemAulas.map((f: FrenteValidacaoResult) => ({\r\n              id: f.id,\r\n              nome: f.nome,\r\n              disciplina: getDisciplinaNome(f.disciplinas) || \"Desconhecida\",\r\n              curso_id: f.curso_id,\r\n            })),\r\n            motivo_possivel: excluirConcluidas\r\n              ? \"Aulas podem ter sido excluídas por estarem concluídas ou não terem prioridade suficiente\"\r\n              : \"Aulas podem não ter prioridade suficiente ou módulos não foram selecionados\",\r\n            prioridade_minima: input.prioridade_minima,\r\n            modulos_selecionados: input.modulos_ids?.length || 0,\r\n          },\r\n        );\r\n      } else {\r\n        console.log(\r\n          \"[CronogramaService] ✅ Todas as frentes selecionadas têm aulas no cronograma\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // ============================================\r\n    // ETAPA 3: Cálculo de Custo Real\r\n    // ============================================\r\n\r\n    // Velocidade de reprodução padrão: 1.00x\r\n    const velocidadeReproducao = input.velocidade_reproducao ?? 1.0;\r\n\r\n    // Tempo de aula ajustado pela velocidade: se assistir em 1.5x, o tempo real é reduzido\r\n    // Tempo de estudo (anotações/exercícios) é calculado sobre o tempo de aula ajustado\r\n    const aulasComCusto = aulas.map((aula) => {\r\n      const tempoOriginal = aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS;\r\n      const tempoAulaAjustado = tempoOriginal / velocidadeReproducao;\r\n      // Custo = tempo de aula (ajustado) + tempo de estudo (calculado sobre o tempo ajustado)\r\n      const custo = tempoAulaAjustado * FATOR_MULTIPLICADOR;\r\n      return {\r\n        ...aula,\r\n        custo,\r\n      };\r\n    });\r\n\r\n    const custoTotalNecessario = aulasComCusto.reduce(\r\n      (acc, aula) => acc + aula.custo,\r\n      0,\r\n    );\r\n\r\n    // ============================================\r\n    // ETAPA 4: Verificação de Viabilidade\r\n    // ============================================\r\n\r\n    if (custoTotalNecessario > capacidadeTotal) {\r\n      const horasNecessarias = custoTotalNecessario / 60;\r\n      const horasDisponiveis = capacidadeTotal / 60;\r\n      const semanasUteis = semanas.filter((s) => !s.is_ferias).length;\r\n      const horasDiaNecessarias =\r\n        horasNecessarias / (semanasUteis * input.dias_semana);\r\n\r\n      throw new CronogramaTempoInsuficienteError(\"Tempo insuficiente\", {\r\n        horas_necessarias: Math.ceil(horasNecessarias),\r\n        horas_disponiveis: Math.ceil(horasDisponiveis),\r\n        horas_dia_necessarias: Math.ceil(horasDiaNecessarias * 10) / 10,\r\n        horas_dia_atual: input.horas_dia,\r\n      });\r\n    }\r\n\r\n    // ============================================\r\n    // ETAPA 5: Algoritmo de Distribuição\r\n    // ============================================\r\n\r\n    const itens = this.distribuirAulas(\r\n      aulasComCusto,\r\n      semanas,\r\n      input.modalidade,\r\n      input.ordem_frentes_preferencia,\r\n    );\r\n\r\n    if (itens.length === 0) {\r\n      console.error(\r\n        \"[CronogramaService] Nenhum item foi criado na distribuição!\",\r\n        {\r\n          totalAulas: aulasComCusto.length,\r\n          totalSemanas: semanas.length,\r\n          semanasUteis: semanas.filter((s) => !s.is_ferias).length,\r\n          modalidade: input.modalidade,\r\n        },\r\n      );\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula foi distribuída. Verifique se há semanas úteis disponíveis e se as aulas selecionadas são compatíveis com o período.\",\r\n      );\r\n    }\r\n\r\n    logDebug(\"[CronogramaService] Distribuição concluída:\", {\r\n      totalItens: itens.length,\r\n      semanasComItens: new Set(itens.map((i) => i.semana_numero)).size,\r\n    });\r\n\r\n    // ============================================\r\n    // ETAPA 6: Persistência\r\n    // ============================================\r\n\r\n    const cronograma = await this.persistirCronograma(\r\n      client,\r\n      input,\r\n      itens,\r\n      resolvedEmpresaId,\r\n    );\r\n\r\n    const semanasUteis = semanas.filter((s) => !s.is_ferias);\r\n\r\n    return {\r\n      success: true,\r\n      cronograma,\r\n      estatisticas: {\r\n        total_aulas: aulas.length,\r\n        total_semanas: semanas.length,\r\n        semanas_uteis: semanasUteis.length,\r\n        capacidade_total_minutos: capacidadeTotal,\r\n        custo_total_minutos: custoTotalNecessario,\r\n        frentes_distribuidas: new Set(aulas.map((a) => a.frente_id)).size,\r\n      },\r\n    };\r\n  }\r\n\r\n  private async deletarCronogramaAnterior(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n  ): Promise<void> {\r\n    console.log(\r\n      \"[CronogramaService] Verificando e deletando cronograma anterior...\",\r\n    );\r\n\r\n    // Buscar cronograma existente do aluno\r\n    const { data: cronogramaExistente, error: selectError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id\")\r\n      .eq(\"aluno_id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (selectError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao verificar cronograma existente:\",\r\n        selectError,\r\n      );\r\n      // Não lançar erro, apenas logar - pode não existir cronograma anterior\r\n      return;\r\n    }\r\n\r\n    if (cronogramaExistente) {\r\n      console.log(\r\n        \"[CronogramaService] Deletando cronograma anterior:\",\r\n        cronogramaExistente.id,\r\n      );\r\n\r\n      // Deletar cronograma (cascade vai deletar os itens automaticamente devido ao ON DELETE CASCADE)\r\n      const { error: deleteError } = await client\r\n        .from(\"cronogramas\")\r\n        .delete()\r\n        .eq(\"id\", cronogramaExistente.id);\r\n\r\n      if (deleteError) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao deletar cronograma anterior:\",\r\n          deleteError,\r\n        );\r\n        throw new Error(\r\n          `Erro ao deletar cronograma anterior: ${deleteError.message}`,\r\n        );\r\n      }\r\n\r\n      console.log(\r\n        \"[CronogramaService] Cronograma anterior deletado com sucesso\",\r\n      );\r\n    } else {\r\n      console.log(\"[CronogramaService] Nenhum cronograma anterior encontrado\");\r\n    }\r\n  }\r\n\r\n  private async ensureAlunoExists(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n    userEmail?: string,\r\n    empresaId?: string,\r\n  ): Promise<void> {\r\n    // Verificar se o aluno já existe\r\n    const { data: alunoExistente, error: selectError } = await client\r\n      .from(\"alunos\")\r\n      .select(\"id\")\r\n      .eq(\"id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (selectError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao verificar aluno:\",\r\n        selectError,\r\n      );\r\n      throw new Error(`Erro ao verificar aluno: ${selectError.message}`);\r\n    }\r\n\r\n    // Se o aluno não existe, criar um registro básico\r\n    if (!alunoExistente) {\r\n      console.log(\r\n        \"[CronogramaService] Aluno não encontrado, criando registro...\",\r\n      );\r\n\r\n      if (!userEmail) {\r\n        throw new CronogramaValidationError(\r\n          \"Email do usuário é necessário para criar o registro de aluno\",\r\n        );\r\n      }\r\n\r\n      if (!empresaId) {\r\n        throw new CronogramaValidationError(\r\n          \"Empresa não encontrada para criar o registro de aluno (empresa_id ausente).\",\r\n        );\r\n      }\r\n\r\n      const { error: insertError } = await client.from(\"alunos\").insert({\r\n        id: userId,\r\n        email: userEmail,\r\n        empresa_id: empresaId,\r\n      });\r\n\r\n      if (insertError) {\r\n        console.error(\"[CronogramaService] Erro ao criar aluno:\", insertError);\r\n        throw new Error(\r\n          `Erro ao criar registro de aluno: ${insertError.message}`,\r\n        );\r\n      }\r\n\r\n      console.log(\"[CronogramaService] Registro de aluno criado com sucesso\");\r\n    }\r\n  }\r\n\r\n  private async resolveEmpresaId(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    userId: string,\r\n    empresaId?: string,\r\n  ): Promise<string | undefined> {\r\n    if (empresaId) return empresaId;\r\n\r\n    const { data, error } = await client\r\n      .from(\"alunos\")\r\n      .select(\"empresa_id\")\r\n      .eq(\"id\", userId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao resolver empresa_id do aluno:\",\r\n        error,\r\n      );\r\n      return undefined;\r\n    }\r\n\r\n    return (data?.empresa_id as string | null | undefined) ?? undefined;\r\n  }\r\n\r\n  private calcularSemanas(\r\n    dataInicio: Date,\r\n    dataFim: Date,\r\n    ferias: Array<{ inicio: string; fim: string }>,\r\n    horasDia: number,\r\n    diasSemana: number,\r\n  ): SemanaInfo[] {\r\n    const semanas: SemanaInfo[] = [];\r\n    const inicio = new Date(dataInicio);\r\n    let semanaNumero = 1;\r\n\r\n    while (inicio <= dataFim) {\r\n      const fimSemana = new Date(inicio);\r\n      fimSemana.setDate(fimSemana.getDate() + 6); // 7 dias (0-6)\r\n\r\n      // Verificar se a semana cai em período de férias\r\n      let isFerias = false;\r\n      for (const periodo of ferias || []) {\r\n        const inicioFerias = new Date(periodo.inicio);\r\n        const fimFerias = new Date(periodo.fim);\r\n        if (\r\n          (inicio >= inicioFerias && inicio <= fimFerias) ||\r\n          (fimSemana >= inicioFerias && fimSemana <= fimFerias) ||\r\n          (inicio <= inicioFerias && fimSemana >= fimFerias)\r\n        ) {\r\n          isFerias = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      semanas.push({\r\n        numero: semanaNumero,\r\n        data_inicio: new Date(inicio),\r\n        data_fim: fimSemana > dataFim ? new Date(dataFim) : fimSemana,\r\n        is_ferias: isFerias,\r\n        capacidade_minutos: isFerias ? 0 : horasDia * diasSemana * 60,\r\n      });\r\n\r\n      inicio.setDate(inicio.getDate() + 7);\r\n      semanaNumero++;\r\n    }\r\n\r\n    return semanas;\r\n  }\r\n\r\n  private async buscarAulas(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    disciplinasIds: string[],\r\n    prioridadeMinima: number,\r\n    cursoId?: string,\r\n    modulosSelecionados?: string[],\r\n  ): Promise<AulaCompleta[]> {\r\n    const prioridadeMinimaEfetiva = Math.max(1, prioridadeMinima ?? 1);\r\n    console.log(\r\n      \"🔍 [CronogramaService] ===========================================\",\r\n    );\r\n    console.log(\"🔍 [CronogramaService] INICIANDO BUSCA DE AULAS\");\r\n    console.log(\"🔍 [CronogramaService] Disciplinas:\", disciplinasIds);\r\n    console.log(\"🔍 [CronogramaService] Curso ID:\", cursoId);\r\n    console.log(\r\n      \"🔍 [CronogramaService] Módulos selecionados:\",\r\n      modulosSelecionados?.length || 0,\r\n    );\r\n    console.log(\r\n      \"🔍 [CronogramaService] Prioridade mínima:\",\r\n      prioridadeMinimaEfetiva,\r\n    );\r\n    console.log(\r\n      \"🔍 [CronogramaService] ===========================================\",\r\n    );\r\n\r\n    // Buscar frentes das disciplinas selecionadas (com informações completas para validação)\r\n    console.log(\r\n      \"🔍 [CronogramaService] ========== DIAGNÓSTICO DE FRENTES ==========\",\r\n    );\r\n    console.log(\"[CronogramaService] Buscando frentes para:\", {\r\n      disciplinas_ids: disciplinasIds,\r\n      curso_id: cursoId,\r\n      total_disciplinas: disciplinasIds.length,\r\n    });\r\n\r\n    // PRIMEIRO: Buscar TODAS as frentes das disciplinas (sem filtro de curso) para diagnóstico\r\n    const { data: todasFrentesSemFiltro, error: todasFrentesError } =\r\n      await client\r\n        .from(\"frentes\")\r\n        .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n        .in(\"disciplina_id\", disciplinasIds);\r\n\r\n    if (todasFrentesError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar todas as frentes (diagnóstico):\",\r\n        todasFrentesError,\r\n      );\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] TOTAL de frentes encontradas (SEM filtro de curso):\",\r\n        todasFrentesSemFiltro?.length || 0,\r\n      );\r\n\r\n      // Agrupar por disciplina e curso\r\n      const frentesPorDisciplinaECurso = new Map<\r\n        string,\r\n        { disciplina: string; frentes: FrenteInfo[] }\r\n      >();\r\n      todasFrentesSemFiltro?.forEach((frente: FrenteValidacaoResult) => {\r\n        const discId = frente.disciplina_id;\r\n        const discNome =\r\n          getDisciplinaNome(frente.disciplinas) || \"Desconhecida\";\r\n        const key = `${discId}_${frente.curso_id || \"sem-curso\"}`;\r\n\r\n        if (!frentesPorDisciplinaECurso.has(key)) {\r\n          frentesPorDisciplinaECurso.set(key, {\r\n            disciplina: discNome,\r\n            frentes: [],\r\n          });\r\n        }\r\n        frentesPorDisciplinaECurso.get(key)!.frentes.push({\r\n          id: frente.id,\r\n          nome: frente.nome,\r\n          curso_id: frente.curso_id,\r\n        });\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] Frentes agrupadas por disciplina e curso:\",\r\n        Array.from(frentesPorDisciplinaECurso.entries()).map(([key, info]) => ({\r\n          disciplina: info.disciplina,\r\n          curso_id:\r\n            key.split(\"_\")[1] === \"sem-curso\" ? null : key.split(\"_\")[1],\r\n          total_frentes: info.frentes.length,\r\n          frentes: info.frentes.map((f: FrenteInfo) => f.nome),\r\n        })),\r\n      );\r\n\r\n      // Verificar frentes do curso selecionado\r\n      if (cursoId) {\r\n        const frentesDoCurso =\r\n          todasFrentesSemFiltro?.filter(\r\n            (f: FrenteValidacaoResult) => f.curso_id === cursoId,\r\n          ) || [];\r\n        console.log(\"[CronogramaService] Frentes do curso selecionado:\", {\r\n          curso_id: cursoId,\r\n          total: frentesDoCurso.length,\r\n          frentes: frentesDoCurso.map((f: FrenteValidacaoResult) => ({\r\n            id: f.id,\r\n            nome: f.nome,\r\n            disciplina: getDisciplinaNome(f.disciplinas),\r\n          })),\r\n        });\r\n\r\n        // Verificar se há frentes sem curso_id\r\n        const frentesSemCurso =\r\n          todasFrentesSemFiltro?.filter(\r\n            (f: FrenteValidacaoResult) => !f.curso_id,\r\n          ) || [];\r\n        if (frentesSemCurso.length > 0) {\r\n          console.warn(\r\n            \"[CronogramaService] ⚠️ Frentes SEM curso_id encontradas:\",\r\n            frentesSemCurso.map((f: FrenteValidacaoResult) => ({\r\n              id: f.id,\r\n              nome: f.nome,\r\n              disciplina: getDisciplinaNome(f.disciplinas),\r\n            })),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // AGORA: Buscar frentes com filtro de curso (query real)\r\n    let frentesQuery = client\r\n      .from(\"frentes\")\r\n      .select(\"id, nome, disciplina_id, curso_id, disciplinas(nome)\")\r\n      .in(\"disciplina_id\", disciplinasIds);\r\n\r\n    if (cursoId) {\r\n      frentesQuery = frentesQuery.eq(\"curso_id\", cursoId);\r\n    }\r\n\r\n    const { data: frentesData, error: frentesError } = await frentesQuery;\r\n\r\n    if (frentesError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar frentes:\",\r\n        frentesError,\r\n      );\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar frentes: ${frentesError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"🔍 [CronogramaService] RESULTADO DA BUSCA DE FRENTES:\", {\r\n      total_encontradas: frentesData?.length || 0,\r\n      frentes: frentesData?.map((f: FrenteValidacaoResult) => ({\r\n        id: f.id,\r\n        nome: f.nome,\r\n        disciplina_id: f.disciplina_id,\r\n        curso_id: f.curso_id,\r\n        disciplina_nome: Array.isArray(f.disciplinas)\r\n          ? f.disciplinas[0]?.nome\r\n          : f.disciplinas?.nome,\r\n      })),\r\n    });\r\n\r\n    const frenteIds = frentesData?.map((f) => f.id) || [];\r\n    const frentesPorDisciplina = new Map<string, string[]>();\r\n\r\n    // Agrupar frentes por disciplina para validação\r\n    frentesData?.forEach((frente: FrenteValidacaoResult) => {\r\n      const discId = frente.disciplina_id;\r\n      if (discId && !frentesPorDisciplina.has(discId)) {\r\n        frentesPorDisciplina.set(discId, []);\r\n      }\r\n      if (discId) {\r\n        frentesPorDisciplina.get(discId)!.push(frente.nome);\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Frentes encontradas por disciplina (COM filtro):\",\r\n      Array.from(frentesPorDisciplina.entries()).map(([discId, nomes]) => {\r\n        const primeiraFrente = frentesData?.find(\r\n          (f: FrenteValidacaoResult) => f.disciplina_id === discId,\r\n        );\r\n        const disciplinaNome =\r\n          getDisciplinaNome(primeiraFrente?.disciplinas) || \"Desconhecida\";\r\n        return {\r\n          disciplina_id: discId,\r\n          disciplina_nome: disciplinaNome,\r\n          frentes: nomes,\r\n          total: nomes.length,\r\n        };\r\n      }),\r\n    );\r\n\r\n    // Validação crítica: verificar se todas as disciplinas têm frentes\r\n    disciplinasIds.forEach((discId) => {\r\n      const frentesDaDisciplina = frentesPorDisciplina.get(discId) || [];\r\n      if (frentesDaDisciplina.length === 0) {\r\n        console.error(\r\n          `[CronogramaService] ❌❌❌ DISCIPLINA ${discId} NÃO TEM FRENTES ENCONTRADAS!`,\r\n        );\r\n      } else {\r\n        console.log(\r\n          `[CronogramaService] ✅ Disciplina ${discId} tem ${frentesDaDisciplina.length} frente(s):`,\r\n          frentesDaDisciplina,\r\n        );\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes encontradas:\",\r\n      frenteIds.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] ===========================================\",\r\n    );\r\n\r\n    if (frenteIds.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma frente encontrada para as disciplinas selecionadas\",\r\n      );\r\n    }\r\n\r\n    // Buscar módulos das frentes (com informações da frente para validação)\r\n    console.log(\r\n      \"[CronogramaService] ========== DIAGNÓSTICO DE MÓDULOS ==========\",\r\n    );\r\n    console.log(\"[CronogramaService] Buscando módulos para:\", {\r\n      total_frentes: frenteIds.length,\r\n      frente_ids: frenteIds,\r\n      curso_id: cursoId,\r\n    });\r\n\r\n    // PRIMEIRO: Buscar TODOS os módulos das frentes (sem filtro de curso) para diagnóstico\r\n    const { data: todosModulosSemFiltro, error: todosModulosError } =\r\n      await client\r\n        .from(\"modulos\")\r\n        .select(\r\n          \"id, nome, frente_id, curso_id, frentes(id, nome, disciplina_id, curso_id, disciplinas(nome))\",\r\n        )\r\n        .in(\"frente_id\", frenteIds);\r\n\r\n    if (todosModulosError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar todos os módulos (diagnóstico):\",\r\n        todosModulosError,\r\n      );\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] TOTAL de módulos encontrados (SEM filtro de curso):\",\r\n        todosModulosSemFiltro?.length || 0,\r\n      );\r\n\r\n      // Agrupar módulos por frente\r\n      const modulosPorFrenteSemFiltro = new Map<string, DiagnosticoFrente>();\r\n      todosModulosSemFiltro?.forEach((modulo: ModuloQueryResult) => {\r\n        const frenteId = modulo.frente_id || \"\";\r\n        if (!modulosPorFrenteSemFiltro.has(frenteId)) {\r\n          const frente = getFrenteInfo(modulo.frentes);\r\n          modulosPorFrenteSemFiltro.set(frenteId, {\r\n            frente: {\r\n              id: frente?.id,\r\n              nome: frente?.nome,\r\n              disciplina: getDisciplinaNome(frente?.disciplinas),\r\n              curso_id: frente?.curso_id,\r\n            },\r\n            modulos: [],\r\n          });\r\n        }\r\n        modulosPorFrenteSemFiltro.get(frenteId)!.modulos.push({\r\n          id: modulo.id,\r\n          nome: modulo.nome || \"\",\r\n          curso_id: modulo.curso_id ?? null,\r\n        });\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] Módulos agrupados por frente (SEM filtro):\",\r\n        Array.from(modulosPorFrenteSemFiltro.entries()).map(\r\n          ([frenteId, info]) => ({\r\n            frente_id: frenteId,\r\n            frente_nome: info.frente.nome,\r\n            disciplina: info.frente.disciplina,\r\n            frente_curso_id: info.frente.curso_id,\r\n            total_modulos: info.modulos.length,\r\n            modulos: info.modulos.map((m: ModuloInfo) => ({\r\n              id: m.id,\r\n              nome: m.nome,\r\n              curso_id: m.curso_id,\r\n            })),\r\n          }),\r\n        ),\r\n      );\r\n\r\n      // Verificar módulos do curso selecionado\r\n      if (cursoId) {\r\n        const modulosDoCurso =\r\n          todosModulosSemFiltro?.filter(\r\n            (m: ModuloQueryResult) => m.curso_id === cursoId,\r\n          ) || [];\r\n        console.log(\"[CronogramaService] Módulos do curso selecionado:\", {\r\n          curso_id: cursoId,\r\n          total: modulosDoCurso.length,\r\n        });\r\n\r\n        // Verificar frentes sem módulos no curso\r\n        frenteIds.forEach((frenteId) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          const modulosDaFrente =\r\n            todosModulosSemFiltro?.filter(\r\n              (m: ModuloQueryResult) =>\r\n                m.frente_id === frenteId && m.curso_id === cursoId,\r\n            ) || [];\r\n\r\n          if (modulosDaFrente.length === 0) {\r\n            console.error(\r\n              `[CronogramaService] ❌❌❌ FRENTE \"${frente?.nome}\" (${frenteId}) NÃO TEM MÓDULOS NO CURSO ${cursoId}!`,\r\n            );\r\n          } else {\r\n            console.log(\r\n              `[CronogramaService] ✅ Frente \"${frente?.nome}\" tem ${modulosDaFrente.length} módulo(s) no curso`,\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // AGORA: Buscar módulos com filtro de curso (query real)\r\n    let modulosQuery = client\r\n      .from(\"modulos\")\r\n      .select(\r\n        \"id, frente_id, curso_id, frentes(nome, disciplina_id, curso_id, disciplinas(nome))\",\r\n      )\r\n      .in(\"frente_id\", frenteIds);\r\n\r\n    // Alguns módulos antigos podem não ter curso_id definido.\r\n    // Quando um curso é informado, aceitamos módulos que pertençam às frentes do curso\r\n    // mesmo se o curso_id estiver null, para manter compatibilidade com dados legados.\r\n    if (cursoId) {\r\n      modulosQuery = modulosQuery.or(`curso_id.eq.${cursoId},curso_id.is.null`);\r\n    }\r\n\r\n    const { data: modulosData, error: modulosError } = await modulosQuery;\r\n\r\n    if (modulosError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar módulos:\",\r\n        modulosError,\r\n      );\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar módulos: ${modulosError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"🔍 [CronogramaService] RESULTADO DA BUSCA DE MÓDULOS:\", {\r\n      total_encontrados: modulosData?.length || 0,\r\n      frentes_com_modulos: new Set(\r\n        modulosData?.map((m: ModuloQueryResult) => m.frente_id || \"\") || [],\r\n      ).size,\r\n      total_frentes_esperadas: frenteIds.length,\r\n      modulos_por_frente: modulosData?.reduce(\r\n        (acc: Record<string, number>, m: ModuloQueryResult) => {\r\n          const frenteId = m.frente_id || \"\";\r\n          if (!acc[frenteId]) {\r\n            acc[frenteId] = 0;\r\n          }\r\n          acc[frenteId]++;\r\n          return acc;\r\n        },\r\n        {} as Record<string, number>,\r\n      ),\r\n    });\r\n\r\n    // Verificar quais frentes NÃO têm módulos\r\n    const frentesComModulos = new Set(\r\n      modulosData?.map((m: ModuloQueryResult) => m.frente_id || \"\") || [],\r\n    );\r\n    const frentesSemModulos = frenteIds.filter(\r\n      (id) => !frentesComModulos.has(id),\r\n    );\r\n    if (frentesSemModulos.length > 0) {\r\n      console.error(\r\n        \"🔍 [CronogramaService] ❌❌❌ FRENTES SEM MÓDULOS ENCONTRADAS:\",\r\n        frentesSemModulos.map((id) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === id,\r\n          );\r\n          return {\r\n            frente_id: id,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            disciplina_id: frente?.disciplina_id,\r\n          };\r\n        }),\r\n      );\r\n    }\r\n\r\n    let moduloIds = modulosData?.map((m) => m.id) || [];\r\n    const modulosPorFrente = new Map<string, string[]>();\r\n\r\n    // Agrupar módulos por frente para validação\r\n    modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n      const frenteId = modulo.frente_id || \"\";\r\n      if (!modulosPorFrente.has(frenteId)) {\r\n        modulosPorFrente.set(frenteId, []);\r\n      }\r\n      modulosPorFrente.get(frenteId)!.push(modulo.id);\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Módulos encontrados por frente (COM filtro):\",\r\n      Array.from(modulosPorFrente.entries()).map(([frenteId, moduloIds]) => {\r\n        const frente = frentesData?.find(\r\n          (f: FrenteValidacaoResult) => f.id === frenteId,\r\n        );\r\n        const moduloComFrente = modulosData?.find(\r\n          (m: ModuloQueryResult) => m.frente_id === frenteId,\r\n        );\r\n        const frenteInfo = getFrenteInfo(moduloComFrente?.frentes);\r\n        const disciplinaNome =\r\n          getDisciplinaNome(frenteInfo?.disciplinas) || \"Desconhecida\";\r\n        return {\r\n          frente_id: frenteId,\r\n          frente_nome: frente?.nome || frenteInfo?.nome || \"Desconhecida\",\r\n          disciplina: disciplinaNome,\r\n          total_modulos: moduloIds.length,\r\n          modulo_ids: moduloIds,\r\n        };\r\n      }),\r\n    );\r\n\r\n    // Validação crítica: verificar se todas as frentes têm módulos\r\n    frenteIds.forEach((frenteId) => {\r\n      const modulosDaFrente = modulosPorFrente.get(frenteId) || [];\r\n      const frente = frentesData?.find(\r\n        (f: FrenteValidacaoResult) => f.id === frenteId,\r\n      );\r\n      if (modulosDaFrente.length === 0) {\r\n        console.error(\r\n          `[CronogramaService] ❌❌❌ FRENTE \"${frente?.nome}\" (${frenteId}) NÃO TEM MÓDULOS!`,\r\n        );\r\n      } else {\r\n        console.log(\r\n          `[CronogramaService] ✅ Frente \"${frente?.nome}\" tem ${modulosDaFrente.length} módulo(s)`,\r\n        );\r\n      }\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Total de módulos encontrados:\",\r\n      moduloIds.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] ===========================================\",\r\n    );\r\n\r\n    if (modulosSelecionados && modulosSelecionados.length > 0) {\r\n      const modulosAntesFiltro = moduloIds.length;\r\n\r\n      // Log detalhado dos módulos antes do filtro\r\n      const modulosPorFrenteAntes = new Map<\r\n        string,\r\n        { total: number; ids: string[] }\r\n      >();\r\n      modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n        const frenteId = modulo.frente_id || \"\";\r\n        if (!modulosPorFrenteAntes.has(frenteId)) {\r\n          modulosPorFrenteAntes.set(frenteId, { total: 0, ids: [] });\r\n        }\r\n        const frente = modulosPorFrenteAntes.get(frenteId)!;\r\n        frente.total++;\r\n        frente.ids.push(modulo.id);\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] Módulos ANTES do filtro por frente:\",\r\n        Array.from(modulosPorFrenteAntes.entries()).map(([frenteId, info]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_modulos: info.total,\r\n            modulo_ids: info.ids,\r\n          };\r\n        }),\r\n      );\r\n\r\n      moduloIds = moduloIds.filter((id) => modulosSelecionados.includes(id));\r\n\r\n      console.log(\"[CronogramaService] Filtro de módulos aplicado:\", {\r\n        modulos_antes: modulosAntesFiltro,\r\n        modulos_depois: moduloIds.length,\r\n        modulos_selecionados_total: modulosSelecionados.length,\r\n        modulos_selecionados_primeiros_10: modulosSelecionados.slice(0, 10),\r\n      });\r\n\r\n      // Validar que todas as frentes têm pelo menos um módulo selecionado\r\n      const frentesComModulosSelecionados = new Set<string>();\r\n      const modulosPorFrenteDepois = new Map<\r\n        string,\r\n        { total: number; ids: string[] }\r\n      >();\r\n\r\n      modulosData?.forEach((modulo: ModuloQueryResult) => {\r\n        if (moduloIds.includes(modulo.id)) {\r\n          const frenteId = modulo.frente_id || \"\";\r\n          frentesComModulosSelecionados.add(frenteId);\r\n          if (!modulosPorFrenteDepois.has(frenteId)) {\r\n            modulosPorFrenteDepois.set(frenteId, { total: 0, ids: [] });\r\n          }\r\n          const frente = modulosPorFrenteDepois.get(frenteId)!;\r\n          frente.total++;\r\n          frente.ids.push(modulo.id);\r\n        }\r\n      });\r\n\r\n      console.log(\r\n        \"[CronogramaService] Módulos DEPOIS do filtro por frente:\",\r\n        Array.from(modulosPorFrenteDepois.entries()).map(([frenteId, info]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_modulos: info.total,\r\n            modulo_ids: info.ids,\r\n          };\r\n        }),\r\n      );\r\n\r\n      // Verificar se há módulos selecionados que não pertencem a nenhuma frente encontrada\r\n      const modulosSelecionadosValidos = new Set(moduloIds);\r\n      const modulosSelecionadosInvalidos = modulosSelecionados.filter(\r\n        (id) => !modulosSelecionadosValidos.has(id),\r\n      );\r\n      if (modulosSelecionadosInvalidos.length > 0) {\r\n        console.warn(\r\n          \"[CronogramaService] ⚠️ Módulos selecionados que não pertencem às frentes encontradas:\",\r\n          {\r\n            total_invalidos: modulosSelecionadosInvalidos.length,\r\n            modulo_ids: modulosSelecionadosInvalidos.slice(0, 10),\r\n          },\r\n        );\r\n      }\r\n\r\n      const frentesSemModulos = frenteIds.filter(\r\n        (id) => !frentesComModulosSelecionados.has(id),\r\n      );\r\n      if (frentesSemModulos.length > 0) {\r\n        const frentesSemModulosNomes = frentesSemModulos.map((id) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteValidacaoResult) => f.id === id,\r\n          );\r\n          return {\r\n            frente_id: id,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            disciplina_id: frente?.disciplina_id || \"Desconhecida\",\r\n          };\r\n        });\r\n        console.warn(\r\n          \"[CronogramaService] ⚠️⚠️⚠️ Frentes sem módulos selecionados (CRÍTICO):\",\r\n          JSON.stringify(frentesSemModulosNomes, null, 2),\r\n        );\r\n\r\n        // Tentar identificar se há módulos dessas frentes que não foram selecionados\r\n        frentesSemModulos.forEach((frenteId) => {\r\n          const modulosDaFrente = modulosPorFrenteAntes.get(frenteId);\r\n          if (modulosDaFrente && modulosDaFrente.ids.length > 0) {\r\n            console.warn(\r\n              `[CronogramaService] ⚠️ Frente ${frentesData?.find((f: FrenteValidacaoResult) => f.id === frenteId)?.nome} tem ${modulosDaFrente.ids.length} módulo(s) disponível(is) mas nenhum foi selecionado:`,\r\n              modulosDaFrente.ids.slice(0, 5),\r\n            );\r\n          }\r\n        });\r\n      }\r\n\r\n      if (moduloIds.length === 0) {\r\n        console.warn(\r\n          \"[CronogramaService] Nenhum módulo selecionado permaneceu após o filtro por frentes/curso.\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // Diagnóstico adicional quando o usuário selecionou módulos mas nenhum foi considerado válido\r\n    if (\r\n      moduloIds.length === 0 &&\r\n      modulosSelecionados &&\r\n      modulosSelecionados.length > 0\r\n    ) {\r\n      const { data: modulosSelecionadosData, error: modulosSelecionadosError } =\r\n        await client\r\n          .from(\"modulos\")\r\n          .select(\r\n            \"id, frente_id, curso_id, frentes(id, nome, curso_id, disciplinas(nome))\",\r\n          )\r\n          .in(\"id\", modulosSelecionados);\r\n\r\n      if (modulosSelecionadosError) {\r\n        console.warn(\r\n          \"[CronogramaService] Não foi possível diagnosticar módulos selecionados:\",\r\n          modulosSelecionadosError,\r\n        );\r\n      } else {\r\n        const frentesValidasSet = new Set(frenteIds);\r\n        const modulosForaDasFrentes = (modulosSelecionadosData || []).filter(\r\n          (m: ModuloSelecionadoQueryResult) =>\r\n            m.frente_id && !frentesValidasSet.has(m.frente_id),\r\n        );\r\n\r\n        console.warn(\r\n          \"[CronogramaService] ⚠️ Módulos selecionados não pertencem às frentes/curso informados:\",\r\n          {\r\n            cursoId,\r\n            total_modulos_selecionados: modulosSelecionados.length,\r\n            total_modulos_encontrados: modulosSelecionadosData?.length || 0,\r\n            modulos_fora_das_frentes: modulosForaDasFrentes.map(\r\n              (m: ModuloSelecionadoQueryResult) => {\r\n                const frenteInfo = getFirst(m.frentes);\r\n                return {\r\n                  id: m.id,\r\n                  frente_id: m.frente_id,\r\n                  curso_id: m.curso_id,\r\n                  frente_nome: frenteInfo?.nome,\r\n                  frente_curso_id: frenteInfo?.curso_id,\r\n                  disciplina_nome: getFirst(frenteInfo?.disciplinas)?.nome,\r\n                };\r\n              },\r\n            ),\r\n          },\r\n        );\r\n      }\r\n\r\n      throw new CronogramaValidationError(\r\n        \"Nenhum módulo válido encontrado para o curso selecionado. Verifique se os módulos estão vinculados às frentes e disciplinas escolhidas.\",\r\n      );\r\n    }\r\n\r\n    if (moduloIds.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhum módulo encontrado para as frentes selecionadas\",\r\n      );\r\n    }\r\n\r\n    // PRIMEIRO: Buscar TODAS as aulas (sem filtro de prioridade) para diagnóstico\r\n    console.log(\r\n      \"🔍 [CronogramaService] Buscando TODAS as aulas (sem filtro de prioridade) para diagnóstico...\",\r\n    );\r\n    const { data: todasAulasSemFiltro, error: todasAulasError } = await client\r\n      .from(\"aulas\")\r\n      .select(\r\n        `\r\n        id,\r\n        nome,\r\n        prioridade,\r\n        modulo_id,\r\n        modulos!inner(\r\n          id,\r\n          frente_id,\r\n          frentes!inner(\r\n            id,\r\n            nome,\r\n            curso_id\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .in(\"modulo_id\", moduloIds);\r\n\r\n    if (!todasAulasError && todasAulasSemFiltro) {\r\n      // Agrupar por frente\r\n      const aulasPorFrente = new Map<\r\n        string,\r\n        {\r\n          total: number;\r\n          prioridade_0: number;\r\n          prioridade_null: number;\r\n          prioridade_menor_1: number;\r\n          prioridade_maior_igual_1: number;\r\n        }\r\n      >();\r\n\r\n      todasAulasSemFiltro.forEach((aula: AulaQueryResult) => {\r\n        const modulo = getModuloInfo(aula.modulos);\r\n        const frente = getFrenteInfo(modulo?.frentes);\r\n        const frenteId = frente?.id;\r\n        if (!frenteId) return;\r\n\r\n        if (!aulasPorFrente.has(frenteId)) {\r\n          aulasPorFrente.set(frenteId, {\r\n            total: 0,\r\n            prioridade_0: 0,\r\n            prioridade_null: 0,\r\n            prioridade_menor_1: 0,\r\n            prioridade_maior_igual_1: 0,\r\n          });\r\n        }\r\n\r\n        const stats = aulasPorFrente.get(frenteId)!;\r\n        stats.total++;\r\n\r\n        if (aula.prioridade === null || aula.prioridade === undefined) {\r\n          stats.prioridade_null++;\r\n        } else if (aula.prioridade === 0) {\r\n          stats.prioridade_0++;\r\n        } else if (aula.prioridade < 1) {\r\n          stats.prioridade_menor_1++;\r\n        } else if (aula.prioridade >= 1) {\r\n          stats.prioridade_maior_igual_1++;\r\n        }\r\n      });\r\n\r\n      console.log(\r\n        \"🔍 [CronogramaService] Diagnóstico de aulas por frente (ANTES do filtro de prioridade):\",\r\n        Array.from(aulasPorFrente.entries()).map(([frenteId, stats]) => {\r\n          const frente = frentesData?.find(\r\n            (f: FrenteQueryResult) => f.id === frenteId,\r\n          );\r\n          return {\r\n            frente_id: frenteId,\r\n            frente_nome: frente?.nome || \"Desconhecida\",\r\n            total_aulas: stats.total,\r\n            prioridade_0: stats.prioridade_0,\r\n            prioridade_null: stats.prioridade_null,\r\n            prioridade_menor_1: stats.prioridade_menor_1,\r\n            prioridade_maior_igual_1: stats.prioridade_maior_igual_1,\r\n            sera_incluida: stats.prioridade_maior_igual_1 > 0,\r\n          };\r\n        }),\r\n      );\r\n    }\r\n\r\n    // Buscar aulas dos módulos com filtro de prioridade\r\n    // Não usamos curso_id direto de aulas para evitar problemas de cache/sincronização\r\n    // Filtramos via join com frentes após buscar\r\n    const aulasQuery = client\r\n      .from(\"aulas\")\r\n      .select(\r\n        `\r\n        id,\r\n        nome,\r\n        numero_aula,\r\n        tempo_estimado_minutos,\r\n        prioridade,\r\n        modulos!inner(\r\n          id,\r\n          nome,\r\n          numero_modulo,\r\n          frentes!inner(\r\n            id,\r\n            nome,\r\n            curso_id,\r\n            disciplinas!inner(\r\n              id,\r\n              nome\r\n            )\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .in(\"modulo_id\", moduloIds)\r\n      .gte(\"prioridade\", prioridadeMinimaEfetiva)\r\n      .neq(\"prioridade\", 0);\r\n\r\n    const { data: aulasDataRaw, error: aulasError } = await aulasQuery;\r\n\r\n    if (aulasError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar aulas:\", {\r\n        message: aulasError.message,\r\n        details: aulasError.details,\r\n        hint: aulasError.hint,\r\n        code: aulasError.code,\r\n      });\r\n\r\n      // Se o erro for sobre curso_id não existir, tentar buscar sem selecionar curso_id\r\n      if (aulasError.message?.includes(\"curso_id\")) {\r\n        console.warn(\r\n          \"[CronogramaService] Tentando buscar aulas sem filtro de curso_id...\",\r\n        );\r\n        const { data: aulasDataSemFiltro, error: errorSemFiltro } = await client\r\n          .from(\"aulas\")\r\n          .select(\r\n            `\r\n            id,\r\n            nome,\r\n            numero_aula,\r\n            tempo_estimado_minutos,\r\n            prioridade,\r\n            modulos!inner(\r\n              id,\r\n              nome,\r\n              numero_modulo,\r\n              frentes!inner(\r\n                id,\r\n                nome,\r\n                curso_id,\r\n                disciplinas!inner(\r\n                  id,\r\n                  nome\r\n                )\r\n              )\r\n            )\r\n          `,\r\n          )\r\n          .in(\"modulo_id\", moduloIds)\r\n          .gte(\"prioridade\", prioridadeMinimaEfetiva)\r\n          .neq(\"prioridade\", 0);\r\n\r\n        if (errorSemFiltro) {\r\n          throw new CronogramaValidationError(\r\n            `Erro ao buscar aulas: ${errorSemFiltro.message}`,\r\n          );\r\n        }\r\n\r\n        // Filtrar por curso_id em memória baseado na frente\r\n        if (aulasDataSemFiltro) {\r\n          const aulasFiltradas = aulasDataSemFiltro.filter(\r\n            (aula: AulaQueryResult) => {\r\n              const modulo = getModuloInfo(aula.modulos);\r\n              const frente = getFrenteInfo(modulo?.frentes);\r\n              return frente?.curso_id === cursoId;\r\n            },\r\n          );\r\n\r\n          if (aulasFiltradas.length === 0) {\r\n            throw new CronogramaValidationError(\r\n              \"Nenhuma aula encontrada com os critérios fornecidos\",\r\n            );\r\n          }\r\n\r\n          // Continuar com aulasFiltradas\r\n          const aulas: AulaCompleta[] = aulasFiltradas.map(\r\n            (aula: AulaQueryResult) => {\r\n              const modulo = getModuloInfo(aula.modulos);\r\n              const frente = getFrenteInfo(modulo?.frentes);\r\n              const disciplina = getFirst(frente?.disciplinas);\r\n              return {\r\n                id: aula.id,\r\n                nome: aula.nome,\r\n                numero_aula: aula.numero_aula ?? null,\r\n                tempo_estimado_minutos:\r\n                  aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS,\r\n                prioridade: aula.prioridade ?? 1,\r\n                modulo_id: modulo?.id || \"\",\r\n                modulo_nome: modulo?.nome || \"\",\r\n                numero_modulo: modulo?.numero_modulo ?? null,\r\n                frente_id: frente?.id || \"\",\r\n                frente_nome: frente?.nome || \"\",\r\n                disciplina_id: disciplina?.id || \"\",\r\n                disciplina_nome: disciplina?.nome || \"\",\r\n              };\r\n            },\r\n          );\r\n\r\n          return aulas;\r\n        }\r\n      }\r\n\r\n      console.error(\"[CronogramaService] Erro ao buscar aulas:\", {\r\n        message: aulasError.message,\r\n        details: aulasError.details,\r\n        hint: aulasError.hint,\r\n        code: aulasError.code,\r\n      });\r\n      throw new CronogramaValidationError(\r\n        `Erro ao buscar aulas: ${aulasError.message}`,\r\n      );\r\n    }\r\n\r\n    if (!aulasDataRaw || aulasDataRaw.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"Nenhuma aula encontrada com os critérios fornecidos\",\r\n      );\r\n    }\r\n\r\n    console.log(\r\n      \"🔍 [CronogramaService] Aulas encontradas ANTES do filtro de curso:\",\r\n      {\r\n        total: aulasDataRaw.length,\r\n        por_frente: aulasDataRaw.reduce(\r\n          (acc: FrenteStatsAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id || \"\";\r\n            const frenteNome = frente?.nome || \"\";\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = {\r\n                frente_nome: frenteNome,\r\n                total: 0,\r\n                curso_ids: new Set(),\r\n              };\r\n            }\r\n            acc[frenteId].total++;\r\n            if (frente?.curso_id) {\r\n              acc[frenteId].curso_ids.add(frente.curso_id);\r\n            }\r\n            return acc;\r\n          },\r\n          {} as FrenteStatsAccumulator,\r\n        ),\r\n      },\r\n    );\r\n\r\n    // Filtrar por curso_id usando o join com frentes (se fornecido)\r\n    let aulasData = aulasDataRaw;\r\n    if (cursoId) {\r\n      const aulasAntesFiltro = aulasDataRaw.length;\r\n      aulasData = aulasDataRaw.filter((aula: AulaQueryResult) => {\r\n        const modulo = getModuloInfo(aula.modulos);\r\n        const frente = getFrenteInfo(modulo?.frentes);\r\n        return frente?.curso_id === cursoId;\r\n      });\r\n\r\n      console.log(\"🔍 [CronogramaService] Filtro de curso aplicado:\", {\r\n        curso_id: cursoId,\r\n        aulas_antes: aulasAntesFiltro,\r\n        aulas_depois: aulasData.length,\r\n        aulas_removidas: aulasAntesFiltro - aulasData.length,\r\n        por_frente: aulasData.reduce(\r\n          (acc: FrenteCountAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id || \"\";\r\n            const frenteNome = frente?.nome || \"\";\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = { frente_nome: frenteNome, total: 0 };\r\n            }\r\n            acc[frenteId].total++;\r\n            return acc;\r\n          },\r\n          {} as FrenteCountAccumulator,\r\n        ),\r\n      });\r\n\r\n      if (aulasData.length === 0) {\r\n        // Log detalhado antes de lançar erro\r\n        const frentesComCursoDiferente = aulasDataRaw.reduce(\r\n          (acc: FrenteComCursoDiferenteAccumulator, aula: AulaQueryResult) => {\r\n            const modulo = getModuloInfo(aula.modulos);\r\n            const frente = getFrenteInfo(modulo?.frentes);\r\n            const frenteId = frente?.id ?? \"\";\r\n            const frenteNome = frente?.nome ?? \"Desconhecida\";\r\n            const frenteCursoId = frente?.curso_id ?? null;\r\n            if (!acc[frenteId]) {\r\n              acc[frenteId] = {\r\n                frente_nome: frenteNome,\r\n                curso_id: frenteCursoId,\r\n                total: 0,\r\n              };\r\n            }\r\n            acc[frenteId].total++;\r\n            return acc;\r\n          },\r\n          {} as FrenteComCursoDiferenteAccumulator,\r\n        );\r\n\r\n        interface FrenteInfo {\r\n          frente_nome: string;\r\n          curso_id: string | null;\r\n          total: number;\r\n        }\r\n\r\n        console.error(\r\n          \"🔍 [CronogramaService] ❌❌❌ Nenhuma aula encontrada após filtro de curso:\",\r\n          {\r\n            curso_id_esperado: cursoId,\r\n            frentes_encontradas: Object.values(frentesComCursoDiferente).map(\r\n              (f: FrenteInfo) => ({\r\n                frente_nome: f.frente_nome,\r\n                curso_id: f.curso_id,\r\n                total_aulas: f.total,\r\n                curso_id_correto: f.curso_id === cursoId,\r\n              }),\r\n            ),\r\n          },\r\n        );\r\n\r\n        throw new CronogramaValidationError(\r\n          \"Nenhuma aula encontrada para o curso selecionado\",\r\n        );\r\n      }\r\n    }\r\n\r\n    // Mapear dados para estrutura mais simples\r\n    const aulas: AulaCompleta[] = aulasData.map((aula: AulaQueryResult) => {\r\n      const modulo = getModuloInfo(aula.modulos);\r\n      const frente = getFrenteInfo(modulo?.frentes);\r\n      const disciplina = getFirst(frente?.disciplinas);\r\n\r\n      return {\r\n        id: aula.id,\r\n        nome: aula.nome,\r\n        numero_aula: aula.numero_aula ?? null,\r\n        tempo_estimado_minutos: aula.tempo_estimado_minutos ?? null,\r\n        prioridade: aula.prioridade ?? 0,\r\n        modulo_id: modulo?.id ?? \"\",\r\n        modulo_nome: modulo?.nome ?? \"\",\r\n        numero_modulo: modulo?.numero_modulo ?? null,\r\n        frente_id: frente?.id ?? \"\",\r\n        frente_nome: frente?.nome ?? \"\",\r\n        disciplina_id: disciplina?.id ?? \"\",\r\n        disciplina_nome: disciplina?.nome ?? \"\",\r\n      };\r\n    });\r\n\r\n    // Validar que todas as frentes selecionadas têm aulas\r\n    const frentesComAulas = new Set<string>();\r\n    aulas.forEach((aula) => {\r\n      frentesComAulas.add(aula.frente_id);\r\n    });\r\n\r\n    const frentesSemAulasInicial = frenteIds.filter(\r\n      (id) => !frentesComAulas.has(id),\r\n    );\r\n    if (frentesSemAulasInicial.length > 0) {\r\n      const frentesSemAulasNomes = frentesSemAulasInicial.map((id) => {\r\n        const frente = frentesData?.find((f: FrenteQueryResult) => f.id === id);\r\n        return frente?.nome || id;\r\n      });\r\n      console.warn(\r\n        \"[CronogramaService] ⚠️ Frentes sem aulas encontradas (após filtros):\",\r\n        {\r\n          frentes: frentesSemAulasNomes,\r\n          motivo_possivel:\r\n            \"Nenhuma aula encontrada com prioridade >= \" +\r\n            prioridadeMinimaEfetiva +\r\n            \" ou módulos não selecionados\",\r\n        },\r\n      );\r\n\r\n      // Verificar se há módulos selecionados para essas frentes\r\n      if (modulosSelecionados && modulosSelecionados.length > 0) {\r\n        frentesSemAulasInicial.forEach((frenteId) => {\r\n          const modulosDaFrente = modulosPorFrente.get(frenteId) || [];\r\n          const modulosSelecionadosDaFrente = modulosDaFrente.filter((id) =>\r\n            modulosSelecionados.includes(id),\r\n          );\r\n          if (modulosSelecionadosDaFrente.length > 0) {\r\n            console.warn(\r\n              `[CronogramaService] ⚠️ Frente ${frentesData?.find((f: FrenteQueryResult) => f.id === frenteId)?.nome} tem ${modulosSelecionadosDaFrente.length} módulo(s) selecionado(s) mas nenhuma aula foi encontrada`,\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    // Agrupar aulas por frente e disciplina para log\r\n    const aulasPorFrente = new Map<\r\n      string,\r\n      { frente_nome: string; disciplina_nome: string; total: number }\r\n    >();\r\n    aulas.forEach((aula) => {\r\n      if (!aulasPorFrente.has(aula.frente_id)) {\r\n        aulasPorFrente.set(aula.frente_id, {\r\n          frente_nome: aula.frente_nome,\r\n          disciplina_nome: aula.disciplina_nome,\r\n          total: 0,\r\n        });\r\n      }\r\n      aulasPorFrente.get(aula.frente_id)!.total++;\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Aulas encontradas por frente:\",\r\n      Array.from(aulasPorFrente.entries()).map(([frenteId, info]) => ({\r\n        frente_id: frenteId,\r\n        frente_nome: info.frente_nome,\r\n        disciplina_nome: info.disciplina_nome,\r\n        total_aulas: info.total,\r\n      })),\r\n    );\r\n\r\n    // Ordenar aulas: Disciplina > Frente > Numero Modulo > Numero Aula\r\n    aulas.sort((a, b) => {\r\n      // Ordenar por disciplina\r\n      if (a.disciplina_nome !== b.disciplina_nome) {\r\n        return a.disciplina_nome.localeCompare(b.disciplina_nome);\r\n      }\r\n      // Ordenar por frente\r\n      if (a.frente_nome !== b.frente_nome) {\r\n        return a.frente_nome.localeCompare(b.frente_nome);\r\n      }\r\n      // Ordenar por número do módulo\r\n      const numModA = a.numero_modulo ?? 0;\r\n      const numModB = b.numero_modulo ?? 0;\r\n      if (numModA !== numModB) {\r\n        return numModA - numModB;\r\n      }\r\n      // Ordenar por número da aula\r\n      const numAulaA = a.numero_aula ?? 0;\r\n      const numAulaB = b.numero_aula ?? 0;\r\n      return numAulaA - numAulaB;\r\n    });\r\n\r\n    console.log(\"[CronogramaService] ========== RESUMO FINAL ==========\");\r\n    console.log(\r\n      \"[CronogramaService] Total de aulas encontradas:\",\r\n      aulas.length,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes com aulas:\",\r\n      frentesComAulas.size,\r\n    );\r\n    console.log(\r\n      \"[CronogramaService] Total de frentes esperadas:\",\r\n      frenteIds.length,\r\n    );\r\n\r\n    // Listar todas as frentes e se têm aulas\r\n    const frentesComStatus = frenteIds.map((frenteId) => {\r\n      const frente = frentesData?.find(\r\n        (f: FrenteQueryResult) => f.id === frenteId,\r\n      );\r\n      const temAulas = frentesComAulas.has(frenteId);\r\n      const totalAulas = aulas.filter((a) => a.frente_id === frenteId).length;\r\n      return {\r\n        frente_id: frenteId,\r\n        frente_nome: frente?.nome || \"Desconhecida\",\r\n        disciplina_id: frente?.disciplina_id || \"Desconhecida\",\r\n        tem_aulas: temAulas,\r\n        total_aulas: totalAulas,\r\n      };\r\n    });\r\n\r\n    console.log(\r\n      \"[CronogramaService] Status de todas as frentes:\",\r\n      JSON.stringify(frentesComStatus, null, 2),\r\n    );\r\n\r\n    const frentesSemAulas = frentesComStatus.filter((f) => !f.tem_aulas);\r\n    if (frentesSemAulas.length > 0) {\r\n      console.error(\r\n        \"[CronogramaService] ❌❌❌ FRENTES SEM AULAS NO CRONOGRAMA:\",\r\n        JSON.stringify(frentesSemAulas, null, 2),\r\n      );\r\n    } else {\r\n      console.log(\"[CronogramaService] ✅ Todas as frentes têm aulas!\");\r\n    }\r\n    console.log(\"[CronogramaService] ====================================\");\r\n\r\n    return aulas;\r\n  }\r\n\r\n  private distribuirAulas(\r\n    aulasComCusto: Array<AulaCompleta & { custo: number }>,\r\n    semanas: SemanaInfo[],\r\n    modalidade: \"paralelo\" | \"sequencial\",\r\n    ordemFrentesPreferencia?: string[],\r\n  ): ItemDistribuicao[] {\r\n    // Agrupar aulas por frente\r\n    type FrenteComCusto = Omit<FrenteDistribuicao, \"aulas\"> & {\r\n      aulas: Array<AulaCompleta & { custo: number }>;\r\n    };\r\n    const frentesMap = new Map<string, FrenteComCusto>();\r\n\r\n    for (const aula of aulasComCusto) {\r\n      if (!frentesMap.has(aula.frente_id)) {\r\n        frentesMap.set(aula.frente_id, {\r\n          frente_id: aula.frente_id,\r\n          frente_nome: aula.frente_nome,\r\n          aulas: [],\r\n          custo_total: 0,\r\n          peso: 0,\r\n        });\r\n      }\r\n\r\n      const frente = frentesMap.get(aula.frente_id)!;\r\n      frente.aulas.push(aula);\r\n      frente.custo_total += aula.custo;\r\n    }\r\n\r\n    const frentes: FrenteComCusto[] = Array.from(frentesMap.values());\r\n    const custoTotalNecessario = aulasComCusto.reduce(\r\n      (acc, aula) => acc + aula.custo,\r\n      0,\r\n    );\r\n\r\n    // Calcular pesos (modo paralelo)\r\n    if (modalidade === \"paralelo\") {\r\n      frentes.forEach((frente) => {\r\n        frente.peso = frente.custo_total / custoTotalNecessario;\r\n      });\r\n    }\r\n\r\n    // Ordenar frentes (modo sequencial)\r\n    if (modalidade === \"sequencial\" && ordemFrentesPreferencia) {\r\n      const ordemMap = new Map(\r\n        ordemFrentesPreferencia.map((nome, idx) => [nome, idx]),\r\n      );\r\n      frentes.sort((a, b) => {\r\n        const ordemA = ordemMap.get(a.frente_nome) ?? Infinity;\r\n        const ordemB = ordemMap.get(b.frente_nome) ?? Infinity;\r\n        return ordemA - ordemB;\r\n      });\r\n    }\r\n\r\n    // Distribuir aulas por semana\r\n    const itens: ItemDistribuicao[] = [];\r\n    const semanasUteis = semanas.filter((s) => !s.is_ferias);\r\n\r\n    console.log(\"[CronogramaService] Distribuindo aulas:\", {\r\n      totalAulas: aulasComCusto.length,\r\n      totalSemanas: semanas.length,\r\n      semanasUteis: semanasUteis.length,\r\n      semanasFerias: semanas.filter((s) => s.is_ferias).length,\r\n      totalFrentes: frentes.length,\r\n      modalidade,\r\n    });\r\n\r\n    let frenteIndex = 0;\r\n    const aulaIndexPorFrente = new Map<string, number>();\r\n\r\n    // Inicializar índices de aula por frente\r\n    frentes.forEach((frente) => {\r\n      aulaIndexPorFrente.set(frente.frente_id, 0);\r\n    });\r\n\r\n    if (modalidade === \"paralelo\") {\r\n      // Modo Paralelo: Distribuir proporcionalmente\r\n      for (const semana of semanasUteis) {\r\n        const capacidadeSemanal = semana.capacidade_minutos;\r\n        let tempoUsado = 0;\r\n        let ordemNaSemana = 1;\r\n\r\n        // Distribuir cada frente proporcionalmente\r\n        for (const frente of frentes) {\r\n          const cotaFrente = capacidadeSemanal * frente.peso;\r\n          let tempoFrenteUsado = 0;\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n\r\n          while (\r\n            aulaIndex < frente.aulas.length &&\r\n            tempoFrenteUsado + frente.aulas[aulaIndex].custo <= cotaFrente &&\r\n            tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n          ) {\r\n            itens.push({\r\n              cronograma_id: \"\", // Será preenchido após criar cronograma\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoFrenteUsado += frente.aulas[aulaIndex].custo;\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n          }\r\n\r\n          aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n        }\r\n\r\n        // Fallback: Se sobrou tempo, preencher com aulas restantes\r\n        for (const frente of frentes) {\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n          while (\r\n            aulaIndex < frente.aulas.length &&\r\n            tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n          ) {\r\n            itens.push({\r\n              cronograma_id: \"\",\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n          }\r\n          aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n        }\r\n\r\n        // Garantir que pelo menos uma aula seja adicionada se houver aulas disponíveis e capacidade\r\n        if (ordemNaSemana === 1 && capacidadeSemanal > 0) {\r\n          // Nenhuma aula foi adicionada nesta semana, mas há capacidade\r\n          // Tentar adicionar pelo menos uma aula de qualquer frente\r\n          for (const frente of frentes) {\r\n            const aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n            if (\r\n              aulaIndex < frente.aulas.length &&\r\n              tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal\r\n            ) {\r\n              itens.push({\r\n                cronograma_id: \"\",\r\n                aula_id: frente.aulas[aulaIndex].id,\r\n                semana_numero: semana.numero,\r\n                ordem_na_semana: ordemNaSemana++,\r\n              });\r\n              tempoUsado += frente.aulas[aulaIndex].custo;\r\n              aulaIndexPorFrente.set(frente.frente_id, aulaIndex + 1);\r\n              break; // Adicionar apenas uma aula para garantir progresso\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      // Modo Sequencial: Completar uma frente antes de iniciar próxima\r\n      for (const semana of semanasUteis) {\r\n        const capacidadeSemanal = semana.capacidade_minutos;\r\n        let tempoUsado = 0;\r\n        let ordemNaSemana = 1;\r\n\r\n        while (frenteIndex < frentes.length && tempoUsado < capacidadeSemanal) {\r\n          const frente = frentes[frenteIndex];\r\n          let aulaIndex = aulaIndexPorFrente.get(frente.frente_id) ?? 0;\r\n\r\n          if (aulaIndex >= frente.aulas.length) {\r\n            frenteIndex++;\r\n            continue;\r\n          }\r\n\r\n          if (tempoUsado + frente.aulas[aulaIndex].custo <= capacidadeSemanal) {\r\n            itens.push({\r\n              cronograma_id: \"\",\r\n              aula_id: frente.aulas[aulaIndex].id,\r\n              semana_numero: semana.numero,\r\n              ordem_na_semana: ordemNaSemana++,\r\n            });\r\n\r\n            tempoUsado += frente.aulas[aulaIndex].custo;\r\n            aulaIndex++;\r\n            aulaIndexPorFrente.set(frente.frente_id, aulaIndex);\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    console.log(\"[CronogramaService] Distribuição concluída:\", {\r\n      totalItens: itens.length,\r\n      itensPorSemana: itens.reduce(\r\n        (acc, item) => {\r\n          acc[item.semana_numero] = (acc[item.semana_numero] || 0) + 1;\r\n          return acc;\r\n        },\r\n        {} as Record<number, number>,\r\n      ),\r\n    });\r\n\r\n    return itens;\r\n  }\r\n\r\n  private async buscarAulasConcluidas(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    alunoId: string,\r\n    cursoId?: string,\r\n  ): Promise<Set<string>> {\r\n    if (!cursoId) {\r\n      return new Set();\r\n    }\r\n\r\n    const { data, error } = await client\r\n      .from(\"aulas_concluidas\")\r\n      .select(\"aula_id\")\r\n      .eq(\"aluno_id\", alunoId)\r\n      .eq(\"curso_id\", cursoId);\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar aulas concluídas:\",\r\n        error,\r\n      );\r\n    } else if (data && data.length > 0) {\r\n      return new Set(data.map((row) => row.aula_id as string));\r\n    }\r\n\r\n    const { data: historicoData, error: historicoError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\"aula_id, cronogramas!inner(aluno_id, curso_alvo_id)\")\r\n      .eq(\"concluido\", true)\r\n      .eq(\"cronogramas.aluno_id\", alunoId)\r\n      .eq(\"cronogramas.curso_alvo_id\", cursoId);\r\n\r\n    if (historicoError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar histórico de aulas concluídas:\",\r\n        historicoError,\r\n      );\r\n      return new Set();\r\n    }\r\n\r\n    return new Set((historicoData ?? []).map((row) => row.aula_id as string));\r\n  }\r\n\r\n  private async persistirCronograma(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    input: GerarCronogramaInput,\r\n    itens: ItemDistribuicao[],\r\n    empresaId: string,\r\n  ): Promise<CronogramaDetalhado> {\r\n    let cronograma: CronogramaDetalhado | null = null;\r\n\r\n    // Criar registro do cronograma\r\n    const { data: cronogramaData, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .insert({\r\n        empresa_id: empresaId,\r\n        aluno_id: input.aluno_id,\r\n        curso_alvo_id: input.curso_alvo_id || null,\r\n        nome: input.nome || \"Meu Cronograma\",\r\n        data_inicio: input.data_inicio,\r\n        data_fim: input.data_fim,\r\n        dias_estudo_semana: input.dias_semana,\r\n        horas_estudo_dia: input.horas_dia,\r\n        periodos_ferias: (input.ferias ||\r\n          []) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"periodos_ferias\"],\r\n        prioridade_minima: input.prioridade_minima,\r\n        modalidade_estudo: input.modalidade,\r\n        disciplinas_selecionadas:\r\n          input.disciplinas_ids as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"disciplinas_selecionadas\"],\r\n        ordem_frentes_preferencia: (input.ordem_frentes_preferencia ||\r\n          null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"ordem_frentes_preferencia\"],\r\n        modulos_selecionados: (input.modulos_ids?.length\r\n          ? input.modulos_ids\r\n          : null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"modulos_selecionados\"],\r\n        excluir_aulas_concluidas: input.excluir_aulas_concluidas !== false,\r\n        velocidade_reproducao: input.velocidade_reproducao ?? 1.0,\r\n      } as any)\r\n      .select()\r\n      .single();\r\n\r\n    if (cronogramaError || !cronogramaData) {\r\n      console.error(\"[CronogramaService] Erro ao criar cronograma:\", {\r\n        message: cronogramaError?.message,\r\n        details: cronogramaError?.details,\r\n        hint: cronogramaError?.hint,\r\n        code: cronogramaError?.code,\r\n      });\r\n\r\n      // Se for erro 409 (Conflict), lançar erro específico\r\n      if (\r\n        cronogramaError?.code === \"23505\" ||\r\n        cronogramaError?.code === \"PGRST116\"\r\n      ) {\r\n        throw new CronogramaConflictError(\r\n          `Erro ao criar cronograma: ${cronogramaError.message || \"Conflito ao criar cronograma\"}`,\r\n        );\r\n      }\r\n\r\n      // Se o erro mencionar schema cache, limpar cache e tentar novamente\r\n      if (\r\n        cronogramaError?.message?.includes(\"schema cache\") ||\r\n        cronogramaError?.message?.includes(\"Could not find\")\r\n      ) {\r\n        console.warn(\r\n          \"[CronogramaService] Problema com schema cache detectado, limpando cache...\",\r\n        );\r\n        clearDatabaseClientCache();\r\n\r\n        // Tentar inserir sem as colunas que podem estar causando problema\r\n        console.warn(\r\n          \"[CronogramaService] Tentando criar cronograma sem as colunas novas...\",\r\n        );\r\n        const { data: cronogramaFallback, error: fallbackError } = await client\r\n          .from(\"cronogramas\")\r\n          .insert({\r\n            empresa_id: empresaId,\r\n            aluno_id: input.aluno_id,\r\n            curso_alvo_id: input.curso_alvo_id || null,\r\n            nome: input.nome || \"Meu Cronograma\",\r\n            data_inicio: input.data_inicio,\r\n            data_fim: input.data_fim,\r\n            dias_estudo_semana: input.dias_semana,\r\n            horas_estudo_dia: input.horas_dia,\r\n            periodos_ferias: (input.ferias ||\r\n              []) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"periodos_ferias\"],\r\n            prioridade_minima: input.prioridade_minima,\r\n            modalidade_estudo: input.modalidade,\r\n            disciplinas_selecionadas:\r\n              input.disciplinas_ids as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"disciplinas_selecionadas\"],\r\n            ordem_frentes_preferencia: (input.ordem_frentes_preferencia ||\r\n              null) as unknown as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Insert\"][\"ordem_frentes_preferencia\"],\r\n          })\r\n          .select()\r\n          .single();\r\n\r\n        if (fallbackError || !cronogramaFallback) {\r\n          throw new Error(\r\n            `Erro ao criar cronograma: ${fallbackError?.message || cronogramaError?.message || \"Desconhecido\"}`,\r\n          );\r\n        }\r\n\r\n        cronograma = mapToCronogramaDetalhado(cronogramaFallback);\r\n\r\n        // Verificar se cronograma foi criado com sucesso\r\n        if (!cronograma) {\r\n          throw new Error(\"Falha ao criar cronograma no fallback\");\r\n        }\r\n\r\n        // Cronograma confirmado como não-nulo para este bloco\r\n        const cronogramaFallbackConfirmado = cronograma;\r\n\r\n        // Tentar atualizar com as colunas novas separadamente (se existirem)\r\n        try {\r\n          const updateData: Partial<\r\n            Pick<\r\n              CronogramaDetalhado,\r\n              \"modulos_selecionados\" | \"excluir_aulas_concluidas\"\r\n            >\r\n          > = {};\r\n          if (input.modulos_ids?.length) {\r\n            updateData.modulos_selecionados = input.modulos_ids;\r\n          }\r\n          if (input.excluir_aulas_concluidas !== undefined) {\r\n            updateData.excluir_aulas_concluidas =\r\n              input.excluir_aulas_concluidas;\r\n          }\r\n\r\n          if (Object.keys(updateData).length > 0) {\r\n            const { data: cronogramaUpdated, error: updateError } = await client\r\n              .from(\"cronogramas\")\r\n              .update(updateData)\r\n              .eq(\"id\", cronogramaFallbackConfirmado.id)\r\n              .select()\r\n              .single();\r\n\r\n            if (!updateError && cronogramaUpdated) {\r\n              cronograma = mapToCronogramaDetalhado(cronogramaUpdated);\r\n            } else {\r\n              console.warn(\r\n                \"[CronogramaService] Não foi possível atualizar alguns campos novos, mas cronograma foi criado\",\r\n              );\r\n            }\r\n          }\r\n        } catch (updateErr) {\r\n          console.warn(\r\n            \"[CronogramaService] Erro ao atualizar campos novos (ignorado):\",\r\n            updateErr,\r\n          );\r\n        }\r\n      } else {\r\n        throw new Error(\r\n          `Erro ao criar cronograma: ${cronogramaError?.message || \"Desconhecido\"}`,\r\n        );\r\n      }\r\n    } else {\r\n      cronograma = mapToCronogramaDetalhado(cronogramaData);\r\n    }\r\n\r\n    // Verificar se cronograma foi criado com sucesso\r\n    if (!cronograma) {\r\n      throw new Error(\"Falha ao criar cronograma\");\r\n    }\r\n\r\n    // Agora cronograma é garantidamente não-nulo\r\n    const cronogramaConfirmado = cronograma;\r\n\r\n    // IMPORTANTE: Sempre salvar os itens, independente de como o cronograma foi criado\r\n    // Preencher cronograma_id nos itens\r\n    const itensCompleto = itens.map((item) => ({\r\n      ...item,\r\n      cronograma_id: cronogramaConfirmado.id,\r\n    }));\r\n\r\n    console.log(\"[CronogramaService] Inserindo itens do cronograma:\", {\r\n      totalItens: itensCompleto.length,\r\n      cronogramaId: cronogramaConfirmado.id,\r\n      primeirosItens: itensCompleto.slice(0, 3).map((i) => ({\r\n        aula_id: i.aula_id,\r\n        semana_numero: i.semana_numero,\r\n        ordem_na_semana: i.ordem_na_semana,\r\n      })),\r\n    });\r\n\r\n    // Bulk insert dos itens\r\n    const { data: itensInseridos, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .insert(itensCompleto)\r\n      .select(\"id, aula_id, semana_numero, ordem_na_semana\");\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao inserir itens:\", {\r\n        message: itensError.message,\r\n        details: itensError.details,\r\n        hint: itensError.hint,\r\n        code: itensError.code,\r\n        totalItens: itensCompleto.length,\r\n      });\r\n      // Tentar deletar o cronograma criado\r\n      await client\r\n        .from(\"cronogramas\")\r\n        .delete()\r\n        .eq(\"id\", cronogramaConfirmado.id);\r\n      throw new Error(\r\n        `Erro ao inserir itens do cronograma: ${itensError.message}`,\r\n      );\r\n    }\r\n\r\n    console.log(\"[CronogramaService] Itens inseridos com sucesso:\", {\r\n      totalInseridos: itensInseridos?.length || 0,\r\n      esperado: itensCompleto.length,\r\n    });\r\n\r\n    // Criar distribuição padrão de dias\r\n    await this.criarDistribuicaoPadrao(\r\n      client,\r\n      cronogramaConfirmado.id,\r\n      input.dias_semana,\r\n    );\r\n\r\n    // Recalcular datas dos itens baseado na distribuição padrão\r\n    try {\r\n      await this.recalcularDatasItens(cronogramaConfirmado.id, input.aluno_id);\r\n    } catch (recalcError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao recalcular datas (não crítico):\",\r\n        recalcError,\r\n      );\r\n      // Não falhar a criação do cronograma se o recálculo falhar\r\n    }\r\n\r\n    // Buscar cronograma completo com itens\r\n    const { data: cronogramaCompleto, error: fetchError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\r\n        `\r\n        *,\r\n        cronograma_itens(\r\n          id,\r\n          aula_id,\r\n          semana_numero,\r\n          ordem_na_semana,\r\n          concluido,\r\n          aulas(\r\n            id,\r\n            nome,\r\n            numero_aula,\r\n            tempo_estimado_minutos\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"id\", cronogramaConfirmado.id)\r\n      .single();\r\n\r\n    if (fetchError) {\r\n      console.error(\"Erro ao buscar cronograma completo:\", fetchError);\r\n      return cronogramaConfirmado;\r\n    }\r\n\r\n    if (!cronogramaCompleto) {\r\n      return cronogramaConfirmado;\r\n    }\r\n\r\n    return mapToCronogramaDetalhado(\r\n      cronogramaCompleto as Database[\"public\"][\"Tables\"][\"cronogramas\"][\"Row\"],\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Busca a distribuição de dias da semana para um cronograma\r\n   */\r\n  async buscarDistribuicaoDias(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<CronogramaSemanasDias | null> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usuário\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id\")\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma não encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Você só pode acessar seus próprios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar distribuição\r\n    const { data, error } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"*\")\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .maybeSingle();\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar distribuição de dias:\",\r\n        error,\r\n      );\r\n      throw new Error(`Erro ao buscar distribuição de dias: ${error.message}`);\r\n    }\r\n\r\n    if (!data) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      id: data.id,\r\n      cronograma_id: data.cronograma_id,\r\n      dias_semana: data.dias_semana || [],\r\n      created_at: new Date(data.created_at ?? new Date().toISOString()),\r\n      updated_at: new Date(data.updated_at ?? new Date().toISOString()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Salva ou atualiza a distribuição de dias da semana para um cronograma\r\n   */\r\n  async atualizarDistribuicaoDias(\r\n    input: AtualizarDistribuicaoDiasInput,\r\n    userId: string,\r\n  ): Promise<CronogramaSemanasDias> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Validar dias da semana (0-6)\r\n    const diasValidos = input.dias_semana.every((dia) => dia >= 0 && dia <= 6);\r\n    if (!diasValidos || input.dias_semana.length === 0) {\r\n      throw new CronogramaValidationError(\r\n        \"dias_semana deve ser um array de números entre 0 (domingo) e 6 (sábado)\",\r\n      );\r\n    }\r\n\r\n    // Verificar se o cronograma pertence ao usuário\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id, data_inicio\")\r\n      .eq(\"id\", input.cronograma_id)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma não encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Você só pode atualizar seus próprios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Verificar se já existe distribuição\r\n    const { data: existente } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"id\")\r\n      .eq(\"cronograma_id\", input.cronograma_id)\r\n      .maybeSingle();\r\n\r\n    let resultado;\r\n    if (existente) {\r\n      // Atualizar\r\n      const { data, error } = await client\r\n        .from(\"cronograma_semanas_dias\")\r\n        .update({\r\n          dias_semana: input.dias_semana,\r\n        })\r\n        .eq(\"id\", existente.id)\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao atualizar distribuição de dias:\",\r\n          error,\r\n        );\r\n        throw new Error(\r\n          `Erro ao atualizar distribuição de dias: ${error.message}`,\r\n        );\r\n      }\r\n\r\n      resultado = data;\r\n    } else {\r\n      // Criar\r\n      const { data, error } = await client\r\n        .from(\"cronograma_semanas_dias\")\r\n        .insert({\r\n          cronograma_id: input.cronograma_id,\r\n          dias_semana: input.dias_semana,\r\n        })\r\n        .select()\r\n        .single();\r\n\r\n      if (error) {\r\n        console.error(\r\n          \"[CronogramaService] Erro ao criar distribuição de dias:\",\r\n          error,\r\n        );\r\n        throw new Error(`Erro ao criar distribuição de dias: ${error.message}`);\r\n      }\r\n\r\n      resultado = data;\r\n    }\r\n\r\n    // Recalcular datas dos itens\r\n    await this.recalcularDatasItens(input.cronograma_id, userId);\r\n\r\n    return {\r\n      id: resultado.id,\r\n      cronograma_id: resultado.cronograma_id,\r\n      dias_semana: resultado.dias_semana || [],\r\n      created_at: new Date(resultado.created_at ?? new Date().toISOString()),\r\n      updated_at: new Date(resultado.updated_at ?? new Date().toISOString()),\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Recalcula as datas previstas de todos os itens do cronograma\r\n   * baseado na distribuição de dias da semana\r\n   */\r\n  async recalcularDatasItens(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<RecalcularDatasResult> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usuário\r\n    const { data: cronograma, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\"id, aluno_id, data_inicio\")\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronograma) {\r\n      throw new CronogramaValidationError(\"Cronograma não encontrado\");\r\n    }\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Você só pode recalcular datas dos seus próprios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar distribuição de dias\r\n    const { data: distribuicao, error: distError } = await client\r\n      .from(\"cronograma_semanas_dias\")\r\n      .select(\"dias_semana\")\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .maybeSingle();\r\n\r\n    if (distError) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao buscar distribuição de dias:\",\r\n        distError,\r\n      );\r\n      throw new Error(\r\n        `Erro ao buscar distribuição de dias: ${distError.message}`,\r\n      );\r\n    }\r\n\r\n    // Se não houver distribuição, usar padrão (segunda a sexta)\r\n    const diasSemana = distribuicao?.dias_semana || [1, 2, 3, 4, 5];\r\n\r\n    console.log(`[CronogramaService] Distribuição de dias encontrada:`, {\r\n      cronogramaId,\r\n      distribuicaoExiste: !!distribuicao,\r\n      diasSemana,\r\n      diasSemanaTipo: typeof diasSemana,\r\n      diasSemanaIsArray: Array.isArray(diasSemana),\r\n    });\r\n\r\n    // Buscar todos os itens do cronograma com informações de disciplina e frente\r\n    // Necessário para ordenar por disciplina → frente → ordem\r\n    const { data: itens, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\r\n        `\r\n        id, \r\n        semana_numero, \r\n        ordem_na_semana,\r\n        aula_id,\r\n        aulas!inner(\r\n          id,\r\n          modulos!inner(\r\n            id,\r\n            frentes!inner(\r\n              id,\r\n              nome,\r\n              disciplina_id,\r\n              disciplinas!inner(\r\n                id,\r\n                nome\r\n              )\r\n            )\r\n          )\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .order(\"semana_numero\", { ascending: true })\r\n      .order(\"ordem_na_semana\", { ascending: true });\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar itens:\", itensError);\r\n      throw new Error(`Erro ao buscar itens: ${itensError.message}`);\r\n    }\r\n\r\n    if (!itens || itens.length === 0) {\r\n      return { success: true, itens_atualizados: 0 };\r\n    }\r\n\r\n    // Calcular datas agrupando por semana\r\n    const dataInicio = new Date(cronograma.data_inicio);\r\n    const atualizacoes: Array<{ id: string; data_prevista: string }> = [];\r\n\r\n    // Ordenar dias da semana (0=domingo, 1=segunda, ..., 6=sábado)\r\n    const diasOrdenados = [...diasSemana].sort((a, b) => a - b);\r\n\r\n    // Função helper para extrair informações de disciplina e frente de um item\r\n    // Tipo helper para itens com dados aninhados do Supabase\r\n    type ItemComAula = {\r\n      id: string;\r\n      semana_numero: number;\r\n      ordem_na_semana: number;\r\n      aula_id: string;\r\n      aulas: {\r\n        id: string;\r\n        modulos: {\r\n          id: string;\r\n          frentes: {\r\n            id: string;\r\n            nome: string;\r\n            disciplina_id: string | null;\r\n            disciplinas: { id: string; nome: string } | null;\r\n          };\r\n        };\r\n      };\r\n    };\r\n\r\n    const extrairInfoItem = (item: ItemComAula) => {\r\n      // Supabase pode retornar dados aninhados de diferentes formas\r\n      const aula = item.aulas;\r\n      const modulo = aula?.modulos || null;\r\n      const frente = modulo?.frentes || null;\r\n      const disciplina = frente?.disciplinas || null;\r\n\r\n      return {\r\n        disciplinaId: disciplina?.id || \"\",\r\n        disciplinaNome: disciplina?.nome || \"\",\r\n        frenteId: frente?.id || \"\",\r\n        frenteNome: frente?.nome || \"\",\r\n      };\r\n    };\r\n\r\n    // Agrupar itens por semana primeiro\r\n    const itensPorSemana = new Map<number, ItemComAula[]>();\r\n    itens.forEach((item) => {\r\n      const semana = item.semana_numero;\r\n      if (!itensPorSemana.has(semana)) {\r\n        itensPorSemana.set(semana, []);\r\n      }\r\n      itensPorSemana.get(semana)!.push(item);\r\n    });\r\n\r\n    // Função para reorganizar itens de uma semana: alternar entre disciplinas e frentes\r\n    const reorganizarItensPorSemana = (itensDaSemana: ItemComAula[]) => {\r\n      // Extrair informações de cada item\r\n      const itensComInfo = itensDaSemana.map((item) => ({\r\n        ...item,\r\n        info: extrairInfoItem(item),\r\n      }));\r\n\r\n      // Usar tipo inferido do array\r\n      type ItemComInfo = (typeof itensComInfo)[0];\r\n\r\n      // Agrupar por frente (todas as Frentes A, depois todas as Frentes B, etc.)\r\n      const itensPorFrente = new Map<string, ItemComInfo[]>();\r\n      itensComInfo.forEach((item) => {\r\n        const frenteKey = `${item.info.disciplinaNome}_${item.info.frenteNome}`;\r\n        if (!itensPorFrente.has(frenteKey)) {\r\n          itensPorFrente.set(frenteKey, []);\r\n        }\r\n        itensPorFrente.get(frenteKey)!.push(item);\r\n      });\r\n\r\n      // Ordenar itens dentro de cada grupo por ordem_na_semana\r\n      itensPorFrente.forEach((itensGrupo) => {\r\n        itensGrupo.sort((a, b) => a.ordem_na_semana - b.ordem_na_semana);\r\n      });\r\n\r\n      // Agrupar por nome da frente (todas as Frentes A, depois todas as Frentes B, etc.)\r\n      // Isso permite alternar entre disciplinas dentro da mesma frente\r\n      const frentesPorNome = new Map<string, ItemComInfo[][]>();\r\n      itensPorFrente.forEach((itens) => {\r\n        const frenteNome = itens[0].info.frenteNome;\r\n        if (!frentesPorNome.has(frenteNome)) {\r\n          frentesPorNome.set(frenteNome, []);\r\n        }\r\n        frentesPorNome.get(frenteNome)!.push(itens);\r\n      });\r\n\r\n      // Ordenar nomes das frentes alfabeticamente (Frente A, Frente B, etc.)\r\n      const frentesNomes = Array.from(frentesPorNome.keys()).sort();\r\n\r\n      // Reorganizar: distribuir round-robin entre disciplinas dentro de cada frente\r\n      // Processar todas as Frentes A primeiro, depois todas as Frentes B, etc.\r\n      const itensReorganizados: ItemComInfo[] = [];\r\n\r\n      for (const frenteNome of frentesNomes) {\r\n        const gruposFrente = frentesPorNome.get(frenteNome)!;\r\n\r\n        // Ordenar grupos por disciplina para garantir ordem consistente\r\n        gruposFrente.sort((grupoA, grupoB) => {\r\n          const disciplinaA = grupoA[0].info.disciplinaNome;\r\n          const disciplinaB = grupoB[0].info.disciplinaNome;\r\n          return disciplinaA.localeCompare(disciplinaB);\r\n        });\r\n\r\n        // Encontrar o máximo de itens em qualquer grupo desta frente\r\n        const maxItens = Math.max(...gruposFrente.map((grupo) => grupo.length));\r\n\r\n        // Distribuir round-robin: pegar um item de cada disciplina por vez\r\n        // Exemplo: Disc1 Aula1, Disc2 Aula1, Disc3 Aula1, Disc1 Aula2, Disc2 Aula2, etc.\r\n        for (let i = 0; i < maxItens; i++) {\r\n          for (const grupo of gruposFrente) {\r\n            if (i < grupo.length) {\r\n              const item = grupo[i];\r\n              itensReorganizados.push(item);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return itensReorganizados;\r\n    };\r\n\r\n    // Contador para debug: distribuição de itens por dia da semana e por semana\r\n    const contadorPorDia: Record<number, number> = {\r\n      0: 0,\r\n      1: 0,\r\n      2: 0,\r\n      3: 0,\r\n      4: 0,\r\n      5: 0,\r\n      6: 0,\r\n    };\r\n    const contadorPorSemana: Record<number, Record<number, number>> = {};\r\n\r\n    logDebug(`[CronogramaService] Iniciando distribuição por semana:`, {\r\n      totalItens: itens.length,\r\n      totalSemanas: itensPorSemana.size,\r\n      diasSelecionados: diasOrdenados,\r\n      itensPorSemana: Array.from(itensPorSemana.entries()).map(\r\n        ([semana, itens]) => ({\r\n          semana,\r\n          totalItens: itens.length,\r\n        }),\r\n      ),\r\n    });\r\n\r\n    // Processar cada semana separadamente\r\n    Array.from(itensPorSemana.entries())\r\n      .sort(([a], [b]) => a - b) // Ordenar por número da semana\r\n      .forEach(([semanaNumero, itensDaSemanaOriginal]) => {\r\n        // Reorganizar itens para alternar entre disciplinas e frentes\r\n        const itensDaSemana = reorganizarItensPorSemana(itensDaSemanaOriginal);\r\n        // Calcular data base da semana: data_inicio + (semana_numero - 1) * 7 dias\r\n        const dataBaseSemana = new Date(dataInicio);\r\n        dataBaseSemana.setDate(\r\n          dataBaseSemana.getDate() + (semanaNumero - 1) * 7,\r\n        );\r\n\r\n        // Calcular o período da semana do cronograma (7 dias a partir da data base)\r\n        const dataFimSemana = new Date(dataBaseSemana);\r\n        dataFimSemana.setDate(dataFimSemana.getDate() + 6);\r\n\r\n        const diaSemanaBase = dataBaseSemana.getDay();\r\n\r\n        // Encontrar quais dias selecionados caem dentro desta semana do cronograma\r\n        // A semana do cronograma vai de dataBaseSemana até dataFimSemana (7 dias)\r\n        const diasNaSemana: number[] = [];\r\n        for (let d = 0; d < 7; d++) {\r\n          const diaSemana = (diaSemanaBase + d) % 7;\r\n          if (diasOrdenados.includes(diaSemana)) {\r\n            diasNaSemana.push(diaSemana);\r\n          }\r\n        }\r\n\r\n        // Se não houver dias selecionados nesta semana, usar todos os dias selecionados\r\n        // (mas isso não deveria acontecer)\r\n        const diasParaUsar =\r\n          diasNaSemana.length > 0 ? diasNaSemana : diasOrdenados;\r\n        const numDiasParaUsar = diasParaUsar.length;\r\n\r\n        // Ordenar os dias para usar na ordem correta\r\n        const diasParaUsarOrdenados = [...diasParaUsar].sort((a, b) => {\r\n          const indexA = diasOrdenados.indexOf(a);\r\n          const indexB = diasOrdenados.indexOf(b);\r\n          return indexA - indexB;\r\n        });\r\n\r\n        // Dividir itens da semana igualmente entre os dias selecionados desta semana\r\n        const totalItensSemana = itensDaSemana.length;\r\n        const itensPorDia = Math.floor(totalItensSemana / numDiasParaUsar);\r\n        const itensRestantes = totalItensSemana % numDiasParaUsar;\r\n\r\n        logDebug(`[CronogramaService] Processando semana ${semanaNumero}:`, {\r\n          totalItens: totalItensSemana,\r\n          itensPorDia,\r\n          itensRestantes,\r\n          dataBaseSemana: dataBaseSemana.toISOString().split(\"T\")[0],\r\n          dataFimSemana: dataFimSemana.toISOString().split(\"T\")[0],\r\n          diaSemanaBase,\r\n          diasNaSemana,\r\n          diasParaUsar: diasParaUsarOrdenados,\r\n          numDiasParaUsar,\r\n        });\r\n\r\n        // Inicializar contador para esta semana\r\n        contadorPorSemana[semanaNumero] = {\r\n          0: 0,\r\n          1: 0,\r\n          2: 0,\r\n          3: 0,\r\n          4: 0,\r\n          5: 0,\r\n          6: 0,\r\n        };\r\n\r\n        let indiceItem = 0;\r\n\r\n        // Distribuir itens para cada dia selecionado que cai nesta semana\r\n        for (let i = 0; i < numDiasParaUsar; i++) {\r\n          const diaSemanaEscolhido = diasParaUsarOrdenados[i];\r\n\r\n          // Calcular quantos itens este dia receberá\r\n          // Os primeiros dias recebem um item extra se houver resto\r\n          const quantidadeItensParaEsteDia =\r\n            itensPorDia + (i < itensRestantes ? 1 : 0);\r\n\r\n          // Calcular a data deste dia na semana\r\n          // Encontrar a primeira ocorrência do dia escolhido dentro do período de 7 dias\r\n          const dataDiaSemana = new Date(dataBaseSemana);\r\n          let diasParaAdicionar = diaSemanaEscolhido - diaSemanaBase;\r\n\r\n          // Se o dia escolhido já passou na semana base, está na próxima semana do calendário\r\n          // mas ainda dentro do período de 7 dias da semana do cronograma\r\n          if (diasParaAdicionar < 0) {\r\n            diasParaAdicionar += 7;\r\n          }\r\n\r\n          dataDiaSemana.setDate(dataDiaSemana.getDate() + diasParaAdicionar);\r\n\r\n          // Verificar se a data está dentro do período de 7 dias da semana do cronograma\r\n          if (dataDiaSemana < dataBaseSemana || dataDiaSemana > dataFimSemana) {\r\n            logError(\r\n              `[CronogramaService] ⚠️ Data calculada está fora do período da semana ${semanaNumero}:`,\r\n              {\r\n                dataBaseSemana: dataBaseSemana.toISOString().split(\"T\")[0],\r\n                dataFimSemana: dataFimSemana.toISOString().split(\"T\")[0],\r\n                dataCalculada: dataDiaSemana.toISOString().split(\"T\")[0],\r\n                diaSemanaEscolhido,\r\n                diaSemanaBase,\r\n                diasParaAdicionar,\r\n              },\r\n            );\r\n            // Ajustar para ficar dentro do período (usar data base como fallback)\r\n            dataDiaSemana.setTime(dataBaseSemana.getTime());\r\n          }\r\n\r\n          // Atribuir itens a este dia\r\n          for (\r\n            let j = 0;\r\n            j < quantidadeItensParaEsteDia && indiceItem < totalItensSemana;\r\n            j++\r\n          ) {\r\n            const item = itensDaSemana[indiceItem];\r\n\r\n            // Garantir formato YYYY-MM-DD consistente (sem conversão UTC)\r\n            const year = dataDiaSemana.getFullYear();\r\n            const month = String(dataDiaSemana.getMonth() + 1).padStart(2, \"0\");\r\n            const day = String(dataDiaSemana.getDate()).padStart(2, \"0\");\r\n            const dataPrevistaFormatada = `${year}-${month}-${day}`;\r\n\r\n            atualizacoes.push({\r\n              id: item.id,\r\n              data_prevista: dataPrevistaFormatada,\r\n            });\r\n\r\n            // Contar para debug\r\n            contadorPorDia[diaSemanaEscolhido] += 1;\r\n            contadorPorSemana[semanaNumero][diaSemanaEscolhido] += 1;\r\n\r\n            indiceItem++;\r\n\r\n            // Log detalhado para primeiros itens de cada semana\r\n            if (indiceItem <= 3 || j === 0) {\r\n              logDebug(\r\n                `[CronogramaService] Semana ${semanaNumero}, Item ${indiceItem}/${totalItensSemana}:`,\r\n                {\r\n                  itemId: item.id,\r\n                  ordem_na_semana: item.ordem_na_semana,\r\n                  diaSemana: diaSemanaEscolhido,\r\n                  data_prevista: dataPrevistaFormatada,\r\n                  quantidadeItensParaEsteDia,\r\n                },\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        // Verificar se todos os itens da semana foram distribuídos\r\n        if (indiceItem !== totalItensSemana) {\r\n          logError(\r\n            `[CronogramaService] ⚠️ Erro: Nem todos os itens da semana ${semanaNumero} foram distribuídos!`,\r\n            {\r\n              esperado: totalItensSemana,\r\n              distribuido: indiceItem,\r\n            },\r\n          );\r\n        }\r\n      });\r\n\r\n    // Log da distribuição final por dia da semana e por semana\r\n    const totalItens = Object.values(contadorPorDia).reduce((a, b) => a + b, 0);\r\n    const itensPorDiaSelecionado = diasOrdenados.map((dia) => ({\r\n      dia: [\r\n        \"domingo\",\r\n        \"segunda\",\r\n        \"terca\",\r\n        \"quarta\",\r\n        \"quinta\",\r\n        \"sexta\",\r\n        \"sabado\",\r\n      ][dia],\r\n      valor: dia,\r\n      quantidade: contadorPorDia[dia],\r\n      percentual:\r\n        totalItens > 0\r\n          ? ((contadorPorDia[dia] / totalItens) * 100).toFixed(1) + \"%\"\r\n          : \"0%\",\r\n    }));\r\n\r\n    logDebug(`[CronogramaService] Distribuição final por dia da semana:`, {\r\n      total: totalItens,\r\n      dias_selecionados: diasOrdenados,\r\n      distribuicao_por_dia: itensPorDiaSelecionado,\r\n    });\r\n\r\n    // Log da distribuição por semana\r\n    logDebug(\r\n      `[CronogramaService] Distribuição por semana:`,\r\n      Array.from(Object.entries(contadorPorSemana)).map(\r\n        ([semana, contadores]) => ({\r\n          semana: Number(semana),\r\n          totalItens: Object.values(contadores).reduce((a, b) => a + b, 0),\r\n          porDia: diasOrdenados.map((dia) => ({\r\n            dia: [\r\n              \"domingo\",\r\n              \"segunda\",\r\n              \"terca\",\r\n              \"quarta\",\r\n              \"quinta\",\r\n              \"sexta\",\r\n              \"sabado\",\r\n            ][dia],\r\n            quantidade: contadores[dia] || 0,\r\n          })),\r\n        }),\r\n      ),\r\n    );\r\n\r\n    // Atualizar itens em lote usando chunks para melhor performance\r\n    // Processar em lotes de 100 itens por vez\r\n    const CHUNK_SIZE = 100;\r\n    let itensAtualizados = 0;\r\n    const erros: Array<{ id: string; error: string }> = [];\r\n\r\n    // Processar em chunks\r\n    for (let i = 0; i < atualizacoes.length; i += CHUNK_SIZE) {\r\n      const chunk = atualizacoes.slice(i, i + CHUNK_SIZE);\r\n\r\n      // Usar Promise.all para processar chunk em paralelo\r\n      const resultados = await Promise.allSettled(\r\n        chunk.map(async (atualizacao) => {\r\n          const { error: updateError } = await client\r\n            .from(\"cronograma_itens\")\r\n            .update({ data_prevista: atualizacao.data_prevista })\r\n            .eq(\"id\", atualizacao.id);\r\n\r\n          if (updateError) {\r\n            throw new Error(`Item ${atualizacao.id}: ${updateError.message}`);\r\n          }\r\n          return atualizacao.id;\r\n        }),\r\n      );\r\n\r\n      // Contar sucessos e erros\r\n      resultados.forEach((resultado, index) => {\r\n        if (resultado.status === \"fulfilled\") {\r\n          itensAtualizados++;\r\n        } else {\r\n          const atualizacao = chunk[index];\r\n          erros.push({\r\n            id: atualizacao.id,\r\n            error: resultado.reason?.message || \"Erro desconhecido\",\r\n          });\r\n          console.error(\r\n            `[CronogramaService] Erro ao atualizar item ${atualizacao.id}:`,\r\n            resultado.reason,\r\n          );\r\n        }\r\n      });\r\n    }\r\n\r\n    // Validação de integridade: verificar se todos os itens foram atualizados\r\n    if (itensAtualizados < atualizacoes.length) {\r\n      console.warn(\r\n        `[CronogramaService] ⚠️ Apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados`,\r\n      );\r\n      console.warn(\r\n        `[CronogramaService] Erros encontrados:`,\r\n        erros.slice(0, 10),\r\n      ); // Logar apenas primeiros 10 erros\r\n\r\n      // Se menos de 90% dos itens foram atualizados, considerar como falha crítica\r\n      const taxaSucesso = itensAtualizados / atualizacoes.length;\r\n      if (taxaSucesso < 0.9) {\r\n        logError(\r\n          `[CronogramaService] Falha crítica: apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados (${(taxaSucesso * 100).toFixed(1)}%)`,\r\n        );\r\n        throw new Error(\r\n          `Falha ao atualizar datas: apenas ${itensAtualizados} de ${atualizacoes.length} itens foram atualizados (${(taxaSucesso * 100).toFixed(1)}%)`,\r\n        );\r\n      }\r\n    }\r\n\r\n    logDebug(\r\n      `[CronogramaService] Datas recalculadas: ${itensAtualizados} de ${atualizacoes.length} itens`,\r\n    );\r\n\r\n    return { success: true, itens_atualizados: itensAtualizados };\r\n  }\r\n\r\n  /**\r\n   * Calcula estatísticas detalhadas por semana do cronograma\r\n   */\r\n  async calcularEstatisticasPorSemana(\r\n    cronogramaId: string,\r\n    userId: string,\r\n  ): Promise<EstatisticasSemanasResult> {\r\n    const client = getDatabaseClient();\r\n\r\n    // Verificar se o cronograma pertence ao usuário\r\n    const { data: cronogramaRaw, error: cronogramaError } = await client\r\n      .from(\"cronogramas\")\r\n      .select(\r\n        \"id, aluno_id, data_inicio, data_fim, horas_estudo_dia, dias_estudo_semana, periodos_ferias\",\r\n      )\r\n      .eq(\"id\", cronogramaId)\r\n      .single();\r\n\r\n    if (cronogramaError || !cronogramaRaw) {\r\n      throw new CronogramaValidationError(\"Cronograma não encontrado\");\r\n    }\r\n\r\n    const cronograma = cronogramaRaw as {\r\n      id: string;\r\n      aluno_id: string;\r\n      data_inicio: string;\r\n      data_fim: string;\r\n      horas_estudo_dia: number;\r\n      dias_estudo_semana: number;\r\n      periodos_ferias: unknown;\r\n    };\r\n\r\n    if (cronograma.aluno_id !== userId) {\r\n      throw new CronogramaValidationError(\r\n        \"Você só pode acessar seus próprios cronogramas\",\r\n      );\r\n    }\r\n\r\n    // Buscar todos os itens do cronograma com suas aulas\r\n    const { data: itens, error: itensError } = await client\r\n      .from(\"cronograma_itens\")\r\n      .select(\r\n        `\r\n        id,\r\n        semana_numero,\r\n        ordem_na_semana,\r\n        concluido,\r\n        aula_id,\r\n        aulas(\r\n          id,\r\n          tempo_estimado_minutos\r\n        )\r\n      `,\r\n      )\r\n      .eq(\"cronograma_id\", cronogramaId)\r\n      .order(\"semana_numero\", { ascending: true })\r\n      .order(\"ordem_na_semana\", { ascending: true });\r\n\r\n    if (itensError) {\r\n      console.error(\"[CronogramaService] Erro ao buscar itens:\", itensError);\r\n      throw new Error(`Erro ao buscar itens: ${itensError.message}`);\r\n    }\r\n\r\n    // Calcular semanas (mesma lógica do calcularSemanas)\r\n    const dataInicio = new Date(cronograma.data_inicio);\r\n    const dataFim = new Date(cronograma.data_fim);\r\n    const ferias =\r\n      (cronograma.periodos_ferias as unknown as FeriasPeriodo[]) || [];\r\n    const horasDia = cronograma.horas_estudo_dia || 0;\r\n    const diasSemana = cronograma.dias_estudo_semana || 0;\r\n    const velocidadeReproducao = cronograma.velocidade_reproducao ?? 1.0;\r\n\r\n    const semanas = this.calcularSemanas(\r\n      dataInicio,\r\n      dataFim,\r\n      ferias,\r\n      horasDia,\r\n      diasSemana,\r\n    );\r\n\r\n    // Agrupar itens por semana\r\n    // Tipo helper para itens com dados aninhados do Supabase\r\n    type ItemComDados = {\r\n      id: string;\r\n      semana_numero: number;\r\n      ordem_na_semana: number;\r\n      concluido?: boolean | null;\r\n      aula_id: string;\r\n      aulas?: {\r\n        id: string;\r\n        tempo_estimado_minutos?: number | null;\r\n      } | null;\r\n    };\r\n\r\n    const itensPorSemana = new Map<number, ItemComDados[]>();\r\n    ((itens as unknown as ItemComDados[]) || []).forEach((item) => {\r\n      const semanaNum = item.semana_numero;\r\n      if (!itensPorSemana.has(semanaNum)) {\r\n        itensPorSemana.set(semanaNum, []);\r\n      }\r\n      itensPorSemana.get(semanaNum)!.push(item);\r\n    });\r\n\r\n    // Calcular estatísticas para cada semana\r\n    const semanasEstatisticas: SemanaEstatisticas[] = semanas.map((semana) => {\r\n      const itensDaSemana = itensPorSemana.get(semana.numero) || [];\r\n\r\n      // Calcular tempo usado (soma dos custos das aulas)\r\n      let tempoUsado = 0;\r\n      let totalAulas = 0;\r\n      let aulasConcluidas = 0;\r\n\r\n      itensDaSemana.forEach((item) => {\r\n        const aula = Array.isArray(item.aulas) ? item.aulas[0] : item.aulas;\r\n        if (!aula) return;\r\n\r\n        totalAulas++;\r\n        if (item.concluido) {\r\n          aulasConcluidas++;\r\n        }\r\n\r\n        // Calcular custo (mesma lógica do gerarCronograma)\r\n        const tempoOriginal =\r\n          aula.tempo_estimado_minutos ?? TEMPO_PADRAO_MINUTOS;\r\n        const tempoAulaAjustado = tempoOriginal / velocidadeReproducao;\r\n        const custo = tempoAulaAjustado * FATOR_MULTIPLICADOR;\r\n        tempoUsado += custo;\r\n      });\r\n\r\n      const capacidade = semana.capacidade_minutos;\r\n      const tempoDisponivel = Math.max(0, capacidade - tempoUsado);\r\n      const percentualUsado =\r\n        capacidade > 0 ? (tempoUsado / capacidade) * 100 : 0;\r\n      const aulasPendentes = totalAulas - aulasConcluidas;\r\n\r\n      return {\r\n        semana_numero: semana.numero,\r\n        data_inicio: semana.data_inicio.toISOString(),\r\n        data_fim: semana.data_fim.toISOString(),\r\n        capacidade_minutos: capacidade,\r\n        tempo_usado_minutos: Math.round(tempoUsado * 100) / 100, // Arredondar para 2 casas decimais\r\n        tempo_disponivel_minutos: Math.round(tempoDisponivel * 100) / 100,\r\n        percentual_usado: Math.round(percentualUsado * 100) / 100,\r\n        is_ferias: semana.is_ferias,\r\n        total_aulas: totalAulas,\r\n        aulas_concluidas: aulasConcluidas,\r\n        aulas_pendentes: aulasPendentes,\r\n      };\r\n    });\r\n\r\n    // Calcular resumo geral\r\n    const semanasUteis = semanasEstatisticas.filter((s) => !s.is_ferias);\r\n    const capacidadeTotal = semanasUteis.reduce(\r\n      (acc, s) => acc + s.capacidade_minutos,\r\n      0,\r\n    );\r\n    const tempoTotalUsado = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.tempo_usado_minutos,\r\n      0,\r\n    );\r\n    const tempoTotalDisponivel = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.tempo_disponivel_minutos,\r\n      0,\r\n    );\r\n    const percentualMedioUsado =\r\n      semanasUteis.length > 0\r\n        ? semanasUteis.reduce((acc, s) => acc + s.percentual_usado, 0) /\r\n          semanasUteis.length\r\n        : 0;\r\n    const totalAulas = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.total_aulas,\r\n      0,\r\n    );\r\n    const totalAulasConcluidas = semanasEstatisticas.reduce(\r\n      (acc, s) => acc + s.aulas_concluidas,\r\n      0,\r\n    );\r\n    const semanasSobrecarregadas = semanasEstatisticas.filter(\r\n      (s) => s.percentual_usado > 100,\r\n    ).length;\r\n\r\n    return {\r\n      success: true,\r\n      semanas: semanasEstatisticas,\r\n      resumo: {\r\n        total_semanas: semanasEstatisticas.length,\r\n        semanas_uteis: semanasUteis.length,\r\n        semanas_ferias: semanasEstatisticas.length - semanasUteis.length,\r\n        capacidade_total_minutos: Math.round(capacidadeTotal * 100) / 100,\r\n        tempo_total_usado_minutos: Math.round(tempoTotalUsado * 100) / 100,\r\n        tempo_total_disponivel_minutos:\r\n          Math.round(tempoTotalDisponivel * 100) / 100,\r\n        percentual_medio_usado: Math.round(percentualMedioUsado * 100) / 100,\r\n        total_aulas: totalAulas,\r\n        total_aulas_concluidas: totalAulasConcluidas,\r\n        semanas_sobrecarregadas: semanasSobrecarregadas,\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cria distribuição padrão ao gerar um novo cronograma\r\n   */\r\n  private async criarDistribuicaoPadrao(\r\n    client: ReturnType<typeof getDatabaseClient>,\r\n    cronogramaId: string,\r\n    diasEstudoSemana: number,\r\n  ): Promise<void> {\r\n    // Calcular dias padrão baseado em dias_estudo_semana\r\n    // Se dias_estudo_semana = 5, usar segunda a sexta [1,2,3,4,5]\r\n    // Se dias_estudo_semana = 3, usar segunda, quarta, sexta [1,3,5]\r\n    // etc.\r\n    let diasPadrao: number[] = [];\r\n\r\n    if (diasEstudoSemana >= 5) {\r\n      diasPadrao = [1, 2, 3, 4, 5]; // Segunda a sexta\r\n    } else if (diasEstudoSemana === 4) {\r\n      diasPadrao = [1, 2, 4, 5]; // Segunda, terça, quinta, sexta\r\n    } else if (diasEstudoSemana === 3) {\r\n      diasPadrao = [1, 3, 5]; // Segunda, quarta, sexta\r\n    } else if (diasEstudoSemana === 2) {\r\n      diasPadrao = [1, 4]; // Segunda e quinta\r\n    } else {\r\n      diasPadrao = [1]; // Apenas segunda\r\n    }\r\n\r\n    const { error } = await client.from(\"cronograma_semanas_dias\").insert({\r\n      cronograma_id: cronogramaId,\r\n      dias_semana: diasPadrao,\r\n    });\r\n\r\n    if (error) {\r\n      console.error(\r\n        \"[CronogramaService] Erro ao criar distribuição padrão:\",\r\n        error,\r\n      );\r\n      // Não lançar erro, apenas logar - a distribuição pode ser criada depois\r\n    } else {\r\n      console.log(\r\n        \"[CronogramaService] Distribuição padrão criada:\",\r\n        diasPadrao,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nexport const cronogramaService = new CronogramaService();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\auth-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":486,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15383,15386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15383,15386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Auth Pattern Analyzer\r\n *\r\n * Analyzes authentication and authorization patterns in the codebase\r\n * to identify inconsistencies, redundancies, and unnecessary complexity.\r\n *\r\n * Detects:\r\n * - Multiple auth client instantiation patterns\r\n * - Inconsistent permission checking approaches\r\n * - Inconsistent session management\r\n * - Redundant auth middleware\r\n * - Unnecessary auth wrapper functions\r\n */\r\n\r\nimport { SourceFile, Node, ArrowFunction } from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Pattern for tracking auth client instantiation\r\n */\r\ninterface AuthClientPattern {\r\n  functionName: string;\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking permission checks\r\n */\r\ninterface PermissionCheckPattern {\r\n  type: \"role\" | \"permission\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Pattern for tracking session management\r\n */\r\ninterface SessionPattern {\r\n  type: \"cookie\" | \"token\" | \"supabase\" | \"custom\";\r\n  node: Node;\r\n  file: string;\r\n}\r\n\r\n/**\r\n * Analyzer for authentication and authorization patterns\r\n */\r\nexport class AuthPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"AuthPatternAnalyzer\";\r\n\r\n  private authClientPatterns: AuthClientPattern[] = [];\r\n  private permissionCheckPatterns: PermissionCheckPattern[] = [];\r\n  private sessionPatterns: SessionPattern[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"api-route\", \"service\", \"middleware\", \"util\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for auth-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 5.1: Detect auth client instantiation patterns\r\n    issues.push(...this.detectAuthClientPatterns(file, ast));\r\n\r\n    // Task 5.2: Detect auth inconsistencies\r\n    issues.push(...this.detectAuthInconsistencies(file, ast));\r\n\r\n    // Task 5.3: Detect unnecessary auth adapters\r\n    issues.push(...this.detectUnnecessaryAuthAdapters(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.1: Auth Client Instantiation Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect multiple patterns for creating auth clients\r\n   * Validates Requirements: 2.1\r\n   */\r\n  private detectAuthClientPatterns(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Common auth client creation patterns\r\n    const authClientPatterns = [\r\n      \"createClient\",\r\n      \"getSupabaseClient\",\r\n      \"initSupabase\",\r\n      \"createSupabaseClient\",\r\n      \"getAuthClient\",\r\n      \"initAuth\",\r\n      \"createAuthClient\",\r\n      \"supabaseClient\",\r\n      \"getClient\",\r\n      \"initClient\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Check if this is an auth client creation call\r\n      for (const pattern of authClientPatterns) {\r\n        if (callText.includes(pattern)) {\r\n          // Track this pattern\r\n          this.authClientPatterns.push({\r\n            functionName: pattern,\r\n            node: call,\r\n            file: file.relativePath,\r\n          });\r\n\r\n          // If we've seen multiple different patterns, flag as inconsistent\r\n          const uniquePatterns = new Set(\r\n            this.authClientPatterns.map((p) => p.functionName),\r\n          );\r\n          if (uniquePatterns.size > 1) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: \"inconsistent-pattern\",\r\n                severity: \"medium\",\r\n                category: \"authentication\",\r\n                file: file.relativePath,\r\n                node: call,\r\n                description: `Inconsistent auth client instantiation pattern detected. Found ${uniquePatterns.size} different patterns: ${Array.from(uniquePatterns).join(\", \")}`,\r\n                recommendation:\r\n                  \"Standardize auth client creation to use a single pattern across the codebase. Consider creating a centralized auth client factory function.\",\r\n                estimatedEffort: \"medium\",\r\n                tags: [\"auth\", \"inconsistency\", \"client-instantiation\"],\r\n              }),\r\n            );\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.2: Auth Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent permission checking, session management, and redundant middleware\r\n   * Validates Requirements: 2.2, 2.3, 2.4\r\n   */\r\n  private detectAuthInconsistencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect inconsistent permission checking\r\n    issues.push(...this.detectInconsistentPermissionChecks(file, ast));\r\n\r\n    // Detect inconsistent session management\r\n    issues.push(...this.detectInconsistentSessionManagement(file, ast));\r\n\r\n    // Detect redundant auth middleware\r\n    issues.push(...this.detectRedundantAuthMiddleware(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent permission checking patterns\r\n   * Validates Requirements: 2.2\r\n   */\r\n  private detectInconsistentPermissionChecks(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Permission checking patterns\r\n    const roleCheckPatterns = [\r\n      \"checkRole\",\r\n      \"hasRole\",\r\n      \"isRole\",\r\n      \"role ===\",\r\n      \"role ==\",\r\n    ];\r\n    const permissionCheckPatterns = [\r\n      \"checkPermission\",\r\n      \"hasPermission\",\r\n      \"can\",\r\n      \"permissions.includes\",\r\n    ];\r\n    const customCheckPatterns = [\r\n      \"checkAuth\",\r\n      \"isAuthorized\",\r\n      \"authorize\",\r\n      \"verifyAccess\",\r\n    ];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of permission check\r\n      let checkType: \"role\" | \"permission\" | \"custom\" | null = null;\r\n\r\n      if (roleCheckPatterns.some((pattern) => callText.includes(pattern))) {\r\n        checkType = \"role\";\r\n      } else if (\r\n        permissionCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"permission\";\r\n      } else if (\r\n        customCheckPatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        checkType = \"custom\";\r\n      }\r\n\r\n      if (checkType) {\r\n        this.permissionCheckPatterns.push({\r\n          type: checkType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different check types, flag as inconsistent\r\n        const uniqueCheckTypes = new Set(\r\n          this.permissionCheckPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueCheckTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent permission checking approach detected. Found ${uniqueCheckTypes.size} different approaches: ${Array.from(uniqueCheckTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize permission checking to use a single approach (either role-based, permission-based, or a custom unified approach). This improves maintainability and reduces security risks.\",\r\n              estimatedEffort: \"medium\",\r\n              tags: [\"auth\", \"permissions\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent session management\r\n   * Validates Requirements: 2.4\r\n   */\r\n  private detectInconsistentSessionManagement(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const callExpressions = this.getCallExpressions(ast);\r\n\r\n    // Session management patterns\r\n    const cookiePatterns = [\"cookies()\", \"getCookie\", \"setCookie\", \"cookie.\"];\r\n    const tokenPatterns = [\"getToken\", \"setToken\", \"token\", \"jwt\", \"bearer\"];\r\n    const supabasePatterns = [\r\n      \"getSession\",\r\n      \"setSession\",\r\n      \"session.user\",\r\n      \"auth.getUser\",\r\n    ];\r\n    const customPatterns = [\"getAuth\", \"setAuth\", \"authSession\"];\r\n\r\n    for (const call of callExpressions) {\r\n      const callText = call.getText();\r\n\r\n      // Identify the type of session management\r\n      let sessionType: \"cookie\" | \"token\" | \"supabase\" | \"custom\" | null = null;\r\n\r\n      if (cookiePatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"cookie\";\r\n      } else if (tokenPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"token\";\r\n      } else if (\r\n        supabasePatterns.some((pattern) => callText.includes(pattern))\r\n      ) {\r\n        sessionType = \"supabase\";\r\n      } else if (customPatterns.some((pattern) => callText.includes(pattern))) {\r\n        sessionType = \"custom\";\r\n      }\r\n\r\n      if (sessionType) {\r\n        this.sessionPatterns.push({\r\n          type: sessionType,\r\n          node: call,\r\n          file: file.relativePath,\r\n        });\r\n\r\n        // If we've seen multiple different session types, flag as inconsistent\r\n        const uniqueSessionTypes = new Set(\r\n          this.sessionPatterns.map((p) => p.type),\r\n        );\r\n        if (uniqueSessionTypes.size > 1) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"high\",\r\n              category: \"authentication\",\r\n              file: file.relativePath,\r\n              node: call,\r\n              description: `Inconsistent session management detected. Found ${uniqueSessionTypes.size} different approaches: ${Array.from(uniqueSessionTypes).join(\", \")}`,\r\n              recommendation:\r\n                \"Standardize session management to use a single approach. For Supabase projects, prefer using Supabase's built-in session management.\",\r\n              estimatedEffort: \"large\",\r\n              tags: [\"auth\", \"session\", \"inconsistency\", \"security\"],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect redundant auth middleware\r\n   * Validates Requirements: 2.3\r\n   */\r\n  private detectRedundantAuthMiddleware(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Only check middleware files\r\n    if (\r\n      file.category !== \"middleware\" &&\r\n      !file.relativePath.includes(\"middleware\")\r\n    ) {\r\n      return issues;\r\n    }\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    // Track middleware functions that perform auth checks\r\n    const authMiddlewareFunctions: Node[] = [];\r\n\r\n    for (const func of functions) {\r\n      const funcText = func.getText();\r\n\r\n      // Check if this function performs auth checks\r\n      const authKeywords = [\r\n        \"auth\",\r\n        \"authenticate\",\r\n        \"authorize\",\r\n        \"checkAuth\",\r\n        \"verifyAuth\",\r\n        \"getUser\",\r\n        \"getSession\",\r\n        \"checkPermission\",\r\n        \"checkRole\",\r\n      ];\r\n\r\n      if (\r\n        authKeywords.some((keyword) =>\r\n          funcText.toLowerCase().includes(keyword.toLowerCase()),\r\n        )\r\n      ) {\r\n        authMiddlewareFunctions.push(func);\r\n      }\r\n    }\r\n\r\n    // If we have multiple auth middleware functions in the same file, flag as redundant\r\n    if (authMiddlewareFunctions.length > 1) {\r\n      for (const func of authMiddlewareFunctions) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"code-duplication\",\r\n            severity: \"medium\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Redundant auth middleware detected. Found ${authMiddlewareFunctions.length} auth middleware functions in the same file.`,\r\n            recommendation:\r\n              \"Consolidate auth middleware into a single, reusable function. Consider creating a composable middleware pattern if different auth checks are needed.\",\r\n            estimatedEffort: \"small\",\r\n            tags: [\"auth\", \"middleware\", \"duplication\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 5.3: Unnecessary Auth Adapter Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect simple pass-through auth wrapper functions\r\n   * Validates Requirements: 2.5\r\n   */\r\n  private detectUnnecessaryAuthAdapters(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const functions = [\r\n      ...this.getFunctionDeclarations(ast),\r\n      ...this.getArrowFunctions(ast),\r\n      ...this.getFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const _funcText = func.getText();\r\n      const funcName = this.getNodeName(func);\r\n\r\n      // Skip if no name or not auth-related\r\n      if (!funcName || !this.isAuthRelated(funcName)) {\r\n        continue;\r\n      }\r\n\r\n      // Check if this is a simple pass-through wrapper\r\n      if (this.isPassThroughWrapper(func)) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"unnecessary-adapter\",\r\n            severity: \"low\",\r\n            category: \"authentication\",\r\n            file: file.relativePath,\r\n            node: func,\r\n            description: `Unnecessary auth adapter detected: \"${funcName}\". This function appears to be a simple pass-through wrapper that adds no meaningful value.`,\r\n            recommendation:\r\n              \"Remove this wrapper function and call the underlying auth function directly. This reduces code complexity and improves maintainability.\",\r\n            estimatedEffort: \"trivial\",\r\n            tags: [\"auth\", \"adapter\", \"unnecessary\", \"wrapper\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Check if a function name is auth-related\r\n   */\r\n  private isAuthRelated(name: string): boolean {\r\n    const authKeywords = [\r\n      \"auth\",\r\n      \"authenticate\",\r\n      \"authorize\",\r\n      \"login\",\r\n      \"logout\",\r\n      \"session\",\r\n      \"user\",\r\n      \"permission\",\r\n      \"role\",\r\n      \"access\",\r\n      \"token\",\r\n      \"credential\",\r\n    ];\r\n\r\n    const lowerName = name.toLowerCase();\r\n    return authKeywords.some((keyword) => lowerName.includes(keyword));\r\n  }\r\n\r\n  /**\r\n   * Check if a function is a simple pass-through wrapper\r\n   */\r\n  private isPassThroughWrapper(func: Node): boolean {\r\n    const funcText = func.getText();\r\n\r\n    // Get the function body\r\n    let body: Node | undefined;\r\n\r\n    if (Node.isFunctionDeclaration(func) || Node.isFunctionExpression(func)) {\r\n      body = (func as any).getBody();\r\n    } else if (Node.isArrowFunction(func)) {\r\n      const _arrowBody = (func as ArrowFunction).getBody();\r\n    }\r\n\r\n    if (!body) {\r\n      return false;\r\n    }\r\n\r\n    const bodyText = body.getText().trim();\r\n\r\n    // Check for simple pass-through patterns:\r\n    // 1. Single return statement with a function call\r\n    // 2. Single line arrow function that just calls another function\r\n    // 3. Function that just returns the result of another function call\r\n\r\n    // Pattern 1: { return someFunction(...) }\r\n    const singleReturnPattern = /^\\{\\s*return\\s+\\w+\\([^)]*\\)\\s*;?\\s*\\}$/;\r\n    if (singleReturnPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 2: Arrow function: (...) => someFunction(...)\r\n    const arrowPassThroughPattern = /^\\w+\\([^)]*\\)$/;\r\n    if (Node.isArrowFunction(func) && arrowPassThroughPattern.test(bodyText)) {\r\n      return true;\r\n    }\r\n\r\n    // Pattern 3: Check if body has only one statement that's a return with a call\r\n    if (Node.isBlock(body)) {\r\n      const statements = body.getStatements();\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        if (Node.isReturnStatement(statement)) {\r\n          const expression = statement.getExpression();\r\n          if (expression && Node.isCallExpression(expression)) {\r\n            // This is a simple pass-through: just returns a function call\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Pattern 4: Arrow function with single call expression\r\n    if (Node.isArrowFunction(func)) {\r\n      const arrowBody = (func as ArrowFunction).getBody();\r\n      if (Node.isCallExpression(arrowBody)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\component-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":810,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":810,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24922,24925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24922,24925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":865,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":865,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[27036,27039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[27036,27039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":917,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":917,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[29027,29030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[29027,29030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Component Pattern Analyzer\r\n *\r\n * Analyzes React component structure and patterns in the codebase to identify\r\n * component quality issues and inconsistencies.\r\n *\r\n * Detects:\r\n * - React function components\r\n * - React class components\r\n * - Component categorization by type\r\n * - Components with business logic that should be in services\r\n * - Excessive prop drilling (more than 3 levels)\r\n * - Duplicate component logic\r\n * - Inconsistent component composition patterns\r\n * - Components mixing concerns (UI + data fetching + business logic)\r\n */\r\n\r\nimport {\r\n  SourceFile,\r\n  Node,\r\n  FunctionDeclaration,\r\n  ArrowFunction,\r\n  ClassDeclaration,\r\n  VariableDeclaration,\r\n} from \"ts-morph\";\r\nimport { BasePatternAnalyzer } from \"./pattern-analyzer.js\";\r\nimport type { FileInfo, Issue, FileCategory } from \"../types.js\";\r\n\r\n/**\r\n * Information about a discovered React component\r\n */\r\ninterface ComponentInfo {\r\n  name: string;\r\n  type: \"function\" | \"class\" | \"arrow\";\r\n  node: Node;\r\n  file: string;\r\n  isExported: boolean;\r\n  hasProps: boolean;\r\n  usesHooks: boolean;\r\n  usesState: boolean;\r\n}\r\n\r\n/**\r\n * Information about a prop chain through component hierarchy\r\n */\r\ninterface PropChain {\r\n  propName: string;\r\n  depth: number;\r\n  componentPath: string[];\r\n  startNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for React component patterns\r\n */\r\nexport class ComponentPatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = \"ComponentPatternAnalyzer\";\r\n\r\n  private discoveredComponents: ComponentInfo[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return [\"component\"];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for component-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    // Reset state for each file analysis\r\n    this.discoveredComponents = [];\r\n\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 7.1: Discover and categorize React components\r\n    issues.push(...this.discoverComponents(file, ast));\r\n\r\n    // Task 7.2: Detect prop drilling\r\n    issues.push(...this.detectPropDrilling(file, ast));\r\n\r\n    // Task 7.3: Detect component pattern inconsistencies and duplicate logic\r\n    issues.push(...this.detectComponentPatternInconsistencies(file, ast));\r\n    issues.push(...this.detectDuplicateComponentLogic(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.1: Component Discovery and Categorization\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover all React components (function and class components) and categorize them\r\n   * Validates Requirements: 6.1\r\n   */\r\n  private discoverComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Discover function components\r\n    issues.push(...this.discoverFunctionComponents(file, ast));\r\n\r\n    // Discover class components\r\n    issues.push(...this.discoverClassComponents(file, ast));\r\n\r\n    // Discover arrow function components\r\n    issues.push(...this.discoverArrowFunctionComponents(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React function components (function declarations)\r\n   */\r\n  private discoverFunctionComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const functionDeclarations = ast.getFunctions();\r\n\r\n    for (const func of functionDeclarations) {\r\n      const funcName = func.getName();\r\n      if (!funcName) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(func, funcName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: funcName,\r\n          type: \"function\",\r\n          node: func,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(func),\r\n          hasProps: this.hasParameters(func),\r\n          usesHooks: this.usesReactHooks(func),\r\n          usesState: this.usesStateHook(func),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Log discovery (not an issue, just tracking)\r\n        // We don't create issues for valid components, only for problems\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React class components\r\n   */\r\n  private discoverClassComponents(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const classDeclarations = this.getClassDeclarations(ast);\r\n\r\n    for (const classDecl of classDeclarations) {\r\n      const className = this.getNodeName(classDecl);\r\n      if (!className) continue;\r\n\r\n      // Cast to ClassDeclaration for type safety\r\n      if (!Node.isClassDeclaration(classDecl)) continue;\r\n\r\n      // Check if this class extends React.Component or React.PureComponent\r\n      if (this.isReactClassComponent(classDecl)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: className,\r\n          type: \"class\",\r\n          node: classDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(classDecl),\r\n          hasProps: this.classHasProps(classDecl),\r\n          usesHooks: false, // Class components don't use hooks\r\n          usesState: this.classHasState(classDecl),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n\r\n        // Flag class components as potentially outdated pattern\r\n        // Modern React prefers function components with hooks\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"legacy-code\",\r\n            severity: \"low\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: classDecl,\r\n            description: `Class component '${className}' detected. Modern React development favors function components with hooks for better code reuse and simpler patterns.`,\r\n            recommendation: `Consider refactoring '${className}' to a function component using hooks (useState, useEffect, etc.). This improves code readability and enables better composition with custom hooks.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\"component\", \"class-component\", \"modernization\", \"hooks\"],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Discover React arrow function components (variable declarations with arrow functions)\r\n   */\r\n  private discoverArrowFunctionComponents(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n\r\n    for (const varDecl of variableDeclarations) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (!varName) continue;\r\n\r\n      // Cast to VariableDeclaration to access getInitializer\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const initializer = varDecl.getInitializer();\r\n      if (!initializer || !Node.isArrowFunction(initializer)) continue;\r\n\r\n      // Check if this is a React component\r\n      if (this.isReactComponent(initializer, varName)) {\r\n        const componentInfo: ComponentInfo = {\r\n          name: varName,\r\n          type: \"arrow\",\r\n          node: varDecl,\r\n          file: file.relativePath,\r\n          isExported: this.isExported(varDecl),\r\n          hasProps: this.hasParameters(initializer),\r\n          usesHooks: this.usesReactHooks(initializer),\r\n          usesState: this.usesStateHook(initializer),\r\n        };\r\n\r\n        this.discoveredComponents.push(componentInfo);\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Component Detection Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a function/arrow function is a React component\r\n   * React components:\r\n   * - Start with uppercase letter (PascalCase)\r\n   * - Return JSX (contains JSX elements)\r\n   * - May use React hooks\r\n   */\r\n  private isReactComponent(node: Node, name: string): boolean {\r\n    // Check 1: Name starts with uppercase (PascalCase convention)\r\n    if (!this.isPascalCase(name)) {\r\n      return false;\r\n    }\r\n\r\n    // Check 2: Returns JSX or uses React hooks\r\n    const returnsJSX = this.returnsJSX(node);\r\n    const usesHooks = this.usesReactHooks(node);\r\n\r\n    return returnsJSX || usesHooks;\r\n  }\r\n\r\n  /**\r\n   * Check if a class is a React component\r\n   */\r\n  private isReactClassComponent(classDecl: ClassDeclaration): boolean {\r\n    const heritage = classDecl.getExtends();\r\n    if (!heritage) return false;\r\n\r\n    const heritageText = heritage.getText();\r\n\r\n    // Check if extends React.Component, React.PureComponent, Component, or PureComponent\r\n    return (\r\n      heritageText.includes(\"React.Component\") ||\r\n      heritageText.includes(\"React.PureComponent\") ||\r\n      heritageText === \"Component\" ||\r\n      heritageText === \"PureComponent\"\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Check if a name follows PascalCase convention\r\n   */\r\n  private isPascalCase(name: string): boolean {\r\n    // PascalCase: starts with uppercase, contains at least one letter\r\n    return /^[A-Z][a-zA-Z0-9]*$/.test(name) && name.length > 1;\r\n  }\r\n\r\n  /**\r\n   * Check if a function returns JSX\r\n   */\r\n  private returnsJSX(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Look for JSX patterns:\r\n    // - JSX elements: <div>, <Component>\r\n    // - JSX fragments: <>, </>\r\n    // - Return statements with JSX\r\n    const jsxPatterns = [\r\n      /<[A-Z][a-zA-Z0-9]*[\\s>\\/]/, // Component tags: <MyComponent\r\n      /<[a-z][a-zA-Z0-9]*[\\s>\\/]/, // HTML tags: <div\r\n      /<>/, // Fragment opening\r\n      /<\\/>/, // Fragment closing\r\n      /return\\s*\\(/, // Return with parentheses (common for JSX)\r\n    ];\r\n\r\n    return jsxPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses React hooks\r\n   */\r\n  private usesReactHooks(node: Node): boolean {\r\n    const text = node.getText();\r\n\r\n    // Common React hooks\r\n    const hookPatterns = [\r\n      /\\buse[A-Z][a-zA-Z0-9]*\\(/, // Any hook: useState, useEffect, useCustomHook\r\n      /\\buseState\\(/,\r\n      /\\buseEffect\\(/,\r\n      /\\buseContext\\(/,\r\n      /\\buseReducer\\(/,\r\n      /\\buseCallback\\(/,\r\n      /\\buseMemo\\(/,\r\n      /\\buseRef\\(/,\r\n      /\\buseImperativeHandle\\(/,\r\n      /\\buseLayoutEffect\\(/,\r\n      /\\buseDebugValue\\(/,\r\n    ];\r\n\r\n    return hookPatterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  /**\r\n   * Check if a function uses useState hook\r\n   */\r\n  private usesStateHook(node: Node): boolean {\r\n    const text = node.getText();\r\n    return /\\buseState\\(/.test(text);\r\n  }\r\n\r\n  /**\r\n   * Check if a function has parameters\r\n   */\r\n  private hasParameters(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      return node.getParameters().length > 0;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has props\r\n   */\r\n  private classHasProps(classDecl: ClassDeclaration): boolean {\r\n    // Check constructor parameters\r\n    const constructors = classDecl.getConstructors();\r\n    for (const constructor of constructors) {\r\n      if (constructor.getParameters().length > 0) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check if props are accessed in the class\r\n    const classText = classDecl.getText();\r\n    return classText.includes(\"this.props\");\r\n  }\r\n\r\n  /**\r\n   * Check if a class component has state\r\n   */\r\n  private classHasState(classDecl: ClassDeclaration): boolean {\r\n    const classText = classDecl.getText();\r\n\r\n    // Check for state initialization or usage\r\n    return classText.includes(\"this.state\") || classText.includes(\"setState(\");\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.2: Prop Drilling Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive prop drilling (props passed through more than 3 levels)\r\n   * Validates Requirements: 6.3\r\n   */\r\n  private detectPropDrilling(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all JSX elements in the file\r\n    const jsxElements = this.findJSXElements(ast);\r\n\r\n    // Track prop chains through component hierarchy\r\n    const propChains = this.buildPropChains(jsxElements, ast);\r\n\r\n    // Flag chains exceeding 3 levels\r\n    for (const chain of propChains) {\r\n      if (chain.depth > 3) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: \"confusing-logic\",\r\n            severity: \"medium\",\r\n            category: \"components\",\r\n            file: file.relativePath,\r\n            node: chain.startNode,\r\n            description: `Prop drilling detected: prop '${chain.propName}' is passed through ${chain.depth} levels of components (${chain.componentPath.join(\" → \")}). This makes the code harder to maintain and understand.`,\r\n            recommendation: `Consider using React Context, a state management library (Redux, Zustand), or component composition patterns to avoid passing '${chain.propName}' through ${chain.depth} levels. This will make the code more maintainable and reduce coupling between components.`,\r\n            estimatedEffort: \"medium\",\r\n            tags: [\r\n              \"component\",\r\n              \"prop-drilling\",\r\n              \"state-management\",\r\n              \"refactoring\",\r\n            ],\r\n          }),\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in the AST\r\n   */\r\n  private findJSXElements(ast: SourceFile): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (node: Node) => {\r\n      const kind = node.getKind();\r\n\r\n      // JSX element types\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement ||\r\n        kind === SyntaxKind.JsxFragment\r\n      ) {\r\n        jsxElements.push(node);\r\n      }\r\n\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Build prop chains by tracking props through component hierarchy\r\n   */\r\n  private buildPropChains(jsxElements: Node[], ast: SourceFile): PropChain[] {\r\n    const chains: PropChain[] = [];\r\n\r\n    // For each component in the file, track its props\r\n    for (const component of this.discoveredComponents) {\r\n      const componentNode = component.node;\r\n      const componentName = component.name;\r\n\r\n      // Get the props parameter\r\n      const props = this.getComponentProps(componentNode);\r\n      if (!props || props.length === 0) continue;\r\n\r\n      // For each prop, track where it's passed down\r\n      for (const propName of props) {\r\n        const chain = this.trackPropThroughHierarchy(\r\n          propName,\r\n          componentName,\r\n          componentNode,\r\n          ast,\r\n          1,\r\n        );\r\n\r\n        if (chain && chain.depth > 1) {\r\n          chains.push(chain);\r\n        }\r\n      }\r\n    }\r\n\r\n    return chains;\r\n  }\r\n\r\n  /**\r\n   * Get the props from a component (parameter names)\r\n   */\r\n  private getComponentProps(componentNode: Node): string[] {\r\n    const props: string[] = [];\r\n\r\n    // Handle function components\r\n    if (\r\n      Node.isFunctionDeclaration(componentNode) ||\r\n      Node.isArrowFunction(componentNode)\r\n    ) {\r\n      const params = componentNode.getParameters();\r\n      if (params.length > 0) {\r\n        const propsParam = params[0];\r\n\r\n        // Handle destructured props: function MyComponent({ prop1, prop2 })\r\n        const binding = propsParam.getNameNode();\r\n        if (Node.isObjectBindingPattern(binding)) {\r\n          const elements = binding.getElements();\r\n          for (const element of elements) {\r\n            const name = element.getName();\r\n            if (name) {\r\n              props.push(name);\r\n            }\r\n          }\r\n        } else {\r\n          // Handle props object: function MyComponent(props)\r\n          const paramName = propsParam.getName();\r\n          if (paramName) {\r\n            // Look for props.propName usage in the component\r\n            const componentText = componentNode.getText();\r\n            const propAccessPattern = new RegExp(\r\n              `${paramName}\\\\.([a-zA-Z_$][a-zA-Z0-9_$]*)`,\r\n              \"g\",\r\n            );\r\n            let match;\r\n            while ((match = propAccessPattern.exec(componentText)) !== null) {\r\n              const propName = match[1];\r\n              if (!props.includes(propName)) {\r\n                props.push(propName);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle variable declarations with arrow functions\r\n    if (Node.isVariableDeclaration(componentNode)) {\r\n      const initializer = componentNode.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.getComponentProps(initializer);\r\n      }\r\n    }\r\n\r\n    return props;\r\n  }\r\n\r\n  /**\r\n   * Track a prop through the component hierarchy to detect drilling\r\n   */\r\n  private trackPropThroughHierarchy(\r\n    propName: string,\r\n    currentComponent: string,\r\n    componentNode: Node,\r\n    ast: SourceFile,\r\n    currentDepth: number,\r\n    visitedComponents: Set<string> = new Set(),\r\n  ): PropChain | null {\r\n    // Prevent infinite recursion\r\n    if (visitedComponents.has(currentComponent)) {\r\n      return null;\r\n    }\r\n    visitedComponents.add(currentComponent);\r\n\r\n    // Maximum depth to track (prevent excessive recursion)\r\n    if (currentDepth > 10) {\r\n      return null;\r\n    }\r\n\r\n    const componentPath = [currentComponent];\r\n    let maxDepth = currentDepth;\r\n    let deepestNode = componentNode;\r\n\r\n    // Find JSX elements within this component that pass the prop down\r\n    const jsxElements = this.findJSXElementsInNode(componentNode);\r\n\r\n    for (const jsxElement of jsxElements) {\r\n      const childComponentName = this.getJSXElementName(jsxElement);\r\n      if (!childComponentName) continue;\r\n\r\n      // Check if this JSX element passes the prop down\r\n      if (this.jsxElementPassesProp(jsxElement, propName)) {\r\n        // Find the child component definition\r\n        const childComponent = this.discoveredComponents.find(\r\n          (comp) => comp.name === childComponentName,\r\n        );\r\n\r\n        if (childComponent) {\r\n          // Recursively track the prop in the child component\r\n          const childChain = this.trackPropThroughHierarchy(\r\n            propName,\r\n            childComponentName,\r\n            childComponent.node,\r\n            ast,\r\n            currentDepth + 1,\r\n            new Set(visitedComponents),\r\n          );\r\n\r\n          if (childChain && childChain.depth > maxDepth) {\r\n            maxDepth = childChain.depth;\r\n            componentPath.push(...childChain.componentPath);\r\n            deepestNode = childChain.startNode;\r\n          }\r\n        } else {\r\n          // Child component not found in this file, assume it's passed one more level\r\n          componentPath.push(childComponentName);\r\n          maxDepth = currentDepth + 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (maxDepth > currentDepth) {\r\n      return {\r\n        propName,\r\n        depth: maxDepth,\r\n        componentPath,\r\n        startNode: deepestNode,\r\n      };\r\n    }\r\n\r\n    return {\r\n      propName,\r\n      depth: currentDepth,\r\n      componentPath,\r\n      startNode: componentNode,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find JSX elements within a specific node\r\n   */\r\n  private findJSXElementsInNode(node: Node): Node[] {\r\n    const jsxElements: Node[] = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      const kind = n.getKind();\r\n\r\n      if (\r\n        kind === SyntaxKind.JsxElement ||\r\n        kind === SyntaxKind.JsxSelfClosingElement\r\n      ) {\r\n        jsxElements.push(n);\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return jsxElements;\r\n  }\r\n\r\n  /**\r\n   * Get the component name from a JSX element\r\n   */\r\n  private getJSXElementName(jsxElement: Node): string | null {\r\n    const text = jsxElement.getText();\r\n\r\n    // Match opening tag: <ComponentName or <ComponentName>\r\n    const match = text.match(/^<([A-Z][a-zA-Z0-9]*)/);\r\n    if (match) {\r\n      return match[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if a JSX element passes a specific prop down\r\n   */\r\n  private jsxElementPassesProp(jsxElement: Node, propName: string): boolean {\r\n    const text = jsxElement.getText();\r\n\r\n    // Look for patterns like:\r\n    // - propName={propName}\r\n    // - propName={props.propName}\r\n    // - {...props} (spread operator)\r\n    const patterns = [\r\n      new RegExp(`\\\\b${propName}=\\\\{${propName}\\\\}`), // propName={propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{props\\\\.${propName}\\\\}`), // propName={props.propName}\r\n      new RegExp(`\\\\b${propName}=\\\\{[^}]*${propName}[^}]*\\\\}`), // propName={...propName...}\r\n      /\\{\\.\\.\\.props\\}/, // {...props}\r\n      /\\{\\.\\.\\.rest\\}/, // {...rest}\r\n    ];\r\n\r\n    return patterns.some((pattern) => pattern.test(text));\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing discovered components\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered components\r\n   */\r\n  public getDiscoveredComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents;\r\n  }\r\n\r\n  /**\r\n   * Get components by type\r\n   */\r\n  public getComponentsByType(\r\n    type: \"function\" | \"class\" | \"arrow\",\r\n  ): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.type === type);\r\n  }\r\n\r\n  /**\r\n   * Get exported components\r\n   */\r\n  public getExportedComponents(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.isExported);\r\n  }\r\n\r\n  /**\r\n   * Get components that use hooks\r\n   */\r\n  public getComponentsUsingHooks(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesHooks);\r\n  }\r\n\r\n  /**\r\n   * Get components that use state\r\n   */\r\n  public getComponentsUsingState(): ComponentInfo[] {\r\n    return this.discoveredComponents.filter((comp) => comp.usesState);\r\n  }\r\n\r\n  /**\r\n   * Clear discovered components (useful for testing or re-analysis)\r\n   */\r\n  public clearDiscoveredComponents(): void {\r\n    this.discoveredComponents = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Component Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent component composition patterns\r\n   * Validates Requirements: 6.4\r\n   *\r\n   * Detects:\r\n   * - Inconsistent prop passing patterns (destructuring vs object)\r\n   * - Inconsistent export patterns (default vs named)\r\n   * - Inconsistent component definition styles (function vs arrow)\r\n   * - Inconsistent hook usage patterns\r\n   * - Inconsistent event handler naming\r\n   */\r\n  private detectComponentPatternInconsistencies(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Analyze patterns across all components in the file\r\n    const patterns = this.analyzeComponentPatterns();\r\n\r\n    // Detect inconsistent prop patterns\r\n    issues.push(...this.detectInconsistentPropPatterns(file, patterns));\r\n\r\n    // Detect inconsistent export patterns\r\n    issues.push(...this.detectInconsistentExportPatterns(file, patterns));\r\n\r\n    // Detect inconsistent component definition styles\r\n    issues.push(...this.detectInconsistentDefinitionStyles(file, patterns));\r\n\r\n    // Detect inconsistent event handler naming\r\n    issues.push(...this.detectInconsistentEventHandlerNaming(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze patterns across all discovered components\r\n   */\r\n  private analyzeComponentPatterns() {\r\n    const patterns = {\r\n      propDestructuring: 0,\r\n      propObject: 0,\r\n      defaultExports: 0,\r\n      namedExports: 0,\r\n      functionDeclarations: 0,\r\n      arrowFunctions: 0,\r\n      usesTypeScript: 0,\r\n      usesJavaScript: 0,\r\n    };\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      // Count prop patterns\r\n      if (this.usesPropDestructuring(component.node)) {\r\n        patterns.propDestructuring++;\r\n      } else if (component.hasProps) {\r\n        patterns.propObject++;\r\n      }\r\n\r\n      // Count export patterns\r\n      if (this.isDefaultExport(component.node)) {\r\n        patterns.defaultExports++;\r\n      } else if (component.isExported) {\r\n        patterns.namedExports++;\r\n      }\r\n\r\n      // Count definition styles\r\n      if (component.type === \"function\") {\r\n        patterns.functionDeclarations++;\r\n      } else if (component.type === \"arrow\") {\r\n        patterns.arrowFunctions++;\r\n      }\r\n    }\r\n\r\n    return patterns;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent prop passing patterns\r\n   */\r\n  private detectInconsistentPropPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both patterns are used, flag inconsistency\r\n    if (patterns.propDestructuring > 0 && patterns.propObject > 0) {\r\n      const total = patterns.propDestructuring + patterns.propObject;\r\n      const destructuringPercent = Math.round(\r\n        (patterns.propDestructuring / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const usesDestructuring = this.usesPropDestructuring(component.node);\r\n        const isMinorityPattern =\r\n          (usesDestructuring && destructuringPercent < 50) ||\r\n          (!usesDestructuring &&\r\n            component.hasProps &&\r\n            destructuringPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            destructuringPercent >= 50 ? \"destructuring\" : \"object\";\r\n          const currentPattern = usesDestructuring ? \"destructuring\" : \"object\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} for props, but ${patterns.propDestructuring} components use destructuring and ${patterns.propObject} use object props. This inconsistency makes the codebase harder to understand.`,\r\n              recommendation: `Consider using ${preferredPattern} pattern for props consistently across all components. This improves code readability and maintainability.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"props\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent export patterns\r\n   */\r\n  private detectInconsistentExportPatterns(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both export patterns are used, flag inconsistency\r\n    if (patterns.defaultExports > 0 && patterns.namedExports > 0) {\r\n      const total = patterns.defaultExports + patterns.namedExports;\r\n      const defaultPercent = Math.round(\r\n        (patterns.defaultExports / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        const isDefault = this.isDefaultExport(component.node);\r\n        const isMinorityPattern =\r\n          (isDefault && defaultPercent < 50) ||\r\n          (component.isExported && !isDefault && defaultPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern = defaultPercent >= 50 ? \"default\" : \"named\";\r\n          const currentPattern = isDefault ? \"default\" : \"named\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' uses ${currentPattern} export, but ${patterns.defaultExports} components use default exports and ${patterns.namedExports} use named exports. This inconsistency can confuse developers.`,\r\n              recommendation: `Consider using ${preferredPattern} exports consistently across all components. This makes imports more predictable and consistent.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"exports\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent component definition styles\r\n   */\r\n  private detectInconsistentDefinitionStyles(\r\n    file: FileInfo,\r\n    patterns: any,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // If both function and arrow styles are used, flag inconsistency\r\n    if (patterns.functionDeclarations > 0 && patterns.arrowFunctions > 0) {\r\n      const total = patterns.functionDeclarations + patterns.arrowFunctions;\r\n      const functionPercent = Math.round(\r\n        (patterns.functionDeclarations / total) * 100,\r\n      );\r\n\r\n      // Find components using the minority pattern\r\n      for (const component of this.discoveredComponents) {\r\n        if (component.type === \"class\") continue; // Skip class components\r\n\r\n        const isFunction = component.type === \"function\";\r\n        const isMinorityPattern =\r\n          (isFunction && functionPercent < 50) ||\r\n          (component.type === \"arrow\" && functionPercent >= 50);\r\n\r\n        if (isMinorityPattern) {\r\n          const preferredPattern =\r\n            functionPercent >= 50 ? \"function declaration\" : \"arrow function\";\r\n          const currentPattern = isFunction\r\n            ? \"function declaration\"\r\n            : \"arrow function\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: component.node,\r\n              description: `Component '${component.name}' is defined as ${currentPattern}, but ${patterns.functionDeclarations} components use function declarations and ${patterns.arrowFunctions} use arrow functions. This inconsistency affects code style uniformity.`,\r\n              recommendation: `Consider using ${preferredPattern} consistently for all function components. This creates a more uniform codebase.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"definition-style\",\r\n                \"code-style\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect inconsistent event handler naming patterns\r\n   */\r\n  private detectInconsistentEventHandlerNaming(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Track event handler naming patterns\r\n    const handlerPatterns = {\r\n      handlePrefix: 0, // handleClick, handleSubmit\r\n      onPrefix: 0, // onClick, onSubmit\r\n      other: 0, // click, submit, doSomething\r\n    };\r\n\r\n    const inconsistentHandlers: Array<{\r\n      name: string;\r\n      node: Node;\r\n      pattern: string;\r\n    }> = [];\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const handlers = this.findEventHandlers(component.node);\r\n\r\n      for (const handler of handlers) {\r\n        if (handler.name.startsWith(\"handle\")) {\r\n          handlerPatterns.handlePrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"handle\" });\r\n        } else if (handler.name.startsWith(\"on\")) {\r\n          handlerPatterns.onPrefix++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"on\" });\r\n        } else {\r\n          handlerPatterns.other++;\r\n          inconsistentHandlers.push({ ...handler, pattern: \"other\" });\r\n        }\r\n      }\r\n    }\r\n\r\n    // If multiple patterns are used, flag inconsistency\r\n    const patternsUsed = [\r\n      handlerPatterns.handlePrefix > 0,\r\n      handlerPatterns.onPrefix > 0,\r\n      handlerPatterns.other > 0,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternsUsed > 1) {\r\n      const total =\r\n        handlerPatterns.handlePrefix +\r\n        handlerPatterns.onPrefix +\r\n        handlerPatterns.other;\r\n      const dominantPattern =\r\n        handlerPatterns.handlePrefix > handlerPatterns.onPrefix &&\r\n        handlerPatterns.handlePrefix > handlerPatterns.other\r\n          ? \"handle\"\r\n          : handlerPatterns.onPrefix > handlerPatterns.other\r\n            ? \"on\"\r\n            : \"other\";\r\n\r\n      // Flag handlers using minority patterns\r\n      for (const handler of inconsistentHandlers) {\r\n        if (handler.pattern !== dominantPattern) {\r\n          const preferredExample =\r\n            dominantPattern === \"handle\"\r\n              ? \"handleClick\"\r\n              : dominantPattern === \"on\"\r\n                ? \"onClick\"\r\n                : \"descriptive names\";\r\n\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"inconsistent-pattern\",\r\n              severity: \"low\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: handler.node,\r\n              description: `Event handler '${handler.name}' uses '${handler.pattern}' prefix, but the codebase has ${handlerPatterns.handlePrefix} 'handle' handlers, ${handlerPatterns.onPrefix} 'on' handlers, and ${handlerPatterns.other} other patterns. This inconsistency makes the code less predictable.`,\r\n              recommendation: `Consider using '${dominantPattern}' prefix consistently for event handlers (e.g., ${preferredExample}). This improves code consistency and makes event handlers easier to identify.`,\r\n              estimatedEffort: \"trivial\",\r\n              tags: [\r\n                \"component\",\r\n                \"inconsistent-pattern\",\r\n                \"event-handlers\",\r\n                \"naming\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find event handler functions in a component\r\n   */\r\n  private findEventHandlers(node: Node): Array<{ name: string; node: Node }> {\r\n    const handlers: Array<{ name: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common event handler patterns in JSX\r\n    const eventAttributes = [\r\n      \"onClick\",\r\n      \"onChange\",\r\n      \"onSubmit\",\r\n      \"onFocus\",\r\n      \"onBlur\",\r\n      \"onKeyDown\",\r\n      \"onKeyUp\",\r\n      \"onKeyPress\",\r\n      \"onMouseEnter\",\r\n      \"onMouseLeave\",\r\n      \"onMouseDown\",\r\n      \"onMouseUp\",\r\n      \"onInput\",\r\n      \"onScroll\",\r\n      \"onLoad\",\r\n    ];\r\n\r\n    for (const eventAttr of eventAttributes) {\r\n      // Match patterns like onClick={handleClick} or onClick={onClickHandler}\r\n      const pattern = new RegExp(\r\n        `${eventAttr}=\\\\{([a-zA-Z_$][a-zA-Z0-9_$]*)\\\\}`,\r\n        \"g\",\r\n      );\r\n      let match;\r\n\r\n      while ((match = pattern.exec(text)) !== null) {\r\n        const handlerName = match[1];\r\n\r\n        // Find the actual function definition\r\n        const handlerNode = this.findFunctionByName(node, handlerName);\r\n        if (handlerNode) {\r\n          handlers.push({ name: handlerName, node: handlerNode });\r\n        }\r\n      }\r\n    }\r\n\r\n    return handlers;\r\n  }\r\n\r\n  /**\r\n   * Find a function definition by name within a node\r\n   */\r\n  private findFunctionByName(node: Node, name: string): Node | null {\r\n    let foundNode: Node | null = null;\r\n\r\n    const traverse = (n: Node) => {\r\n      if (foundNode) return;\r\n\r\n      // Check function declarations\r\n      if (Node.isFunctionDeclaration(n)) {\r\n        if (n.getName() === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      // Check variable declarations with arrow functions\r\n      if (Node.isVariableDeclaration(n)) {\r\n        if (this.getNodeName(n) === name) {\r\n          foundNode = n;\r\n          return;\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return foundNode;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 7.3: Duplicate Component Logic Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate component logic across components\r\n   * Validates Requirements: 6.5\r\n   *\r\n   * Detects:\r\n   * - Duplicate validation logic\r\n   * - Duplicate data transformation logic\r\n   * - Duplicate effect patterns\r\n   * - Duplicate custom hook patterns\r\n   * - Similar component structures\r\n   */\r\n  private detectDuplicateComponentLogic(\r\n    file: FileInfo,\r\n    ast: SourceFile,\r\n  ): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate validation logic\r\n    issues.push(...this.detectDuplicateValidation(file));\r\n\r\n    // Detect duplicate useEffect patterns\r\n    issues.push(...this.detectDuplicateEffects(file));\r\n\r\n    // Detect duplicate data transformations\r\n    issues.push(...this.detectDuplicateTransformations(file));\r\n\r\n    // Detect similar component structures\r\n    issues.push(...this.detectSimilarComponentStructures(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate validation logic across components\r\n   */\r\n  private detectDuplicateValidation(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const validationPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const validations = this.extractValidationLogic(component.node);\r\n\r\n      for (const validation of validations) {\r\n        const pattern = this.normalizeCode(validation.code);\r\n\r\n        if (!validationPatterns.has(pattern)) {\r\n          validationPatterns.set(pattern, []);\r\n        }\r\n\r\n        validationPatterns.get(pattern)!.push({\r\n          component,\r\n          node: validation.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of validationPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate validation logic found in component '${occurrence.component.name}'. This same validation appears in ${occurrences.length} components: ${componentNames}. Duplicated validation logic increases maintenance burden.`,\r\n              recommendation: `Extract this validation logic into a shared utility function or custom hook. This will make the validation logic reusable and easier to maintain. Consider creating a validation utility in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"validation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract validation logic from a component\r\n   */\r\n  private extractValidationLogic(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const validations: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Look for common validation patterns\r\n    const validationKeywords = [\r\n      \"validate\",\r\n      \"isValid\",\r\n      \"check\",\r\n      \"verify\",\r\n      \"test\",\r\n      \"required\",\r\n      \"optional\",\r\n      \"min\",\r\n      \"max\",\r\n      \"pattern\",\r\n      \"email\",\r\n      \"phone\",\r\n      \"url\",\r\n      \"number\",\r\n      \"string\",\r\n    ];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for if statements with validation logic\r\n      if (Node.isIfStatement(n)) {\r\n        const condition = n.getExpression().getText();\r\n\r\n        if (\r\n          validationKeywords.some((keyword) =>\r\n            condition.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Look for validation functions\r\n      if (Node.isFunctionDeclaration(n) || Node.isArrowFunction(n)) {\r\n        const funcText = n.getText();\r\n        const funcName = Node.isFunctionDeclaration(n) ? n.getName() : \"\";\r\n\r\n        if (\r\n          validationKeywords.some(\r\n            (keyword) =>\r\n              funcName?.toLowerCase().includes(keyword) ||\r\n              funcText.toLowerCase().includes(keyword),\r\n          )\r\n        ) {\r\n          validations.push({\r\n            code: funcText,\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return validations;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate useEffect patterns\r\n   */\r\n  private detectDuplicateEffects(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const effectPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const effects = this.extractEffects(component.node);\r\n\r\n      for (const effect of effects) {\r\n        const pattern = this.normalizeCode(effect.code);\r\n\r\n        if (!effectPatterns.has(pattern)) {\r\n          effectPatterns.set(pattern, []);\r\n        }\r\n\r\n        effectPatterns.get(pattern)!.push({\r\n          component,\r\n          node: effect.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of effectPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate useEffect logic found in component '${occurrence.component.name}'. This same effect appears in ${occurrences.length} components: ${componentNames}. Duplicated effects increase maintenance burden.`,\r\n              recommendation: `Extract this effect logic into a custom hook. This will make the effect reusable and easier to maintain. Consider creating a custom hook like 'use[DescriptiveName]' in a shared hooks directory.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"hooks\",\r\n                \"useEffect\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract useEffect calls from a component\r\n   */\r\n  private extractEffects(node: Node): Array<{ code: string; node: Node }> {\r\n    const effects: Array<{ code: string; node: Node }> = [];\r\n    const text = node.getText();\r\n\r\n    // Find useEffect calls\r\n    const effectPattern = /useEffect\\s*\\(/g;\r\n    let match;\r\n\r\n    while ((match = effectPattern.exec(text)) !== null) {\r\n      // Try to find the actual call expression node\r\n      const traverse = (n: Node) => {\r\n        if (Node.isCallExpression(n)) {\r\n          const expr = n.getExpression();\r\n          if (expr.getText() === \"useEffect\") {\r\n            effects.push({\r\n              code: n.getText(),\r\n              node: n,\r\n            });\r\n          }\r\n        }\r\n        n.forEachChild(traverse);\r\n      };\r\n\r\n      traverse(node);\r\n    }\r\n\r\n    return effects;\r\n  }\r\n\r\n  /**\r\n   * Detect duplicate data transformation logic\r\n   */\r\n  private detectDuplicateTransformations(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const transformPatterns = new Map<\r\n      string,\r\n      Array<{ component: ComponentInfo; node: Node }>\r\n    >();\r\n\r\n    for (const component of this.discoveredComponents) {\r\n      const transforms = this.extractTransformations(component.node);\r\n\r\n      for (const transform of transforms) {\r\n        const pattern = this.normalizeCode(transform.code);\r\n\r\n        if (!transformPatterns.has(pattern)) {\r\n          transformPatterns.set(pattern, []);\r\n        }\r\n\r\n        transformPatterns.get(pattern)!.push({\r\n          component,\r\n          node: transform.node,\r\n        });\r\n      }\r\n    }\r\n\r\n    // Flag patterns that appear in multiple components\r\n    for (const [pattern, occurrences] of transformPatterns.entries()) {\r\n      if (occurrences.length > 1) {\r\n        const componentNames = occurrences\r\n          .map((o) => o.component.name)\r\n          .join(\", \");\r\n\r\n        for (const occurrence of occurrences) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: occurrence.node,\r\n              description: `Duplicate data transformation logic found in component '${occurrence.component.name}'. This same transformation appears in ${occurrences.length} components: ${componentNames}. Duplicated transformations increase maintenance burden.`,\r\n              recommendation: `Extract this transformation logic into a shared utility function. This will make the transformation reusable and easier to maintain. Consider creating a utility function in a shared location.`,\r\n              estimatedEffort: \"small\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"transformation\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Extract data transformation logic from a component\r\n   */\r\n  private extractTransformations(\r\n    node: Node,\r\n  ): Array<{ code: string; node: Node }> {\r\n    const transformations: Array<{ code: string; node: Node }> = [];\r\n\r\n    const traverse = (n: Node) => {\r\n      // Look for array methods (map, filter, reduce, etc.)\r\n      if (Node.isCallExpression(n)) {\r\n        const expr = n.getExpression();\r\n        const exprText = expr.getText();\r\n\r\n        if (\r\n          exprText.endsWith(\".map\") ||\r\n          exprText.endsWith(\".filter\") ||\r\n          exprText.endsWith(\".reduce\") ||\r\n          exprText.endsWith(\".sort\") ||\r\n          exprText.endsWith(\".find\") ||\r\n          exprText.endsWith(\".findIndex\")\r\n        ) {\r\n          transformations.push({\r\n            code: n.getText(),\r\n            node: n,\r\n          });\r\n        }\r\n      }\r\n\r\n      n.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(node);\r\n    return transformations;\r\n  }\r\n\r\n  /**\r\n   * Detect similar component structures (potential for abstraction)\r\n   */\r\n  private detectSimilarComponentStructures(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Compare components pairwise for structural similarity\r\n    for (let i = 0; i < this.discoveredComponents.length; i++) {\r\n      for (let j = i + 1; j < this.discoveredComponents.length; j++) {\r\n        const comp1 = this.discoveredComponents[i];\r\n        const comp2 = this.discoveredComponents[j];\r\n\r\n        const similarity = this.calculateStructuralSimilarity(comp1, comp2);\r\n\r\n        // If components are very similar (>70% similar), flag for potential abstraction\r\n        if (similarity > 0.7) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: \"code-duplication\",\r\n              severity: \"medium\",\r\n              category: \"components\",\r\n              file: file.relativePath,\r\n              node: comp1.node,\r\n              description: `Components '${comp1.name}' and '${comp2.name}' have very similar structures (${Math.round(similarity * 100)}% similar). This suggests they could be abstracted into a single reusable component.`,\r\n              recommendation: `Consider creating a single component that accepts configuration props to handle both use cases. This reduces code duplication and makes the codebase more maintainable. Look for common patterns and extract them into a shared component.`,\r\n              estimatedEffort: \"medium\",\r\n              tags: [\r\n                \"component\",\r\n                \"code-duplication\",\r\n                \"abstraction\",\r\n                \"refactoring\",\r\n              ],\r\n            }),\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Calculate structural similarity between two components\r\n   */\r\n  private calculateStructuralSimilarity(\r\n    comp1: ComponentInfo,\r\n    comp2: ComponentInfo,\r\n  ): number {\r\n    let similarityScore = 0;\r\n    let totalChecks = 0;\r\n\r\n    // Compare component types\r\n    totalChecks++;\r\n    if (comp1.type === comp2.type) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare hook usage\r\n    totalChecks++;\r\n    if (comp1.usesHooks === comp2.usesHooks) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare state usage\r\n    totalChecks++;\r\n    if (comp1.usesState === comp2.usesState) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare props usage\r\n    totalChecks++;\r\n    if (comp1.hasProps === comp2.hasProps) {\r\n      similarityScore++;\r\n    }\r\n\r\n    // Compare code structure (simplified - count similar patterns)\r\n    const text1 = comp1.node.getText();\r\n    const text2 = comp2.node.getText();\r\n\r\n    // Count common patterns\r\n    const patterns = [\r\n      /useEffect/g,\r\n      /useState/g,\r\n      /useCallback/g,\r\n      /useMemo/g,\r\n      /return\\s*\\(/g,\r\n      /onClick/g,\r\n      /onChange/g,\r\n      /className/g,\r\n    ];\r\n\r\n    for (const pattern of patterns) {\r\n      totalChecks++;\r\n      const count1 = (text1.match(pattern) || []).length;\r\n      const count2 = (text2.match(pattern) || []).length;\r\n\r\n      if (count1 > 0 && count2 > 0) {\r\n        // Both use this pattern\r\n        const ratio = Math.min(count1, count2) / Math.max(count1, count2);\r\n        similarityScore += ratio;\r\n      }\r\n    }\r\n\r\n    return similarityScore / totalChecks;\r\n  }\r\n\r\n  /**\r\n   * Normalize code for comparison (remove whitespace, comments, etc.)\r\n   */\r\n  private normalizeCode(code: string): string {\r\n    return code\r\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\") // Remove block comments\r\n      .replace(/\\/\\/.*/g, \"\") // Remove line comments\r\n      .replace(/\\s+/g, \" \") // Normalize whitespace\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods for Pattern Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Check if a component uses prop destructuring\r\n   */\r\n  private usesPropDestructuring(node: Node): boolean {\r\n    if (Node.isFunctionDeclaration(node) || Node.isArrowFunction(node)) {\r\n      const params = node.getParameters();\r\n      if (params.length > 0) {\r\n        const binding = params[0].getNameNode();\r\n        return Node.isObjectBindingPattern(binding);\r\n      }\r\n    }\r\n\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const initializer = node.getInitializer();\r\n      if (initializer && Node.isArrowFunction(initializer)) {\r\n        return this.usesPropDestructuring(initializer);\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if a component uses default export\r\n   */\r\n  private isDefaultExport(node: Node): boolean {\r\n    const parent = node.getParent();\r\n\r\n    // Check if this is a default export declaration\r\n    if (parent && Node.isExportAssignment(parent)) {\r\n      return true;\r\n    }\r\n\r\n    // Check if there's a separate default export statement\r\n    const sourceFile = node.getSourceFile();\r\n    const defaultExports = sourceFile.getExportAssignments();\r\n\r\n    for (const exportAssignment of defaultExports) {\r\n      const expr = exportAssignment.getExpression();\r\n      const nodeName = this.getNodeName(node);\r\n\r\n      if (nodeName && expr.getText() === nodeName) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    // Check for \"export default\" syntax\r\n    const text = node.getText();\r\n    const fullText = node.getFullText();\r\n\r\n    return (\r\n      fullText.includes(\"export default\") || text.startsWith(\"export default\")\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9497,9500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9497,9500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":343,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10041,10044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10041,10044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10222,10225],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10222,10225],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10614,10617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10614,10617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":358,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":358,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10678,10681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10678,10681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":359,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10736,10739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10736,10739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Abstract base class for all pattern analyzers\r\n * Provides common utilities for AST traversal and issue creation\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { randomUUID } from 'crypto';\r\nimport type {\r\n  PatternAnalyzer,\r\n  FileInfo,\r\n  Issue,\r\n  IssueType,\r\n  IssueCategory,\r\n  Severity,\r\n  EffortLevel,\r\n  CodeLocation,\r\n  FileCategory,\r\n} from '../types.js';\r\n\r\n/**\r\n * Abstract base class that all pattern analyzers must extend\r\n */\r\nexport abstract class BasePatternAnalyzer implements PatternAnalyzer {\r\n  /**\r\n   * Name of the analyzer (must be implemented by subclasses)\r\n   */\r\n  abstract readonly name: string;\r\n\r\n  /**\r\n   * Analyze a file and return detected issues\r\n   * @param file File information\r\n   * @param ast Parsed AST of the file\r\n   * @returns Array of detected issues\r\n   */\r\n  abstract analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]>;\r\n\r\n  /**\r\n   * Get the file types this analyzer supports\r\n   * @returns Array of supported file categories\r\n   */\r\n  abstract getSupportedFileTypes(): FileCategory[];\r\n\r\n  // ============================================================================\r\n  // Issue Creation Helpers\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Create an issue with proper location tracking\r\n   * @param params Issue parameters\r\n   * @returns Complete Issue object\r\n   */\r\n  protected createIssue(params: {\r\n    type: IssueType;\r\n    severity: Severity;\r\n    category: IssueCategory;\r\n    file: string;\r\n    node: Node;\r\n    description: string;\r\n    recommendation: string;\r\n    estimatedEffort: EffortLevel;\r\n    tags?: string[];\r\n  }): Issue {\r\n    const location = this.getNodeLocation(params.node);\r\n    const codeSnippet = this.getCodeSnippet(params.node);\r\n\r\n    return {\r\n      id: randomUUID(),\r\n      type: params.type,\r\n      severity: params.severity,\r\n      category: params.category,\r\n      file: params.file,\r\n      location,\r\n      description: params.description,\r\n      codeSnippet,\r\n      recommendation: params.recommendation,\r\n      estimatedEffort: params.estimatedEffort,\r\n      tags: params.tags || [],\r\n      detectedBy: this.name,\r\n      detectedAt: new Date(),\r\n      relatedIssues: [],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get the location of a node in the source file\r\n   * @param node AST node\r\n   * @returns Code location with line and column numbers\r\n   */\r\n  protected getNodeLocation(node: Node): CodeLocation {\r\n    const sourceFile = node.getSourceFile();\r\n    const start = node.getStart();\r\n    const end = node.getEnd();\r\n\r\n    const startLineAndColumn = sourceFile.getLineAndColumnAtPos(start);\r\n    const endLineAndColumn = sourceFile.getLineAndColumnAtPos(end);\r\n\r\n    return {\r\n      startLine: startLineAndColumn.line,\r\n      endLine: endLineAndColumn.line,\r\n      startColumn: startLineAndColumn.column,\r\n      endColumn: endLineAndColumn.column,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get a code snippet from a node\r\n   * @param node AST node\r\n   * @param maxLength Maximum length of snippet (default: 200)\r\n   * @returns Code snippet as string\r\n   */\r\n  protected getCodeSnippet(node: Node, maxLength: number = 200): string {\r\n    const text = node.getText();\r\n    if (text.length <= maxLength) {\r\n      return text;\r\n    }\r\n    return text.substring(0, maxLength) + '...';\r\n  }\r\n\r\n  // ============================================================================\r\n  // AST Traversal Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all nodes of a specific kind in the AST\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodesByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (node.getKind() === kind) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes matching a predicate function\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  protected findNodes(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const nodes: Node[] = [];\r\n    \r\n    const traverse = (node: Node) => {\r\n      if (predicate(node)) {\r\n        nodes.push(node);\r\n      }\r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return nodes;\r\n  }\r\n\r\n  /**\r\n   * Get all function declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  protected getFunctionDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all arrow functions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  protected getArrowFunctions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Get all function expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  protected getFunctionExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Get all method declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  protected getMethodDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all class declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  protected getClassDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all interface declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  protected getInterfaceDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all type alias declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  protected getTypeAliases(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all import declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  protected getImportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all export declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  protected getExportDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all variable declarations in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  protected getVariableDeclarations(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Get all if statements in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  protected getIfStatements(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Get all call expressions in the AST\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  protected getCallExpressions(ast: SourceFile): Node[] {\r\n    return this.findNodesByKind(ast, SyntaxKind.CallExpression);\r\n  }\r\n\r\n  // ============================================================================\r\n  // Code Analysis Utilities\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Nesting depth (0 for top-level)\r\n   */\r\n  protected getNestingDepth(node: Node): number {\r\n    let depth = 0;\r\n    let current = node.getParent();\r\n\r\n    while (current) {\r\n      const kind = current.getKind();\r\n      // Count blocks that increase nesting\r\n      if (\r\n        kind === SyntaxKind.IfStatement ||\r\n        kind === SyntaxKind.ForStatement ||\r\n        kind === SyntaxKind.WhileStatement ||\r\n        kind === SyntaxKind.DoStatement ||\r\n        kind === SyntaxKind.SwitchStatement ||\r\n        kind === SyntaxKind.CaseClause ||\r\n        kind === SyntaxKind.TryStatement ||\r\n        kind === SyntaxKind.CatchClause\r\n      ) {\r\n        depth++;\r\n      }\r\n      current = current.getParent();\r\n    }\r\n\r\n    return depth;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific text pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  protected containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  protected getNodeName(node: Node): string | undefined {\r\n    // Try to get name from various node types\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  protected isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    // First check the node itself\r\n    if (nodeWithModifiers.getModifiers) {\r\n      const modifiers = nodeWithModifiers.getModifiers();\r\n      if (modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword)) {\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    // For variable declarations, check the parent VariableStatement\r\n    if (Node.isVariableDeclaration(node)) {\r\n      const parent = node.getParent(); // VariableDeclarationList\r\n      const grandParent = parent?.getParent(); // VariableStatement\r\n      if (grandParent && (grandParent as any).getModifiers) {\r\n        const modifiers = (grandParent as any).getModifiers();\r\n        return modifiers.some((mod: any) => mod.getKind() === SyntaxKind.ExportKeyword);\r\n      }\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get all comments associated with a node\r\n   * @param node AST node\r\n   * @returns Array of comment texts\r\n   */\r\n  protected getComments(node: Node): string[] {\r\n    const comments: string[] = [];\r\n    const sourceFile = node.getSourceFile();\r\n    const fullText = sourceFile.getFullText();\r\n    \r\n    // Get leading comments\r\n    const leadingCommentRanges = node.getLeadingCommentRanges();\r\n    for (const range of leadingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    // Get trailing comments\r\n    const trailingCommentRanges = node.getTrailingCommentRanges();\r\n    for (const range of trailingCommentRanges) {\r\n      comments.push(fullText.substring(range.getPos(), range.getEnd()));\r\n    }\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Count the number of child nodes\r\n   * @param node AST node\r\n   * @returns Number of direct children\r\n   */\r\n  protected getChildCount(node: Node): number {\r\n    return node.getChildCount();\r\n  }\r\n\r\n  /**\r\n   * Get the text length of a node\r\n   * @param node AST node\r\n   * @returns Length in characters\r\n   */\r\n  protected getTextLength(node: Node): number {\r\n    return node.getText().length;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\service-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":385,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13740,13743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13740,13743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Service Pattern Analyzer\r\n * \r\n * Analyzes service layer architecture in the codebase to identify\r\n * inconsistencies, circular dependencies, and unnecessary complexity.\r\n * \r\n * Detects:\r\n * - All service modules in the codebase\r\n * - Service dependencies and import relationships\r\n * - Circular dependencies between services\r\n * - Inconsistent service initialization patterns\r\n * - Unnecessary service abstraction layers\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Pattern for tracking service modules\r\n */\r\ninterface ServiceModule {\r\n  name: string;\r\n  path: string;\r\n  imports: string[];\r\n  exports: string[];\r\n  node: Node;\r\n}\r\n\r\n/**\r\n * Pattern for tracking service dependencies\r\n */\r\ninterface ServiceDependency {\r\n  from: string;\r\n  to: string;\r\n  importNode: Node;\r\n}\r\n\r\n/**\r\n * Analyzer for service layer patterns\r\n */\r\nexport class ServicePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'ServicePatternAnalyzer';\r\n\r\n  // Track all discovered services across files\r\n  private services: Map<string, ServiceModule> = new Map();\r\n  private dependencies: ServiceDependency[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['service'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for service-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 10.1: Discover service modules and analyze dependencies\r\n    issues.push(...this.discoverServiceModule(file, ast));\r\n    issues.push(...this.analyzeServiceDependencies(file, ast));\r\n    issues.push(...this.analyzeServiceImports(file, ast));\r\n\r\n    // Task 10.2: Detect circular dependencies\r\n    // Note: This should be called after all services have been discovered\r\n    // Typically called once after analyzing all files\r\n    issues.push(...this.detectCircularDependencies(file));\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.1: Service Discovery and Analysis\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Discover and catalog service modules\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private discoverServiceModule(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Extract service name from file path\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    \r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get all imports from this service\r\n    const imports = this.getImportDeclarations(ast);\r\n    const importedServices: string[] = [];\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access getModuleSpecifierValue\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Check if this import is from another service\r\n      if (this.isServiceImport(moduleSpecifier)) {\r\n        const importedServiceName = this.extractServiceNameFromImport(moduleSpecifier);\r\n        if (importedServiceName) {\r\n          importedServices.push(importedServiceName);\r\n          \r\n          // Track dependency\r\n          this.dependencies.push({\r\n            from: serviceName,\r\n            to: importedServiceName,\r\n            importNode: importDecl,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Get all exports from this service\r\n    const exports = this.getExportDeclarations(ast);\r\n    const exportedNames: string[] = [];\r\n\r\n    // Get named exports\r\n    for (const exportDecl of exports) {\r\n      // Cast to ExportDeclaration to access getNamedExports\r\n      if (!Node.isExportDeclaration(exportDecl)) continue;\r\n      const namedExports = exportDecl.getNamedExports();\r\n      for (const namedExport of namedExports) {\r\n        exportedNames.push(namedExport.getName());\r\n      }\r\n    }\r\n\r\n    // Get exported functions, classes, and variables\r\n    const functions = ast.getFunctions();\r\n    const classes = this.getClassDeclarations(ast);\r\n    const variables = this.getVariableDeclarations(ast);\r\n\r\n    for (const func of functions) {\r\n      if (this.isExported(func)) {\r\n        const funcName = this.getNodeName(func);\r\n        if (funcName) {\r\n          exportedNames.push(funcName);\r\n        }\r\n      }\r\n    }\r\n\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        const className = this.getNodeName(cls);\r\n        if (className) {\r\n          exportedNames.push(className);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Store service information\r\n    const serviceModule: ServiceModule = {\r\n      name: serviceName,\r\n      path: file.relativePath,\r\n      imports: importedServices,\r\n      exports: exportedNames,\r\n      node: ast,\r\n    };\r\n\r\n    this.services.set(serviceName, serviceModule);\r\n\r\n    // Check if service has no exports (might be incomplete or unused)\r\n    if (exportedNames.length === 0) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service module '${serviceName}' has no exports. This might indicate an incomplete implementation or an unused service file.`,\r\n          recommendation: 'Either add exports to make this service usable, or remove the file if it\\'s no longer needed. Services should export functions, classes, or objects that provide specific functionality.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'architecture', 'unused-code'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service dependencies for patterns and issues\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceDependencies(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Get dependencies for this service\r\n    const serviceDeps = this.dependencies.filter(dep => dep.from === serviceName);\r\n\r\n    // Check for excessive dependencies (might indicate poor separation of concerns)\r\n    if (serviceDeps.length > 5) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' depends on ${serviceDeps.length} other services. This high number of dependencies suggests the service might have unclear responsibilities or be doing too much.`,\r\n          recommendation: 'Consider breaking this service into smaller, more focused services with clearer responsibilities. Each service should have a single, well-defined purpose. Review the dependencies to see if some functionality could be consolidated or if the service is mixing concerns.',\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'separation-of-concerns'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for duplicate imports (same service imported multiple times)\r\n    const importCounts = new Map<string, number>();\r\n    for (const dep of serviceDeps) {\r\n      importCounts.set(dep.to, (importCounts.get(dep.to) || 0) + 1);\r\n    }\r\n\r\n    for (const [importedService, count] of importCounts.entries()) {\r\n      if (count > 1) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Service '${importedService}' is imported ${count} times in this file. This might indicate duplicate import statements or inconsistent import patterns.`,\r\n            recommendation: 'Consolidate imports from the same service into a single import statement. This improves code readability and reduces redundancy.',\r\n            estimatedEffort: 'trivial',\r\n            tags: ['service', 'imports', 'code-quality'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Analyze service import patterns and relationships\r\n   * Validates Requirements: 5.1\r\n   */\r\n  private analyzeServiceImports(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const imports = this.getImportDeclarations(ast);\r\n    \r\n    // Track import patterns\r\n    const importPatterns = {\r\n      defaultImports: 0,\r\n      namedImports: 0,\r\n      namespaceImports: 0,\r\n      sideEffectImports: 0,\r\n    };\r\n\r\n    for (const importDecl of imports) {\r\n      // Cast to ImportDeclaration to access import methods\r\n      if (!Node.isImportDeclaration(importDecl)) continue;\r\n      const moduleSpecifier = importDecl.getModuleSpecifierValue();\r\n      \r\n      // Only analyze service imports\r\n      if (!this.isServiceImport(moduleSpecifier)) {\r\n        continue;\r\n      }\r\n\r\n      // Check import type\r\n      const defaultImport = importDecl.getDefaultImport();\r\n      const namedImports = importDecl.getNamedImports();\r\n      const namespaceImport = importDecl.getNamespaceImport();\r\n\r\n      if (defaultImport) {\r\n        importPatterns.defaultImports++;\r\n      }\r\n      \r\n      if (namedImports.length > 0) {\r\n        importPatterns.namedImports++;\r\n      }\r\n      \r\n      if (namespaceImport) {\r\n        importPatterns.namespaceImports++;\r\n      }\r\n      \r\n      if (!defaultImport && namedImports.length === 0 && !namespaceImport) {\r\n        importPatterns.sideEffectImports++;\r\n      }\r\n\r\n      // Check for relative imports that go up multiple levels\r\n      if (moduleSpecifier.startsWith('../')) {\r\n        const levels = (moduleSpecifier.match(/\\.\\.\\//g) || []).length;\r\n        \r\n        if (levels > 2) {\r\n          issues.push(\r\n            this.createIssue({\r\n              type: 'inconsistent-pattern',\r\n              severity: 'low',\r\n              category: 'services',\r\n              file: file.relativePath,\r\n              node: importDecl,\r\n              description: `Import uses ${levels} levels of relative path traversal (${moduleSpecifier}). This makes the code harder to refactor and understand.`,\r\n              recommendation: 'Consider using absolute imports or path aliases (e.g., @/services/...) instead of deep relative imports. This makes imports more maintainable and less fragile during refactoring.',\r\n              estimatedEffort: 'trivial',\r\n              tags: ['service', 'imports', 'maintainability'],\r\n            })\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for inconsistent import patterns\r\n    const totalServiceImports = importPatterns.defaultImports + \r\n                                importPatterns.namedImports + \r\n                                importPatterns.namespaceImports;\r\n\r\n    if (totalServiceImports > 2) {\r\n      // If we have a mix of default and named imports, flag it\r\n      if (importPatterns.defaultImports > 0 && importPatterns.namedImports > 0) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'low',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: ast,\r\n            description: `Inconsistent import patterns detected: ${importPatterns.defaultImports} default imports and ${importPatterns.namedImports} named imports from services. This inconsistency can make the codebase harder to understand.`,\r\n            recommendation: 'Standardize on either default exports or named exports for services. Named exports are generally preferred as they provide better IDE support and make refactoring easier.',\r\n            estimatedEffort: 'small',\r\n            tags: ['service', 'imports', 'consistency'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.2: Circular Dependency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect circular dependencies between services\r\n   * Validates Requirements: 5.3\r\n   * \r\n   * Uses depth-first search to detect cycles in the dependency graph.\r\n   * A circular dependency exists when service A depends on service B,\r\n   * and service B (directly or indirectly) depends on service A.\r\n   */\r\n  private detectCircularDependencies(file: FileInfo): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Build dependency graph\r\n    const graph = this.buildDependencyGraph();\r\n\r\n    // Find all cycles that include this service\r\n    const cycles = this.findCyclesInGraph(graph, serviceName);\r\n\r\n    // Create issues for each unique cycle\r\n    for (const cycle of cycles) {\r\n      // Only report the cycle once (from the first service in the cycle alphabetically)\r\n      // This prevents duplicate reports for the same cycle\r\n      const sortedCycle = [...cycle].sort();\r\n      if (sortedCycle[0] !== serviceName) {\r\n        continue;\r\n      }\r\n\r\n      const cycleDescription = cycle.join(' → ') + ' → ' + cycle[0];\r\n      \r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'architectural',\r\n          severity: 'high',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: this.services.get(serviceName)?.node || file as any,\r\n          description: `Circular dependency detected: ${cycleDescription}. This creates tight coupling between services and can lead to initialization problems, testing difficulties, and maintenance issues.`,\r\n          recommendation: `Break the circular dependency by:\r\n1. Extracting shared functionality into a separate service that both services can depend on\r\n2. Using dependency injection to invert the dependency\r\n3. Refactoring to remove the need for one of the dependencies\r\n4. Using events or a message bus to decouple the services\r\n\r\nCircular dependencies are a serious architectural issue that should be resolved to improve code maintainability and testability.`,\r\n          estimatedEffort: 'large',\r\n          tags: ['service', 'architecture', 'circular-dependency', 'coupling'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Build a dependency graph from discovered services\r\n   * Returns a Map where keys are service names and values are arrays of dependent service names\r\n   */\r\n  private buildDependencyGraph(): Map<string, string[]> {\r\n    const graph = new Map<string, string[]>();\r\n\r\n    // Initialize graph with all services\r\n    for (const serviceName of this.services.keys()) {\r\n      graph.set(serviceName, []);\r\n    }\r\n\r\n    // Add dependencies\r\n    for (const dep of this.dependencies) {\r\n      const deps = graph.get(dep.from) || [];\r\n      // Only add if the target service exists in our discovered services\r\n      if (this.services.has(dep.to)) {\r\n        deps.push(dep.to);\r\n        graph.set(dep.from, deps);\r\n      }\r\n    }\r\n\r\n    return graph;\r\n  }\r\n\r\n  /**\r\n   * Find all cycles in the dependency graph that include the given service\r\n   * Uses depth-first search with cycle detection\r\n   */\r\n  private findCyclesInGraph(graph: Map<string, string[]>, startService: string): string[][] {\r\n    const cycles: string[][] = [];\r\n    const visited = new Set<string>();\r\n    const recursionStack = new Set<string>();\r\n    const path: string[] = [];\r\n\r\n    /**\r\n     * Depth-first search to detect cycles\r\n     */\r\n    const dfs = (service: string): void => {\r\n      visited.add(service);\r\n      recursionStack.add(service);\r\n      path.push(service);\r\n\r\n      const dependencies = graph.get(service) || [];\r\n\r\n      for (const dep of dependencies) {\r\n        if (!visited.has(dep)) {\r\n          // Continue DFS\r\n          dfs(dep);\r\n        } else if (recursionStack.has(dep)) {\r\n          // Found a cycle!\r\n          // Extract the cycle from the path\r\n          const cycleStartIndex = path.indexOf(dep);\r\n          if (cycleStartIndex !== -1) {\r\n            const cycle = path.slice(cycleStartIndex);\r\n            \r\n            // Only include cycles that contain the start service\r\n            if (cycle.includes(startService)) {\r\n              // Normalize the cycle to start with the lexicographically smallest service\r\n              // This helps with deduplication\r\n              const minIndex = cycle.indexOf(\r\n                cycle.reduce((min, curr) => (curr < min ? curr : min))\r\n              );\r\n              const normalizedCycle = [\r\n                ...cycle.slice(minIndex),\r\n                ...cycle.slice(0, minIndex),\r\n              ];\r\n              \r\n              // Check if we've already found this cycle\r\n              const cycleKey = normalizedCycle.join('→');\r\n              const isDuplicate = cycles.some(\r\n                existingCycle => existingCycle.join('→') === cycleKey\r\n              );\r\n              \r\n              if (!isDuplicate) {\r\n                cycles.push(normalizedCycle);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      path.pop();\r\n      recursionStack.delete(service);\r\n    };\r\n\r\n    // Start DFS from the given service\r\n    dfs(startService);\r\n\r\n    return cycles;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 10.3: Service Pattern Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect inconsistent service initialization and configuration patterns\r\n   * Validates Requirements: 5.4\r\n   */\r\n  private detectInconsistentInitialization(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Track initialization patterns found in this service\r\n    const initPatterns = {\r\n      hasConstructor: false,\r\n      hasInitFunction: false,\r\n      hasConfigObject: false,\r\n      hasFactoryFunction: false,\r\n      hasSingletonPattern: false,\r\n      hasDirectExports: false,\r\n    };\r\n\r\n    // Check for class-based services with constructors\r\n    const classes = this.getClassDeclarations(ast);\r\n    for (const cls of classes) {\r\n      if (this.isExported(cls)) {\r\n        // Cast to ClassDeclaration to access getConstructors\r\n        if (!Node.isClassDeclaration(cls)) continue;\r\n        const constructors = cls.getConstructors();\r\n        if (constructors.length > 0) {\r\n          initPatterns.hasConstructor = true;\r\n          \r\n          // Check if constructor has parameters (dependency injection)\r\n          const constructor = constructors[0];\r\n          const params = constructor.getParameters();\r\n          \r\n          // Flag constructors with too many parameters (poor design)\r\n          if (params.length > 5) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'medium',\r\n                category: 'services',\r\n                file: file.relativePath,\r\n                node: constructor,\r\n                description: `Service class constructor has ${params.length} parameters. This high number of dependencies suggests the service might be doing too much or have unclear responsibilities.`,\r\n                recommendation: 'Consider breaking this service into smaller, more focused services. Use the Single Responsibility Principle: each service should have one clear purpose. If many dependencies are needed, consider using a configuration object or builder pattern instead of individual parameters.',\r\n                estimatedEffort: 'medium',\r\n                tags: ['service', 'initialization', 'constructor', 'dependencies'],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for init/initialize/setup functions\r\n    const functions = ast.getFunctions();\r\n    for (const func of functions) {\r\n      const funcName = this.getNodeName(func);\r\n      if (funcName && /^(init|initialize|setup|configure|config)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasInitFunction = true;\r\n        }\r\n      }\r\n      \r\n      // Check for factory functions (create*, make*, build*)\r\n      if (funcName && /^(create|make|build|get)/i.test(funcName)) {\r\n        if (this.isExported(func)) {\r\n          initPatterns.hasFactoryFunction = true;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for configuration objects\r\n    const variables = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variables) {\r\n      const varName = this.getNodeName(varDecl);\r\n      if (varName && /config|options|settings/i.test(varName)) {\r\n        if (this.isExported(varDecl)) {\r\n          initPatterns.hasConfigObject = true;\r\n        }\r\n      }\r\n      \r\n      // Check for singleton pattern (instance variable)\r\n      if (varName && /instance|singleton/i.test(varName)) {\r\n        initPatterns.hasSingletonPattern = true;\r\n      }\r\n    }\r\n\r\n    // Check for direct function exports (functional style)\r\n    const exportedFunctions = functions.filter(f => this.isExported(f));\r\n    if (exportedFunctions.length > 0 && !initPatterns.hasConstructor) {\r\n      initPatterns.hasDirectExports = true;\r\n    }\r\n\r\n    // Detect mixed initialization patterns (inconsistency)\r\n    const patternCount = [\r\n      initPatterns.hasConstructor,\r\n      initPatterns.hasInitFunction,\r\n      initPatterns.hasFactoryFunction,\r\n      initPatterns.hasSingletonPattern,\r\n    ].filter(Boolean).length;\r\n\r\n    if (patternCount > 1) {\r\n      const patterns: string[] = [];\r\n      if (initPatterns.hasConstructor) patterns.push('class constructor');\r\n      if (initPatterns.hasInitFunction) patterns.push('init/setup function');\r\n      if (initPatterns.hasFactoryFunction) patterns.push('factory function');\r\n      if (initPatterns.hasSingletonPattern) patterns.push('singleton pattern');\r\n\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'medium',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' uses multiple initialization patterns: ${patterns.join(', ')}. This inconsistency makes the service harder to understand and use correctly.`,\r\n          recommendation: 'Standardize on a single initialization pattern for this service. Choose one approach:\\n1. Class-based with constructor injection (good for stateful services)\\n2. Factory functions (good for creating instances)\\n3. Direct function exports (good for stateless utilities)\\n4. Singleton pattern (use sparingly, only when truly needed)\\n\\nConsistency in initialization patterns makes the codebase more predictable and easier to maintain.',\r\n          estimatedEffort: 'medium',\r\n          tags: ['service', 'initialization', 'consistency', 'pattern'],\r\n        })\r\n      );\r\n    }\r\n\r\n    // Check for services with no clear initialization pattern\r\n    if (patternCount === 0 && !initPatterns.hasDirectExports) {\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'inconsistent-pattern',\r\n          severity: 'low',\r\n          category: 'services',\r\n          file: file.relativePath,\r\n          node: ast,\r\n          description: `Service '${serviceName}' has no clear initialization pattern. It's unclear how this service should be instantiated or configured.`,\r\n          recommendation: 'Add a clear initialization pattern to this service. Consider:\\n1. Exporting a class with a constructor\\n2. Exporting a factory function (e.g., createService())\\n3. Exporting direct functions if this is a stateless utility\\n\\nClear initialization patterns make services easier to use and test.',\r\n          estimatedEffort: 'small',\r\n          tags: ['service', 'initialization', 'clarity'],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary service abstraction layers\r\n   * Validates Requirements: 5.5\r\n   */\r\n  private detectUnnecessaryAbstractions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    const serviceName = this.extractServiceName(file.relativePath);\r\n    if (!serviceName) {\r\n      return issues;\r\n    }\r\n\r\n    // Check all exported functions for pass-through behavior\r\n    const functions = ast.getFunctions();\r\n    \r\n    for (const func of functions) {\r\n      if (!this.isExported(func)) {\r\n        continue;\r\n      }\r\n\r\n      const funcName = this.getNodeName(func);\r\n      if (!funcName) {\r\n        continue;\r\n      }\r\n\r\n      // Get function body\r\n      const body = func.getBody();\r\n      if (!body || !Node.isBlock(body)) {\r\n        continue;\r\n      }\r\n\r\n      const statements = body.getStatements();\r\n      \r\n      // Check for single-statement functions (potential pass-through)\r\n      if (statements.length === 1) {\r\n        const statement = statements[0];\r\n        \r\n        // Check if it's a return statement\r\n        if (Node.isReturnStatement(statement)) {\r\n          const returnExpr = statement.getExpression();\r\n          \r\n          if (returnExpr) {\r\n            // Check if it's a simple call expression (pass-through)\r\n            if (Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if parameters are just passed through\r\n              const funcParams = func.getParameters();\r\n              const callArgs = callExpr.getArguments();\r\n              \r\n              // Simple heuristic: if parameter count matches and function just calls another function\r\n              if (funcParams.length === callArgs.length) {\r\n                // Check if all arguments are simple identifiers matching parameters\r\n                let isSimplePassThrough = true;\r\n                const paramNames = funcParams.map(p => p.getName());\r\n                \r\n                for (let i = 0; i < callArgs.length; i++) {\r\n                  const arg = callArgs[i];\r\n                  if (Node.isIdentifier(arg)) {\r\n                    if (arg.getText() !== paramNames[i]) {\r\n                      isSimplePassThrough = false;\r\n                      break;\r\n                    }\r\n                  } else {\r\n                    // Argument is not a simple identifier\r\n                    isSimplePassThrough = false;\r\n                    break;\r\n                  }\r\n                }\r\n                \r\n                if (isSimplePassThrough) {\r\n                  const calledFunctionName = calledExpr.getText();\r\n                  \r\n                  issues.push(\r\n                    this.createIssue({\r\n                      type: 'unnecessary-adapter',\r\n                      severity: 'low',\r\n                      category: 'services',\r\n                      file: file.relativePath,\r\n                      node: func,\r\n                      description: `Function '${funcName}' is a simple pass-through wrapper that just calls '${calledFunctionName}' with the same parameters. This abstraction layer adds no value and increases code complexity.`,\r\n                      recommendation: `Consider removing this wrapper function and using '${calledFunctionName}' directly. If this wrapper exists for a specific reason (e.g., to provide a stable API while the implementation changes), document that reason clearly. Otherwise, unnecessary abstraction layers make code harder to navigate and maintain.`,\r\n                      estimatedEffort: 'trivial',\r\n                      tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                    })\r\n                  );\r\n                }\r\n              }\r\n            }\r\n            \r\n            // Check for simple property access pass-through\r\n            if (Node.isPropertyAccessExpression(returnExpr)) {\r\n              issues.push(\r\n                this.createIssue({\r\n                  type: 'unnecessary-adapter',\r\n                  severity: 'low',\r\n                  category: 'services',\r\n                  file: file.relativePath,\r\n                  node: func,\r\n                  description: `Function '${funcName}' simply returns a property access (${returnExpr.getText()}). This adds an unnecessary abstraction layer.`,\r\n                  recommendation: 'Consider exposing the property directly or removing this wrapper function. Simple property access wrappers add little value and make code harder to follow.',\r\n                  estimatedEffort: 'trivial',\r\n                  tags: ['service', 'abstraction', 'wrapper', 'property-access'],\r\n                })\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Check for functions with only trivial transformations\r\n      if (statements.length === 2) {\r\n        // Pattern: const result = someCall(); return result;\r\n        const firstStmt = statements[0];\r\n        const secondStmt = statements[1];\r\n        \r\n        if (Node.isVariableStatement(firstStmt) && Node.isReturnStatement(secondStmt)) {\r\n          const varDecls = firstStmt.getDeclarations();\r\n          if (varDecls.length === 1) {\r\n            const varDecl = varDecls[0];\r\n            const varName = varDecl.getName();\r\n            const returnExpr = secondStmt.getExpression();\r\n            \r\n            // Check if return statement just returns the variable\r\n            if (returnExpr && Node.isIdentifier(returnExpr) && returnExpr.getText() === varName) {\r\n              const initializer = varDecl.getInitializer();\r\n              \r\n              if (initializer && Node.isCallExpression(initializer)) {\r\n                // This is a pass-through with an intermediate variable\r\n                issues.push(\r\n                  this.createIssue({\r\n                    type: 'unnecessary-adapter',\r\n                    severity: 'low',\r\n                    category: 'services',\r\n                    file: file.relativePath,\r\n                    node: func,\r\n                    description: `Function '${funcName}' is a pass-through wrapper that calls another function and immediately returns the result without any transformation or additional logic.`,\r\n                    recommendation: 'Consider removing this wrapper function unless it serves a specific architectural purpose (e.g., providing a stable API, adding logging, or handling errors). Document the reason if the wrapper is intentional.',\r\n                    estimatedEffort: 'trivial',\r\n                    tags: ['service', 'abstraction', 'wrapper', 'pass-through'],\r\n                  })\r\n                );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for wrapper classes that just delegate to another class\r\n    const classes = this.getClassDeclarations(ast);\r\n    \r\n    for (const cls of classes) {\r\n      if (!this.isExported(cls)) {\r\n        continue;\r\n      }\r\n\r\n      const className = this.getNodeName(cls);\r\n      if (!className) {\r\n        continue;\r\n      }\r\n\r\n      // Cast to ClassDeclaration to access getMethods\r\n      if (!Node.isClassDeclaration(cls)) continue;\r\n      const methods = cls.getMethods();\r\n      let passThroughMethodCount = 0;\r\n      \r\n      for (const method of methods) {\r\n        const methodBody = method.getBody();\r\n        if (!methodBody || !Node.isBlock(methodBody)) {\r\n          continue;\r\n        }\r\n\r\n        const statements = methodBody.getStatements();\r\n        \r\n        // Check for single-statement methods that just delegate\r\n        if (statements.length === 1) {\r\n          const statement = statements[0];\r\n          \r\n          if (Node.isReturnStatement(statement)) {\r\n            const returnExpr = statement.getExpression();\r\n            \r\n            if (returnExpr && Node.isCallExpression(returnExpr)) {\r\n              const callExpr = returnExpr;\r\n              const calledExpr = callExpr.getExpression();\r\n              \r\n              // Check if it's calling a method on a member variable (delegation)\r\n              if (Node.isPropertyAccessExpression(calledExpr)) {\r\n                passThroughMethodCount++;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If most methods are pass-through, flag the class as unnecessary abstraction\r\n      if (methods.length > 0 && passThroughMethodCount / methods.length > 0.7) {\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'unnecessary-adapter',\r\n            severity: 'medium',\r\n            category: 'services',\r\n            file: file.relativePath,\r\n            node: cls,\r\n            description: `Class '${className}' appears to be a wrapper class where ${passThroughMethodCount} out of ${methods.length} methods simply delegate to another object. This abstraction layer may be unnecessary.`,\r\n            recommendation: 'Consider whether this wrapper class is needed. If it\\'s just delegating calls without adding value (no error handling, logging, transformation, or business logic), consider using the wrapped class directly. If the wrapper serves a specific purpose (e.g., adapter pattern for third-party libraries, providing a stable API), document that clearly.',\r\n            estimatedEffort: 'medium',\r\n            tags: ['service', 'abstraction', 'wrapper', 'delegation', 'class'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Helper Methods\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Extract service name from file path\r\n   * Examples:\r\n   *   backend/services/user/index.ts -> user\r\n   *   backend/services/auth/auth-service.ts -> auth\r\n   *   services/database/db.ts -> database\r\n   */\r\n  private extractServiceName(filePath: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = filePath.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: backend/services/NAME/... or services/NAME/...\r\n    const serviceMatch = normalizedPath.match(/(?:backend\\/)?services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Check if an import is from a service module\r\n   */\r\n  private isServiceImport(moduleSpecifier: string): boolean {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Check for service imports\r\n    return normalizedPath.includes('/services/') || \r\n           normalizedPath.includes('services/') ||\r\n           normalizedPath.startsWith('@/services/') ||\r\n           normalizedPath.startsWith('~/services/');\r\n  }\r\n\r\n  /**\r\n   * Extract service name from import path\r\n   */\r\n  private extractServiceNameFromImport(moduleSpecifier: string): string | null {\r\n    // Normalize path separators\r\n    const normalizedPath = moduleSpecifier.replace(/\\\\/g, '/');\r\n    \r\n    // Match patterns like: ../services/NAME or @/services/NAME\r\n    const serviceMatch = normalizedPath.match(/services\\/([^\\/]+)/);\r\n    \r\n    if (serviceMatch) {\r\n      return serviceMatch[1];\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Get all discovered services\r\n   * This can be used by other analyzers or for reporting\r\n   */\r\n  public getDiscoveredServices(): Map<string, ServiceModule> {\r\n    return this.services;\r\n  }\r\n\r\n  /**\r\n   * Get all service dependencies\r\n   * This can be used for circular dependency detection\r\n   */\r\n  public getServiceDependencies(): ServiceDependency[] {\r\n    return this.dependencies;\r\n  }\r\n\r\n  /**\r\n   * Clear the analyzer state (useful for testing or re-analysis)\r\n   */\r\n  public reset(): void {\r\n    this.services.clear();\r\n    this.dependencies = [];\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\analyzers\\type-pattern-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":327,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10170,10173],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10170,10173],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":756,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":756,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26109,26112],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26109,26112],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Type Pattern Analyzer\r\n * \r\n * Analyzes TypeScript type definitions and usage patterns in the codebase\r\n * to identify inconsistencies, redundancies, and type safety issues.\r\n * \r\n * Detects:\r\n * - All type definitions (interfaces, types, enums)\r\n * - Type usage across files\r\n * - Duplicate type definitions\r\n * - Inconsistent type definitions for same entities\r\n * - Excessive 'any' type usage\r\n * - Type assertions that could be avoided\r\n * - Mismatches between Supabase generated types and manual types\r\n */\r\n\r\nimport { SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport { BasePatternAnalyzer } from './pattern-analyzer.js';\r\nimport type { FileInfo, Issue, FileCategory } from '../types.js';\r\n\r\n/**\r\n * Information about a type definition\r\n */\r\ninterface TypeDefinition {\r\n  name: string;\r\n  kind: 'interface' | 'type' | 'enum';\r\n  node: Node;\r\n  file: string;\r\n  definition: string;\r\n}\r\n\r\n/**\r\n * Information about type usage\r\n */\r\ninterface TypeUsage {\r\n  typeName: string;\r\n  node: Node;\r\n  file: string;\r\n  context: string; // 'variable' | 'parameter' | 'return' | 'property'\r\n}\r\n\r\n/**\r\n * Analyzer for TypeScript type patterns\r\n */\r\nexport class TypePatternAnalyzer extends BasePatternAnalyzer {\r\n  readonly name = 'TypePatternAnalyzer';\r\n\r\n  // Track type definitions across files for cross-file analysis\r\n  private typeDefinitions: TypeDefinition[] = [];\r\n  private typeUsages: TypeUsage[] = [];\r\n\r\n  /**\r\n   * Get supported file types for this analyzer\r\n   */\r\n  getSupportedFileTypes(): FileCategory[] {\r\n    return ['type', 'component', 'api-route', 'service', 'util'];\r\n  }\r\n\r\n  /**\r\n   * Analyze a file for type-related issues\r\n   */\r\n  async analyze(file: FileInfo, ast: SourceFile): Promise<Issue[]> {\r\n    const issues: Issue[] = [];\r\n\r\n    // Task 8.1: Find all type definitions and track type usage\r\n    this.discoverTypeDefinitions(file, ast);\r\n    this.trackTypeUsage(file, ast);\r\n\r\n    // Task 8.2: Detect type inconsistencies\r\n    // Note: This requires cross-file analysis, so we detect issues after all files are analyzed\r\n    // The detectTypeInconsistencies() method should be called after analyzing all files\r\n\r\n    // Task 8.3: Detect type safety issues\r\n    issues.push(...this.detectExcessiveAnyUsage(file, ast));\r\n    issues.push(...this.detectUnnecessaryTypeAssertions(file, ast));\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect type inconsistencies across all analyzed files\r\n   * This method should be called after all files have been analyzed\r\n   * Validates Requirements: 7.2, 7.4, 7.5\r\n   */\r\n  public detectTypeInconsistencies(): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Detect duplicate type definitions for the same entities\r\n    issues.push(...this.detectDuplicateTypeDefinitions());\r\n\r\n    // Detect mismatches between Supabase types and manual types\r\n    issues.push(...this.detectSupabaseTypeMismatches());\r\n\r\n    return issues;\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.1: Type Definition Discovery\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Find all type definitions (interfaces, types, enums) in the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private discoverTypeDefinitions(file: FileInfo, ast: SourceFile): void {\r\n    // Find all interface declarations\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const name = interfaceDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'interface',\r\n        node: interfaceDecl,\r\n        file: file.relativePath,\r\n        definition: interfaceDecl.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all type alias declarations\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const name = typeAlias.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'type',\r\n        node: typeAlias,\r\n        file: file.relativePath,\r\n        definition: typeAlias.getText(),\r\n      });\r\n    }\r\n\r\n    // Find all enum declarations\r\n    const enums = ast.getEnums();\r\n    for (const enumDecl of enums) {\r\n      const name = enumDecl.getName();\r\n      \r\n      this.typeDefinitions.push({\r\n        name,\r\n        kind: 'enum',\r\n        node: enumDecl,\r\n        file: file.relativePath,\r\n        definition: enumDecl.getText(),\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track type usage across the file\r\n   * Validates Requirements: 7.1\r\n   */\r\n  private trackTypeUsage(file: FileInfo, ast: SourceFile): void {\r\n    // Track type usage in variable declarations\r\n    const variableDeclarations = this.getVariableDeclarations(ast);\r\n    for (const varDecl of variableDeclarations) {\r\n      // Cast to VariableDeclaration to access getTypeNode\r\n      if (!Node.isVariableDeclaration(varDecl)) continue;\r\n      const typeNode = varDecl.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: varDecl,\r\n            file: file.relativePath,\r\n            context: 'variable',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in function parameters\r\n    const functions = [\r\n      ...ast.getFunctions(),\r\n      ...this.findNodesByKind(ast, SyntaxKind.ArrowFunction),\r\n      ...this.findNodesByKind(ast, SyntaxKind.FunctionExpression),\r\n      ...this.findNodesByKind(ast, SyntaxKind.MethodDeclaration),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const parameters = this.getFunctionParameters(func);\r\n      for (const param of parameters) {\r\n        // Cast to ParameterDeclaration to access getTypeNode\r\n        if (!Node.isParameterDeclaration(param)) continue;\r\n        const typeNode = param.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: param,\r\n              file: file.relativePath,\r\n              context: 'parameter',\r\n            });\r\n          }\r\n        }\r\n      }\r\n\r\n      // Track return type usage\r\n      // Check if this is a function-like node with getReturnTypeNode\r\n      let returnTypeNode: Node | undefined;\r\n      if (Node.isFunctionDeclaration(func) || Node.isArrowFunction(func) || \r\n          Node.isFunctionExpression(func) || Node.isMethodDeclaration(func)) {\r\n        returnTypeNode = func.getReturnTypeNode();\r\n      }\r\n      if (returnTypeNode) {\r\n        const typeName = this.extractTypeName(returnTypeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: func,\r\n            file: file.relativePath,\r\n            context: 'return',\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Track type usage in interface/type properties\r\n    const interfaces = ast.getInterfaces();\r\n    for (const interfaceDecl of interfaces) {\r\n      const properties = interfaceDecl.getProperties();\r\n      for (const prop of properties) {\r\n        const typeNode = prop.getTypeNode();\r\n        if (typeNode) {\r\n          const typeName = this.extractTypeName(typeNode);\r\n          if (typeName) {\r\n            this.typeUsages.push({\r\n              typeName,\r\n              node: prop,\r\n              file: file.relativePath,\r\n              context: 'property',\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const typeAliases = ast.getTypeAliases();\r\n    for (const typeAlias of typeAliases) {\r\n      const typeNode = typeAlias.getTypeNode();\r\n      if (typeNode) {\r\n        const typeName = this.extractTypeName(typeNode);\r\n        if (typeName) {\r\n          this.typeUsages.push({\r\n            typeName,\r\n            node: typeAlias,\r\n            file: file.relativePath,\r\n            context: 'property',\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract the type name from a type node\r\n   * Handles simple types, generic types, and complex type expressions\r\n   */\r\n  private extractTypeName(typeNode: Node): string | null {\r\n    const typeText = typeNode.getText();\r\n\r\n    // Handle simple type references (e.g., \"User\", \"string\", \"number\")\r\n    if (/^[A-Z][a-zA-Z0-9_]*$/.test(typeText)) {\r\n      return typeText;\r\n    }\r\n\r\n    // Handle generic types (e.g., \"Array<User>\", \"Promise<User>\")\r\n    const genericMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)<(.+)>$/);\r\n    if (genericMatch) {\r\n      // Return the inner type for tracking\r\n      return this.extractTypeName({ getText: () => genericMatch[2] } as Node);\r\n    }\r\n\r\n    // Handle union types (e.g., \"User | null\")\r\n    if (typeText.includes('|')) {\r\n      const types = typeText.split('|').map(t => t.trim());\r\n      // Return the first non-primitive type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle intersection types (e.g., \"User & Timestamps\")\r\n    if (typeText.includes('&')) {\r\n      const types = typeText.split('&').map(t => t.trim());\r\n      // Return the first type\r\n      for (const type of types) {\r\n        if (/^[A-Z][a-zA-Z0-9_]*$/.test(type)) {\r\n          return type;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Handle array types (e.g., \"User[]\")\r\n    const arrayMatch = typeText.match(/^([A-Z][a-zA-Z0-9_]*)\\[\\]$/);\r\n    if (arrayMatch) {\r\n      return arrayMatch[1];\r\n    }\r\n\r\n    // Handle Supabase Database types (e.g., \"Database['public']['Tables']['users']['Row']\")\r\n    if (typeText.includes('Database[')) {\r\n      const tableMatch = typeText.match(/\\['Tables'\\]\\['([^']+)'\\]/);\r\n      if (tableMatch) {\r\n        // Return a normalized name for the table type\r\n        return `Db${this.capitalize(tableMatch[1])}`;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Capitalize the first letter of a string\r\n   */\r\n  private capitalize(str: string): string {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n  }\r\n\r\n  /**\r\n   * Get parameters from a function node\r\n   */\r\n  private getFunctionParameters(func: Node): Node[] {\r\n    const funcWithParams = func as any;\r\n    if (funcWithParams.getParameters && typeof funcWithParams.getParameters === 'function') {\r\n      return funcWithParams.getParameters();\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API for accessing tracked data\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Get all discovered type definitions\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeDefinitions(): TypeDefinition[] {\r\n    return this.typeDefinitions;\r\n  }\r\n\r\n  /**\r\n   * Get all tracked type usages\r\n   * Useful for cross-file analysis and reporting\r\n   */\r\n  public getTypeUsages(): TypeUsage[] {\r\n    return this.typeUsages;\r\n  }\r\n\r\n  /**\r\n   * Get type definitions by name\r\n   */\r\n  public getTypeDefinitionsByName(name: string): TypeDefinition[] {\r\n    return this.typeDefinitions.filter(def => def.name === name);\r\n  }\r\n\r\n  /**\r\n   * Get type usages by name\r\n   */\r\n  public getTypeUsagesByName(name: string): TypeUsage[] {\r\n    return this.typeUsages.filter(usage => usage.typeName === name);\r\n  }\r\n\r\n  /**\r\n   * Clear tracked data (useful for testing or re-analysis)\r\n   */\r\n  public clearTrackedData(): void {\r\n    this.typeDefinitions = [];\r\n    this.typeUsages = [];\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.2: Type Inconsistency Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect duplicate type definitions for the same entities\r\n   * Validates Requirements: 7.2, 7.4\r\n   */\r\n  private detectDuplicateTypeDefinitions(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    const typesByName = new Map<string, TypeDefinition[]>();\r\n\r\n    // Group type definitions by name\r\n    for (const typeDef of this.typeDefinitions) {\r\n      const existing = typesByName.get(typeDef.name) || [];\r\n      existing.push(typeDef);\r\n      typesByName.set(typeDef.name, existing);\r\n    }\r\n\r\n    // Check for duplicates\r\n    for (const [typeName, definitions] of typesByName.entries()) {\r\n      if (definitions.length > 1) {\r\n        // We have duplicate type definitions\r\n        const files = definitions.map(d => d.file).join(', ');\r\n        \r\n        // Check if definitions are identical or different\r\n        const uniqueDefinitions = new Set(definitions.map(d => this.normalizeTypeDefinition(d.definition)));\r\n        \r\n        if (uniqueDefinitions.size === 1) {\r\n          // Identical definitions - code duplication\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'code-duplication',\r\n                severity: 'medium',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Duplicate type definition '${typeName}' found in ${definitions.length} files: ${files}`,\r\n                recommendation: `Consolidate the type definition '${typeName}' into a single shared type file and import it where needed. This reduces maintenance burden and ensures consistency.`,\r\n                estimatedEffort: 'small',\r\n                tags: ['duplicate-type', 'type-consolidation', typeName],\r\n              })\r\n            );\r\n          }\r\n        } else {\r\n          // Different definitions - inconsistent types\r\n          for (const def of definitions) {\r\n            issues.push(\r\n              this.createIssue({\r\n                type: 'inconsistent-pattern',\r\n                severity: 'high',\r\n                category: 'types',\r\n                file: def.file,\r\n                node: def.node,\r\n                description: `Inconsistent type definition for '${typeName}' found across ${definitions.length} files: ${files}. The definitions differ in structure or properties.`,\r\n                recommendation: `Review all definitions of '${typeName}' and establish a single canonical definition. Ensure all usages align with the canonical type. Consider if these should be different types with different names.`,\r\n                estimatedEffort: 'medium',\r\n                tags: ['inconsistent-type', 'type-mismatch', typeName],\r\n              })\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect mismatches between Supabase generated types and manual type definitions\r\n   * Validates Requirements: 7.5\r\n   */\r\n  private detectSupabaseTypeMismatches(): Issue[] {\r\n    const issues: Issue[] = [];\r\n    \r\n    // Find Supabase database type definitions\r\n    const supabaseTypes = this.typeDefinitions.filter(def => \r\n      def.file.includes('database.types') || \r\n      def.file.includes('supabase') ||\r\n      def.definition.includes(\"Database['public']['Tables']\")\r\n    );\r\n\r\n    // Find manual type definitions that might correspond to database entities\r\n    const manualTypes = this.typeDefinitions.filter(def => \r\n      !def.file.includes('database.types') && \r\n      !def.file.includes('supabase')\r\n    );\r\n\r\n    // Check for potential mismatches\r\n    for (const manualType of manualTypes) {\r\n      // Check if there's a corresponding Supabase type\r\n      const potentialSupabaseType = this.findCorrespondingSupabaseType(manualType, supabaseTypes);\r\n      \r\n      if (potentialSupabaseType) {\r\n        // We found a potential mismatch - manual type exists alongside Supabase type\r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'inconsistent-pattern',\r\n            severity: 'high',\r\n            category: 'types',\r\n            file: manualType.file,\r\n            node: manualType.node,\r\n            description: `Manual type definition '${manualType.name}' may conflict with Supabase generated type. Found potential Supabase type in ${potentialSupabaseType.file}.`,\r\n            recommendation: `Use Supabase generated types instead of manual definitions to ensure type safety with the database schema. Import the type from the generated types file: import type { ${manualType.name} } from '@/types/database.types'`,\r\n            estimatedEffort: 'small',\r\n            tags: ['supabase-type-mismatch', 'database-type', manualType.name],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    // Check for usage of Database['public']['Tables'] pattern outside of type files\r\n    for (const usage of this.typeUsages) {\r\n      if (usage.typeName.startsWith('Db') && !usage.file.includes('database.types')) {\r\n        // This is likely a Supabase type being used directly\r\n        // Check if there's a manual type that should be used instead\r\n        const manualType = this.typeDefinitions.find(def => \r\n          def.name === usage.typeName && \r\n          !def.file.includes('database.types')\r\n        );\r\n\r\n        if (!manualType) {\r\n          // Using Supabase type directly without a proper type alias\r\n          // This is actually good practice, so we don't flag it as an issue\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find a corresponding Supabase type for a manual type definition\r\n   */\r\n  private findCorrespondingSupabaseType(\r\n    manualType: TypeDefinition, \r\n    supabaseTypes: TypeDefinition[]\r\n  ): TypeDefinition | null {\r\n    // Look for Supabase types with similar names\r\n    const manualName = manualType.name.toLowerCase();\r\n    \r\n    for (const supabaseType of supabaseTypes) {\r\n      const supabaseName = supabaseType.name.toLowerCase();\r\n      \r\n      // Check for exact match\r\n      if (manualName === supabaseName) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check for common patterns:\r\n      // - User vs users (singular vs plural)\r\n      // - User vs DbUser\r\n      // - UserProfile vs user_profiles\r\n      \r\n      if (\r\n        manualName === supabaseName + 's' ||\r\n        manualName + 's' === supabaseName ||\r\n        manualName === 'db' + supabaseName ||\r\n        'db' + manualName === supabaseName ||\r\n        manualName.replace(/_/g, '') === supabaseName.replace(/_/g, '')\r\n      ) {\r\n        return supabaseType;\r\n      }\r\n      \r\n      // Check if the Supabase type definition references a table with similar name\r\n      if (supabaseType.definition.includes(`['${manualName}']`) ||\r\n          supabaseType.definition.includes(`['${manualName}s']`) ||\r\n          supabaseType.definition.includes(`['${manualName.replace(/([A-Z])/g, '_$1').toLowerCase()}']`)) {\r\n        return supabaseType;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Normalize a type definition for comparison\r\n   * Removes whitespace and formatting differences\r\n   */\r\n  private normalizeTypeDefinition(definition: string): string {\r\n    return definition\r\n      .replace(/\\s+/g, ' ')  // Normalize whitespace\r\n      .replace(/,\\s*}/g, '}')  // Remove trailing commas\r\n      .replace(/;\\s*}/g, '}')  // Remove trailing semicolons\r\n      .trim();\r\n  }\r\n\r\n  // ============================================================================\r\n  // Task 8.3: Type Safety Issue Detection\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Detect excessive 'any' type usage\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectExcessiveAnyUsage(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all occurrences of 'any' type in the file\r\n    const anyTypeNodes = this.findAnyTypeUsage(ast);\r\n\r\n    for (const node of anyTypeNodes) {\r\n      // Determine the context of the 'any' usage\r\n      const context = this.getAnyTypeContext(node);\r\n      \r\n      // Create an issue for each 'any' usage\r\n      issues.push(\r\n        this.createIssue({\r\n          type: 'type-safety',\r\n          severity: 'medium',\r\n          category: 'types',\r\n          file: file.relativePath,\r\n          node: node,\r\n          description: `Excessive use of 'any' type detected in ${context}. This bypasses TypeScript's type checking and reduces type safety.`,\r\n          recommendation: `Replace 'any' with a specific type. Consider using: 1) A proper interface or type definition, 2) Generic types for flexible but type-safe code, 3) 'unknown' if the type is truly unknown (requires type guards), 4) Union types for multiple possible types.`,\r\n          estimatedEffort: 'small',\r\n          tags: ['any-type', 'type-safety', context],\r\n        })\r\n      );\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Detect unnecessary type assertions\r\n   * Validates Requirements: 7.3\r\n   */\r\n  private detectUnnecessaryTypeAssertions(file: FileInfo, ast: SourceFile): Issue[] {\r\n    const issues: Issue[] = [];\r\n\r\n    // Find all type assertions (as Type and <Type>)\r\n    const typeAssertions = this.findTypeAssertions(ast);\r\n\r\n    for (const assertion of typeAssertions) {\r\n      // Check if the type assertion is unnecessary\r\n      if (this.isTypeAssertionUnnecessary(assertion)) {\r\n        const assertedType = this.getAssertedType(assertion);\r\n        \r\n        issues.push(\r\n          this.createIssue({\r\n            type: 'type-safety',\r\n            severity: 'low',\r\n            category: 'types',\r\n            file: file.relativePath,\r\n            node: assertion,\r\n            description: `Unnecessary type assertion to '${assertedType}' detected. The expression already has the correct type or TypeScript can infer it.`,\r\n            recommendation: `Remove the type assertion and let TypeScript infer the type naturally. If the assertion is needed for a specific reason, add a comment explaining why. Type assertions should only be used when you have more information about the type than TypeScript can infer.`,\r\n            estimatedEffort: 'trivial',\r\n            tags: ['type-assertion', 'type-safety', 'unnecessary-assertion'],\r\n          })\r\n        );\r\n      }\r\n    }\r\n\r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Find all 'any' type usage in the AST\r\n   */\r\n  private findAnyTypeUsage(ast: SourceFile): Node[] {\r\n    const anyNodes: Node[] = [];\r\n\r\n    // Find nodes with 'any' keyword\r\n    const traverse = (node: Node) => {\r\n      // Check if this is an 'any' type reference\r\n      if (node.getKind() === SyntaxKind.AnyKeyword) {\r\n        anyNodes.push(node);\r\n      }\r\n      \r\n      node.forEachChild(traverse);\r\n    };\r\n\r\n    traverse(ast);\r\n    return anyNodes;\r\n  }\r\n\r\n  /**\r\n   * Get the context of an 'any' type usage\r\n   */\r\n  private getAnyTypeContext(node: Node): string {\r\n    let parent = node.getParent();\r\n    \r\n    // Traverse up to find the meaningful context\r\n    while (parent) {\r\n      const kind = parent.getKind();\r\n      \r\n      if (kind === SyntaxKind.Parameter) {\r\n        const paramName = this.getNodeName(parent) || 'parameter';\r\n        return `function parameter '${paramName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.VariableDeclaration) {\r\n        const varName = this.getNodeName(parent) || 'variable';\r\n        return `variable declaration '${varName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.PropertySignature || kind === SyntaxKind.PropertyDeclaration) {\r\n        const propName = this.getNodeName(parent) || 'property';\r\n        return `property '${propName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.FunctionDeclaration || \r\n          kind === SyntaxKind.MethodDeclaration ||\r\n          kind === SyntaxKind.ArrowFunction) {\r\n        const funcName = this.getNodeName(parent) || 'function';\r\n        return `return type of '${funcName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.TypeAliasDeclaration) {\r\n        const typeName = this.getNodeName(parent) || 'type';\r\n        return `type alias '${typeName}'`;\r\n      }\r\n      \r\n      if (kind === SyntaxKind.InterfaceDeclaration) {\r\n        const interfaceName = this.getNodeName(parent) || 'interface';\r\n        return `interface '${interfaceName}'`;\r\n      }\r\n      \r\n      parent = parent.getParent();\r\n    }\r\n    \r\n    return 'unknown context';\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions in the AST\r\n   */\r\n  private findTypeAssertions(ast: SourceFile): Node[] {\r\n    const assertions: Node[] = [];\r\n\r\n    // Find 'as' type assertions\r\n    const asAssertions = this.findNodesByKind(ast, SyntaxKind.AsExpression);\r\n    assertions.push(...asAssertions);\r\n\r\n    // Find angle bracket type assertions (TypeReference)\r\n    const typeAssertions = this.findNodesByKind(ast, SyntaxKind.TypeAssertionExpression);\r\n    assertions.push(...typeAssertions);\r\n\r\n    // Find non-null assertions (!)\r\n    const nonNullAssertions = this.findNodesByKind(ast, SyntaxKind.NonNullExpression);\r\n    assertions.push(...nonNullAssertions);\r\n\r\n    return assertions;\r\n  }\r\n\r\n  /**\r\n   * Check if a type assertion is unnecessary\r\n   */\r\n  private isTypeAssertionUnnecessary(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for common patterns of unnecessary assertions\r\n    \r\n    // Pattern 1: Asserting to the same type as the literal\r\n    // e.g., \"hello\" as string, 123 as number, true as boolean\r\n    if (this.isLiteralToSameTypeAssertion(assertion)) {\r\n      return true;\r\n    }\r\n    \r\n    // Pattern 2: Double assertions (as any as Type)\r\n    // These are sometimes necessary for complex type conversions, so we're lenient\r\n    if (assertionText.includes(' as any as ')) {\r\n      return false; // Not flagging double assertions as they're often intentional\r\n    }\r\n    \r\n    // Pattern 3: Asserting after a type guard\r\n    // This is harder to detect statically, so we skip it for now\r\n    \r\n    // Pattern 4: Asserting to 'any' (this is caught by excessive any detection)\r\n    if (assertionText.includes(' as any') || assertionText.includes('<any>')) {\r\n      return false; // Let the 'any' detection handle this\r\n    }\r\n    \r\n    // Pattern 5: Non-null assertion on optional chaining result\r\n    // e.g., obj?.prop! - this is often unnecessary\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      const expression = (assertion as any).getExpression?.();\r\n      if (expression) {\r\n        const exprText = expression.getText();\r\n        // Check if the expression uses optional chaining\r\n        if (exprText.includes('?.')) {\r\n          return true; // Likely unnecessary\r\n        }\r\n      }\r\n    }\r\n    \r\n    // For other cases, we need more sophisticated type inference\r\n    // which would require the TypeScript type checker\r\n    // For now, we're conservative and don't flag them\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Check if an assertion is from a literal to its natural type\r\n   */\r\n  private isLiteralToSameTypeAssertion(assertion: Node): boolean {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Check for string literal to string\r\n    if (assertionText.match(/[\"'`][^\"'`]*[\"'`]\\s+as\\s+string/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for number literal to number\r\n    if (assertionText.match(/\\d+(\\.\\d+)?\\s+as\\s+number/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for boolean literal to boolean\r\n    if (assertionText.match(/(true|false)\\s+as\\s+boolean/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for array literal to array type\r\n    if (assertionText.match(/\\[.*\\]\\s+as\\s+.*\\[\\]/)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for object literal to object type\r\n    if (assertionText.match(/\\{.*\\}\\s+as\\s+\\{.*\\}/)) {\r\n      // This might be necessary for specific object shapes, so we're lenient\r\n      return false;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get the type being asserted to\r\n   */\r\n  private getAssertedType(assertion: Node): string {\r\n    const assertionText = assertion.getText();\r\n    \r\n    // Extract type from 'as Type' syntax\r\n    const asMatch = assertionText.match(/\\s+as\\s+(.+)$/);\r\n    if (asMatch) {\r\n      return asMatch[1].trim();\r\n    }\r\n    \r\n    // Extract type from '<Type>' syntax\r\n    const angleMatch = assertionText.match(/^<(.+)>/);\r\n    if (angleMatch) {\r\n      return angleMatch[1].trim();\r\n    }\r\n    \r\n    // Non-null assertion\r\n    if (assertion.getKind() === SyntaxKind.NonNullExpression) {\r\n      return 'non-null';\r\n    }\r\n    \r\n    return 'unknown';\r\n  }\r\n}\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\plan.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1664,1667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1664,1667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1738,1741],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1738,1741],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1810,1813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1810,1813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1881,1884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1881,1884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3415,3418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3415,3418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":118,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4381,4384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4381,4384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":123,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4616,4619],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4616,4619],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Plan Command\r\n * \r\n * Generates a cleanup plan from analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { CleanupPlanner } from '../../planner/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { ClassifiedIssues } from '../../types.js';\r\n\r\ninterface PlanOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const planCommand = new Command('plan')\r\n  .description('Generate a cleanup plan from analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-plan)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: PlanOptions) => {\r\n    try {\r\n      console.log('📋 Generating cleanup plan from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-plan');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"issues\" field.');\r\n      }\r\n\r\n      // Reconstruct ClassifiedIssues\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate cleanup plan\r\n      console.log('Generating cleanup plan...');\r\n      const planner = new CleanupPlanner();\r\n      const plan = planner.generatePlan(classified, classified.patterns);\r\n\r\n      // Display summary\r\n      console.log('\\n📊 Cleanup Plan Summary:');\r\n      console.log('─'.repeat(50));\r\n      console.log(`Total Tasks: ${plan.tasks.length}`);\r\n      console.log(`Phases: ${plan.phases.length}`);\r\n      console.log(`Estimated Duration: ${plan.estimatedDuration}`);\r\n      console.log(`Overall Risk: ${plan.riskAssessment.overallRisk}`);\r\n      console.log('─'.repeat(50));\r\n\r\n      // Generate output\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdown = generateMarkdownPlan(plan);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdown, 'utf-8');\r\n        console.log(`✅ Markdown plan saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(plan, null, 2), 'utf-8');\r\n        console.log(`✅ JSON plan saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\n✅ Cleanup plan generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'plan');\r\n    }\r\n  });\r\n\r\n/**\r\n * Generate markdown representation of cleanup plan\r\n */\r\nfunction generateMarkdownPlan(plan: any): string {\r\n  let markdown = '# Codebase Cleanup Plan\\n\\n';\r\n\r\n  // Summary\r\n  markdown += '## Summary\\n\\n';\r\n  markdown += `- **Total Tasks**: ${plan.tasks.length}\\n`;\r\n  markdown += `- **Phases**: ${plan.phases.length}\\n`;\r\n  markdown += `- **Estimated Duration**: ${plan.estimatedDuration}\\n`;\r\n  markdown += `- **Overall Risk**: ${plan.riskAssessment.overallRisk}\\n\\n`;\r\n\r\n  // Risk Assessment\r\n  if (plan.riskAssessment.highRiskTasks.length > 0) {\r\n    markdown += '## Risk Assessment\\n\\n';\r\n    markdown += `**High Risk Tasks**: ${plan.riskAssessment.highRiskTasks.length}\\n\\n`;\r\n    \r\n    if (plan.riskAssessment.mitigationStrategies.length > 0) {\r\n      markdown += '**Mitigation Strategies**:\\n';\r\n      plan.riskAssessment.mitigationStrategies.forEach((strategy: string) => {\r\n        markdown += `- ${strategy}\\n`;\r\n      });\r\n      markdown += '\\n';\r\n    }\r\n  }\r\n\r\n  // Phases\r\n  markdown += '## Execution Phases\\n\\n';\r\n  plan.phases.forEach((phase: any) => {\r\n    markdown += `### Phase ${phase.phaseNumber}: ${phase.phaseName}\\n\\n`;\r\n    markdown += `${phase.description}\\n\\n`;\r\n    markdown += `**Tasks in this phase**: ${phase.tasks.length}\\n\\n`;\r\n\r\n    phase.tasks.forEach((task: any) => {\r\n      markdown += `#### ${task.title}\\n\\n`;\r\n      markdown += `- **ID**: ${task.id}\\n`;\r\n      markdown += `- **Category**: ${task.category}\\n`;\r\n      markdown += `- **Effort**: ${task.estimatedEffort}\\n`;\r\n      markdown += `- **Risk**: ${task.riskLevel}\\n`;\r\n      markdown += `- **Requires Tests**: ${task.requiresTests ? 'Yes' : 'No'}\\n`;\r\n      \r\n      if (task.dependencies.length > 0) {\r\n        markdown += `- **Dependencies**: ${task.dependencies.join(', ')}\\n`;\r\n      }\r\n      \r\n      markdown += `\\n**Description**: ${task.description}\\n\\n`;\r\n      \r\n      if (task.actionSteps.length > 0) {\r\n        markdown += '**Action Steps**:\\n';\r\n        task.actionSteps.forEach((step: string, index: number) => {\r\n          markdown += `${index + 1}. ${step}\\n`;\r\n        });\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      if (task.affectedFiles.length > 0) {\r\n        markdown += '**Affected Files**:\\n';\r\n        task.affectedFiles.slice(0, 10).forEach((file: string) => {\r\n          markdown += `- ${file}\\n`;\r\n        });\r\n        if (task.affectedFiles.length > 10) {\r\n          markdown += `- ... and ${task.affectedFiles.length - 10} more files\\n`;\r\n        }\r\n        markdown += '\\n';\r\n      }\r\n      \r\n      markdown += '---\\n\\n';\r\n    });\r\n  });\r\n\r\n  return markdown;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\cli\\commands\\report.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2236,2239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2236,2239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":57,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2310,2313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2310,2313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2382,2385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2382,2385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2453,2456],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2453,2456],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Report Command\r\n * \r\n * Generates a report from previously saved analysis results.\r\n */\r\n\r\nimport { Command } from 'commander';\r\nimport { resolve } from 'path';\r\nimport { readFile, writeFile } from 'fs/promises';\r\nimport { createReportGenerator } from '../../reporter/index.js';\r\nimport { handleError } from '../utils/error-handler.js';\r\nimport type { AnalysisResult, ClassifiedIssues } from '../../types.js';\r\n\r\ninterface ReportOptions {\r\n  input: string;\r\n  output?: string;\r\n  format?: 'markdown' | 'json' | 'both';\r\n}\r\n\r\nexport const reportCommand = new Command('report')\r\n  .description('Generate a report from saved analysis results')\r\n  .requiredOption('-i, --input <path>', 'Path to analysis results JSON file')\r\n  .option('-o, --output <path>', 'Output file path (default: ./cleanup-report)')\r\n  .option('-f, --format <format>', 'Output format: markdown, json, or both', 'markdown')\r\n  .action(async (options: ReportOptions) => {\r\n    try {\r\n      console.log('📄 Generating report from analysis results...\\n');\r\n\r\n      // Resolve paths\r\n      const inputPath = resolve(options.input);\r\n      const outputPath = options.output ? resolve(options.output) : resolve('./cleanup-report');\r\n\r\n      // Load analysis results\r\n      console.log(`Loading analysis results from: ${inputPath}`);\r\n      const fileContent = await readFile(inputPath, 'utf-8');\r\n      const data = JSON.parse(fileContent);\r\n\r\n      // Validate data structure\r\n      if (!data.summary || !data.issues) {\r\n        throw new Error('Invalid analysis results file. Expected JSON with \"summary\" and \"issues\" fields.');\r\n      }\r\n\r\n      // Reconstruct AnalysisResult and ClassifiedIssues\r\n      const analysisResult: AnalysisResult = {\r\n        totalFiles: data.summary.totalFiles || 0,\r\n        analyzedFiles: data.summary.analyzedFiles || 0,\r\n        totalIssues: data.summary.totalIssues || 0,\r\n        issuesByType: new Map(),\r\n        issuesByCategory: new Map(),\r\n        issuesBySeverity: new Map(),\r\n        analysisTimestamp: new Date(data.summary.analysisTimestamp || Date.now()),\r\n        analysisDuration: data.summary.analysisDuration || 0,\r\n      };\r\n\r\n      const classified: ClassifiedIssues = {\r\n        critical: data.issues.filter((i: any) => i.severity === 'critical'),\r\n        high: data.issues.filter((i: any) => i.severity === 'high'),\r\n        medium: data.issues.filter((i: any) => i.severity === 'medium'),\r\n        low: data.issues.filter((i: any) => i.severity === 'low'),\r\n        patterns: data.patterns || [],\r\n      };\r\n\r\n      // Generate report\r\n      const reporter = createReportGenerator();\r\n      const format = options.format || 'markdown';\r\n\r\n      if (format === 'markdown' || format === 'both') {\r\n        const markdownReport = reporter.generateMarkdownReport(analysisResult, classified);\r\n        const mdPath = `${outputPath}.md`;\r\n        await writeFile(mdPath, markdownReport, 'utf-8');\r\n        console.log(`✅ Markdown report saved to: ${mdPath}`);\r\n      }\r\n\r\n      if (format === 'json' || format === 'both') {\r\n        const jsonReport = reporter.generateJsonReport(analysisResult, classified);\r\n        const jsonPath = `${outputPath}.json`;\r\n        await writeFile(jsonPath, JSON.stringify(jsonReport, null, 2), 'utf-8');\r\n        console.log(`✅ JSON report saved to: ${jsonPath}`);\r\n      }\r\n\r\n      console.log('\\n✅ Report generation complete!\\n');\r\n\r\n    } catch (error) {\r\n      handleError(error, 'report');\r\n    }\r\n  });\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":158,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5126,5129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5126,5129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":195,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6203,6206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6203,6206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Core type definitions for the codebase cleanup and refactoring analysis system\r\n */\r\n\r\n// ============================================================================\r\n// File Information Types\r\n// ============================================================================\r\n\r\n/**\r\n * Categorization of files for analysis purposes\r\n */\r\nexport type FileCategory =\r\n  | 'component'      // React components\r\n  | 'api-route'      // Next.js API routes\r\n  | 'service'        // Backend services\r\n  | 'type'           // Type definition files\r\n  | 'util'           // Utility functions\r\n  | 'middleware'     // Middleware files\r\n  | 'config'         // Configuration files\r\n  | 'test'           // Test files\r\n  | 'other';         // Uncategorized\r\n\r\n/**\r\n * Information about a file to be analyzed\r\n */\r\nexport interface FileInfo {\r\n  path: string;              // Absolute path\r\n  relativePath: string;      // Relative to project root\r\n  extension: string;         // '.ts', '.tsx', etc.\r\n  size: number;             // File size in bytes\r\n  category: FileCategory;   // Categorization for analysis\r\n  lastModified: Date;       // File modification timestamp\r\n}\r\n\r\n// ============================================================================\r\n// Issue Types\r\n// ============================================================================\r\n\r\n/**\r\n * Types of issues that can be detected\r\n */\r\nexport type IssueType =\r\n  | 'backward-compatibility'\r\n  | 'legacy-code'\r\n  | 'unnecessary-adapter'\r\n  | 'confusing-logic'\r\n  | 'code-duplication'\r\n  | 'inconsistent-pattern'\r\n  | 'poor-naming'\r\n  | 'missing-error-handling'\r\n  | 'type-safety'\r\n  | 'architectural';\r\n\r\n/**\r\n * Categories for grouping issues\r\n */\r\nexport type IssueCategory =\r\n  | 'authentication'\r\n  | 'database'\r\n  | 'api-routes'\r\n  | 'components'\r\n  | 'services'\r\n  | 'types'\r\n  | 'middleware'\r\n  | 'error-handling'\r\n  | 'general';\r\n\r\n/**\r\n * Severity levels for issues\r\n */\r\nexport type Severity = 'critical' | 'high' | 'medium' | 'low';\r\n\r\n/**\r\n * Effort levels for fixing issues\r\n */\r\nexport type EffortLevel = 'trivial' | 'small' | 'medium' | 'large';\r\n\r\n/**\r\n * Precise location of code within a file\r\n */\r\nexport interface CodeLocation {\r\n  startLine: number;\r\n  endLine: number;\r\n  startColumn: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Represents a detected issue in the codebase\r\n */\r\nexport interface Issue {\r\n  id: string;                    // Unique identifier (UUID)\r\n  type: IssueType;              // Type of issue\r\n  severity: Severity;           // Severity level\r\n  category: IssueCategory;      // Category for grouping\r\n  file: string;                 // File path\r\n  location: CodeLocation;       // Precise location in file\r\n  description: string;          // Human-readable description\r\n  codeSnippet: string;         // Relevant code excerpt\r\n  recommendation: string;       // Suggested fix\r\n  estimatedEffort: EffortLevel; // Effort to fix\r\n  tags: string[];              // Additional tags for filtering\r\n  detectedBy: string;          // Analyzer that detected it\r\n  detectedAt: Date;            // Detection timestamp\r\n  relatedIssues: string[];     // IDs of related issues\r\n}\r\n\r\n// ============================================================================\r\n// Pattern Types\r\n// ============================================================================\r\n\r\n/**\r\n * Represents a pattern of related issues across the codebase\r\n */\r\nexport interface IssuePattern {\r\n  patternId: string;           // Unique pattern identifier\r\n  patternName: string;         // Human-readable name\r\n  description: string;         // Pattern description\r\n  occurrences: number;         // Number of times detected\r\n  affectedFiles: string[];     // Files where pattern appears\r\n  relatedIssues: Issue[];      // Issues that match this pattern\r\n  recommendedAction: string;   // How to address the pattern\r\n  priority: number;            // Priority for addressing (1-10)\r\n  category: IssueCategory;     // Category for grouping\r\n}\r\n\r\n// ============================================================================\r\n// Scanner Types\r\n// ============================================================================\r\n\r\n/**\r\n * Options for scanning directories\r\n */\r\nexport interface ScanOptions {\r\n  includePatterns: string[];  // e.g., [\"**/*.ts\", \"**/*.tsx\"]\r\n  excludePatterns: string[];  // e.g., [\"**/node_modules/**\", \"**/.next/**\"]\r\n  maxDepth?: number;          // Maximum directory depth\r\n}\r\n\r\n/**\r\n * Interface for file scanning functionality\r\n */\r\nexport interface FileScanner {\r\n  scanDirectory(rootPath: string, options: ScanOptions): Promise<FileInfo[]>;\r\n  filterByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n  excludeByPattern(files: FileInfo[], patterns: string[]): FileInfo[];\r\n}\r\n\r\n// ============================================================================\r\n// Analyzer Types\r\n// ============================================================================\r\n\r\n/**\r\n * Base interface for all pattern analyzers\r\n */\r\nexport interface PatternAnalyzer {\r\n  name: string;\r\n  analyze(file: FileInfo, ast: any): Promise<Issue[]>;\r\n  getSupportedFileTypes(): FileCategory[];\r\n}\r\n\r\n// ============================================================================\r\n// Analysis Engine Types\r\n// ============================================================================\r\n\r\n/**\r\n * Collection of issues with various groupings\r\n */\r\nexport interface IssueCollection {\r\n  issues: Issue[];\r\n  groupedByFile: Map<string, Issue[]>;\r\n  groupedByType: Map<IssueType, Issue[]>;\r\n  groupedByCategory: Map<IssueCategory, Issue[]>;\r\n}\r\n\r\n/**\r\n * Result of analyzing the codebase\r\n */\r\nexport interface AnalysisResult {\r\n  totalFiles: number;\r\n  analyzedFiles: number;\r\n  totalIssues: number;\r\n  issuesByType: Map<IssueType, Issue[]>;\r\n  issuesByCategory: Map<IssueCategory, Issue[]>;\r\n  issuesBySeverity: Map<Severity, Issue[]>;\r\n  analysisTimestamp: Date;\r\n  analysisDuration: number;\r\n}\r\n\r\n/**\r\n * Interface for the analysis engine\r\n */\r\nexport interface AnalysisEngine {\r\n  analyze(files: FileInfo[], analyzers: PatternAnalyzer[]): Promise<AnalysisResult>;\r\n  parseFile(file: FileInfo): Promise<any>;\r\n  aggregateIssues(issues: Issue[]): IssueCollection;\r\n}\r\n\r\n// ============================================================================\r\n// Classifier Types\r\n// ============================================================================\r\n\r\n/**\r\n * Issues classified by severity\r\n */\r\nexport interface ClassifiedIssues {\r\n  critical: Issue[];\r\n  high: Issue[];\r\n  medium: Issue[];\r\n  low: Issue[];\r\n  patterns: IssuePattern[];\r\n}\r\n\r\n/**\r\n * Interface for issue classification\r\n */\r\nexport interface IssueClassifier {\r\n  classify(issues: Issue[]): ClassifiedIssues;\r\n  prioritize(issues: Issue[]): Issue[];\r\n  detectPatterns(issues: Issue[]): IssuePattern[];\r\n}\r\n\r\n// ============================================================================\r\n// Report Types\r\n// ============================================================================\r\n\r\n/**\r\n * Summary of the analysis report\r\n */\r\nexport interface ReportSummary {\r\n  totalIssues: number;\r\n  criticalIssues: number;\r\n  highIssues: number;\r\n  mediumIssues: number;\r\n  lowIssues: number;\r\n  topPatterns: IssuePattern[];\r\n  mostAffectedFiles: string[];\r\n  estimatedCleanupEffort: string;\r\n}\r\n\r\n/**\r\n * Recommendation for addressing issues\r\n */\r\nexport interface Recommendation {\r\n  priority: number;\r\n  title: string;\r\n  description: string;\r\n  affectedIssues: string[];\r\n  estimatedImpact: string;\r\n  estimatedEffort: string;\r\n}\r\n\r\n/**\r\n * Complete report data structure\r\n */\r\nexport interface ReportData {\r\n  summary: ReportSummary;\r\n  issues: Issue[];\r\n  patterns: IssuePattern[];\r\n  recommendations: Recommendation[];\r\n}\r\n\r\n/**\r\n * Interface for report generation\r\n */\r\nexport interface ReportGenerator {\r\n  generateMarkdownReport(result: AnalysisResult, classified: ClassifiedIssues): string;\r\n  generateJsonReport(result: AnalysisResult, classified: ClassifiedIssues): ReportData;\r\n  generateSummary(result: AnalysisResult): ReportSummary;\r\n}\r\n\r\n// ============================================================================\r\n// Cleanup Planning Types\r\n// ============================================================================\r\n\r\n/**\r\n * Risk levels for cleanup tasks\r\n */\r\nexport type RiskLevel = 'low' | 'medium' | 'high' | 'critical';\r\n\r\n/**\r\n * A specific cleanup task to address issues\r\n */\r\nexport interface CleanupTask {\r\n  id: string;                  // Unique task identifier\r\n  title: string;               // Short task title\r\n  description: string;         // Detailed description\r\n  category: IssueCategory;     // Category for grouping\r\n  relatedIssues: string[];     // Issue IDs this task addresses\r\n  dependencies: string[];      // Task IDs that must complete first\r\n  estimatedEffort: EffortLevel; // Effort estimate\r\n  riskLevel: RiskLevel;        // Risk of making this change\r\n  requiresTests: boolean;      // Whether tests needed before change\r\n  actionSteps: string[];       // Step-by-step instructions\r\n  affectedFiles: string[];     // Files that will be modified\r\n  phase: number;               // Which phase this belongs to\r\n}\r\n\r\n/**\r\n * Dependency relationship between tasks\r\n */\r\nexport interface TaskDependency {\r\n  taskId: string;\r\n  dependsOn: string[];\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * A phase of cleanup work\r\n */\r\nexport interface CleanupPhase {\r\n  phaseNumber: number;\r\n  phaseName: string;\r\n  tasks: CleanupTask[];\r\n  description: string;\r\n}\r\n\r\n/**\r\n * Risk assessment for the cleanup plan\r\n */\r\nexport interface RiskAssessment {\r\n  overallRisk: RiskLevel;\r\n  highRiskTasks: CleanupTask[];\r\n  mitigationStrategies: string[];\r\n}\r\n\r\n/**\r\n * Complete cleanup plan\r\n */\r\nexport interface CleanupPlan {\r\n  tasks: CleanupTask[];\r\n  phases: CleanupPhase[];\r\n  estimatedDuration: string;\r\n  riskAssessment: RiskAssessment;\r\n}\r\n\r\n/**\r\n * Interface for cleanup planning\r\n */\r\nexport interface ICleanupPlanner {\r\n  generatePlan(classified: ClassifiedIssues, patterns: IssuePattern[]): CleanupPlan;\r\n  orderTasks(tasks: CleanupTask[]): CleanupTask[];\r\n  detectDependencies(tasks: CleanupTask[]): TaskDependency[];\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\src\\utils\\ast-parser.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7455,7458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7455,7458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":484,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":484,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14001,14004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14001,14004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":505,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":505,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14542,14545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14542,14545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14721,14724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14721,14724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AST Parsing Utilities\r\n * \r\n * Provides utilities for parsing TypeScript/JavaScript files into ASTs\r\n * and querying AST nodes for common patterns.\r\n */\r\n\r\nimport { Project, SourceFile, Node, SyntaxKind } from 'ts-morph';\r\nimport type { FileInfo } from '../types';\r\n\r\n/**\r\n * Error thrown when file parsing fails\r\n */\r\nexport class ParseError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public readonly filePath: string,\r\n    public readonly cause?: Error\r\n  ) {\r\n    super(message);\r\n    this.name = 'ParseError';\r\n  }\r\n}\r\n\r\n/**\r\n * AST Parser class for parsing files and querying AST nodes\r\n */\r\nexport class ASTParser {\r\n  private project: Project;\r\n\r\n  constructor() {\r\n    // Initialize ts-morph Project with TypeScript compiler options\r\n    this.project = new Project({\r\n      compilerOptions: {\r\n        target: 99, // ESNext\r\n        module: 99, // ESNext\r\n        jsx: 2, // React\r\n        allowJs: true,\r\n        skipLibCheck: true,\r\n        skipDefaultLibCheck: true,\r\n        noEmit: true,\r\n      },\r\n      skipAddingFilesFromTsConfig: true,\r\n      skipFileDependencyResolution: true,\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Parse a file into an AST\r\n   * @param file File information\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  async parseFile(file: FileInfo): Promise<SourceFile> {\r\n    try {\r\n      // Add the file to the project\r\n      const sourceFile = this.project.addSourceFileAtPath(file.path);\r\n      \r\n      // Check for syntax errors\r\n      const diagnostics = sourceFile.getPreEmitDiagnostics();\r\n      \r\n      if (diagnostics.length > 0) {\r\n        // Log diagnostics but don't fail - we want to analyze even files with errors\r\n        const errors = diagnostics.map(d => d.getMessageText()).join('\\n');\r\n        console.warn(`Syntax warnings in ${file.relativePath}:\\n${errors}`);\r\n      }\r\n      \r\n      return sourceFile;\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse file: ${file.relativePath}`,\r\n        file.path,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse file content from a string\r\n   * @param content File content as string\r\n   * @param filePath Virtual file path for the content\r\n   * @returns Parsed SourceFile AST\r\n   * @throws ParseError if parsing fails\r\n   */\r\n  parseContent(content: string, filePath: string): SourceFile {\r\n    try {\r\n      return this.project.createSourceFile(filePath, content, { overwrite: true });\r\n    } catch (error) {\r\n      throw new ParseError(\r\n        `Failed to parse content for: ${filePath}`,\r\n        filePath,\r\n        error instanceof Error ? error : undefined\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a file from the project to free memory\r\n   * @param sourceFile Source file to remove\r\n   */\r\n  removeFile(sourceFile: SourceFile): void {\r\n    sourceFile.forget();\r\n  }\r\n\r\n  /**\r\n   * Clear all files from the project\r\n   */\r\n  clearAll(): void {\r\n    this.project.getSourceFiles().forEach(sf => sf.forget());\r\n  }\r\n\r\n  /**\r\n   * Get the ts-morph Project instance\r\n   * @returns The Project instance\r\n   */\r\n  getProject(): Project {\r\n    return this.project;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// AST Query Helpers\r\n// ============================================================================\r\n\r\n/**\r\n * Query helper functions for common AST operations\r\n */\r\nexport class ASTQueryHelper {\r\n  /**\r\n   * Find all function declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function declaration nodes\r\n   */\r\n  static findFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all arrow functions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of arrow function nodes\r\n   */\r\n  static findArrowFunctions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ArrowFunction);\r\n  }\r\n\r\n  /**\r\n   * Find all function expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of function expression nodes\r\n   */\r\n  static findFunctionExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.FunctionExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all functions (declarations, expressions, and arrow functions)\r\n   * @param ast Source file AST\r\n   * @returns Array of all function nodes\r\n   */\r\n  static findAllFunctions(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all method declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of method declaration nodes\r\n   */\r\n  static findMethods(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.MethodDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all class declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of class declaration nodes\r\n   */\r\n  static findClasses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ClassDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all interface declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of interface declaration nodes\r\n   */\r\n  static findInterfaces(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.InterfaceDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type alias declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of type alias nodes\r\n   */\r\n  static findTypeAliases(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TypeAliasDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all type definitions (interfaces and type aliases)\r\n   * @param ast Source file AST\r\n   * @returns Array of type definition nodes\r\n   */\r\n  static findTypes(ast: SourceFile): Node[] {\r\n    return [\r\n      ...this.findInterfaces(ast),\r\n      ...this.findTypeAliases(ast),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all import declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of import declaration nodes\r\n   */\r\n  static findImports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ImportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all export declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of export declaration nodes\r\n   */\r\n  static findExports(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ExportDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all variable declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of variable declaration nodes\r\n   */\r\n  static findVariables(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.VariableDeclaration);\r\n  }\r\n\r\n  /**\r\n   * Find all const declarations in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of const variable declaration nodes\r\n   */\r\n  static findConstants(ast: SourceFile): Node[] {\r\n    const variableStatements = ast.getDescendantsOfKind(SyntaxKind.VariableStatement);\r\n    const constants: Node[] = [];\r\n\r\n    for (const statement of variableStatements) {\r\n      const declarationList = statement.getFirstChildByKind(SyntaxKind.VariableDeclarationList);\r\n      if (declarationList) {\r\n        const flags = (declarationList as any).getDeclarationKind?.();\r\n        if (flags === 2) { // VariableDeclarationKind.Const\r\n          constants.push(...declarationList.getDescendantsOfKind(SyntaxKind.VariableDeclaration));\r\n        }\r\n      }\r\n    }\r\n\r\n    return constants;\r\n  }\r\n\r\n  /**\r\n   * Find all if statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of if statement nodes\r\n   */\r\n  static findIfStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.IfStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all for statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of for statement nodes\r\n   */\r\n  static findForStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.ForStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all while statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of while statement nodes\r\n   */\r\n  static findWhileStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.WhileStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all switch statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of switch statement nodes\r\n   */\r\n  static findSwitchStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.SwitchStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all try statements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of try statement nodes\r\n   */\r\n  static findTryStatements(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.TryStatement);\r\n  }\r\n\r\n  /**\r\n   * Find all catch clauses in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of catch clause nodes\r\n   */\r\n  static findCatchClauses(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CatchClause);\r\n  }\r\n\r\n  /**\r\n   * Find all call expressions in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of call expression nodes\r\n   */\r\n  static findCallExpressions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.CallExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all JSX elements in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of JSX element nodes\r\n   */\r\n  static findJSXElements(ast: SourceFile): Node[] {\r\n    return [\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxElement),\r\n      ...ast.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement),\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Find all React component declarations (function components)\r\n   * @param ast Source file AST\r\n   * @returns Array of React component nodes\r\n   */\r\n  static findReactComponents(ast: SourceFile): Node[] {\r\n    const components: Node[] = [];\r\n    \r\n    // Find function declarations that return JSX\r\n    const functions = [\r\n      ...this.findFunctions(ast),\r\n      ...this.findArrowFunctions(ast),\r\n      ...this.findFunctionExpressions(ast),\r\n    ];\r\n\r\n    for (const func of functions) {\r\n      const text = func.getText();\r\n      // Check if function returns JSX (contains JSX syntax)\r\n      if (text.includes('<') && text.includes('/>') || text.includes('</')) {\r\n        components.push(func);\r\n      }\r\n    }\r\n\r\n    return components;\r\n  }\r\n\r\n  /**\r\n   * Find all nodes with 'any' type annotation\r\n   * @param ast Source file AST\r\n   * @returns Array of nodes with 'any' type\r\n   */\r\n  static findAnyTypes(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AnyKeyword);\r\n  }\r\n\r\n  /**\r\n   * Find all type assertions (as Type)\r\n   * @param ast Source file AST\r\n   * @returns Array of type assertion nodes\r\n   */\r\n  static findTypeAssertions(ast: SourceFile): Node[] {\r\n    return ast.getDescendantsOfKind(SyntaxKind.AsExpression);\r\n  }\r\n\r\n  /**\r\n   * Find all comments in a source file\r\n   * @param ast Source file AST\r\n   * @returns Array of comment texts\r\n   */\r\n  static findComments(ast: SourceFile): string[] {\r\n    const comments: string[] = [];\r\n    const fullText = ast.getFullText();\r\n    \r\n    // Get all comment ranges\r\n    ast.forEachDescendant(node => {\r\n      const leadingComments = node.getLeadingCommentRanges();\r\n      const trailingComments = node.getTrailingCommentRanges();\r\n      \r\n      for (const range of [...leadingComments, ...trailingComments]) {\r\n        const commentText = fullText.substring(range.getPos(), range.getEnd());\r\n        comments.push(commentText);\r\n      }\r\n    });\r\n    \r\n    return comments;\r\n  }\r\n\r\n  /**\r\n   * Find all commented-out code blocks\r\n   * @param ast Source file AST\r\n   * @returns Array of commented code blocks\r\n   */\r\n  static findCommentedCode(ast: SourceFile): string[] {\r\n    const comments = this.findComments(ast);\r\n    const commentedCode: string[] = [];\r\n    \r\n    for (const comment of comments) {\r\n      // Remove comment markers\r\n      const cleaned = comment\r\n        .replace(/^\\/\\*+/, '')\r\n        .replace(/\\*+\\/$/, '')\r\n        .replace(/^\\/\\/+/gm, '')\r\n        .trim();\r\n      \r\n      // Check if it looks like code (has common code patterns)\r\n      const codePatterns = [\r\n        /function\\s+\\w+/,\r\n        /const\\s+\\w+\\s*=/,\r\n        /let\\s+\\w+\\s*=/,\r\n        /var\\s+\\w+\\s*=/,\r\n        /class\\s+\\w+/,\r\n        /interface\\s+\\w+/,\r\n        /type\\s+\\w+\\s*=/,\r\n        /import\\s+.*from/,\r\n        /export\\s+(default|const|function|class)/,\r\n        /if\\s*\\(/,\r\n        /for\\s*\\(/,\r\n        /while\\s*\\(/,\r\n        /=>\\s*{/,\r\n      ];\r\n      \r\n      if (codePatterns.some(pattern => pattern.test(cleaned))) {\r\n        commentedCode.push(comment);\r\n      }\r\n    }\r\n    \r\n    return commentedCode;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by custom predicate\r\n   * @param ast Source file AST\r\n   * @param predicate Function to test each node\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByPredicate(ast: SourceFile, predicate: (node: Node) => boolean): Node[] {\r\n    const matches: Node[] = [];\r\n    \r\n    ast.forEachDescendant(node => {\r\n      if (predicate(node)) {\r\n        matches.push(node);\r\n      }\r\n    });\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Find nodes by syntax kind\r\n   * @param ast Source file AST\r\n   * @param kind Syntax kind to search for\r\n   * @returns Array of matching nodes\r\n   */\r\n  static findByKind(ast: SourceFile, kind: SyntaxKind): Node[] {\r\n    return ast.getDescendantsOfKind(kind);\r\n  }\r\n\r\n  /**\r\n   * Get the name of a named node (function, class, variable, etc.)\r\n   * @param node AST node\r\n   * @returns Name of the node or undefined\r\n   */\r\n  static getNodeName(node: Node): string | undefined {\r\n    const nodeWithName = node as any;\r\n    \r\n    if (nodeWithName.getName && typeof nodeWithName.getName === 'function') {\r\n      return nodeWithName.getName();\r\n    }\r\n    \r\n    if (nodeWithName.name) {\r\n      return typeof nodeWithName.name === 'string' \r\n        ? nodeWithName.name \r\n        : nodeWithName.name.getText?.();\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Check if a node is exported\r\n   * @param node AST node\r\n   * @returns True if the node is exported\r\n   */\r\n  static isExported(node: Node): boolean {\r\n    const nodeWithModifiers = node as any;\r\n    \r\n    if (!nodeWithModifiers.getModifiers) {\r\n      return false;\r\n    }\r\n    \r\n    const modifiers = nodeWithModifiers.getModifiers();\r\n    return modifiers.some((mod: any) => \r\n      mod.getKind() === SyntaxKind.ExportKeyword\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calculate the cyclomatic complexity of a function\r\n   * @param node Function node\r\n   * @returns Complexity score\r\n   */\r\n  static calculateComplexity(node: Node): number {\r\n    let complexity = 1; // Base complexity\r\n    \r\n    // Count decision points\r\n    const decisionPoints = [\r\n      SyntaxKind.IfStatement,\r\n      SyntaxKind.ConditionalExpression,\r\n      SyntaxKind.CaseClause,\r\n      SyntaxKind.ForStatement,\r\n      SyntaxKind.ForInStatement,\r\n      SyntaxKind.ForOfStatement,\r\n      SyntaxKind.WhileStatement,\r\n      SyntaxKind.DoStatement,\r\n      SyntaxKind.CatchClause,\r\n      SyntaxKind.BinaryExpression, // For && and ||\r\n    ];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (decisionPoints.includes(child.getKind())) {\r\n        // For binary expressions, only count logical operators\r\n        if (child.getKind() === SyntaxKind.BinaryExpression) {\r\n          const text = child.getText();\r\n          if (text.includes('&&') || text.includes('||')) {\r\n            complexity++;\r\n          }\r\n        } else {\r\n          complexity++;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return complexity;\r\n  }\r\n\r\n  /**\r\n   * Calculate the nesting depth of a node\r\n   * @param node AST node\r\n   * @returns Maximum nesting depth\r\n   */\r\n  static calculateNestingDepth(node: Node): number {\r\n    let maxDepth = 0;\r\n    \r\n    const traverse = (n: Node, depth: number) => {\r\n      maxDepth = Math.max(maxDepth, depth);\r\n      \r\n      const kind = n.getKind();\r\n      const nestingKinds = [\r\n        SyntaxKind.IfStatement,\r\n        SyntaxKind.ForStatement,\r\n        SyntaxKind.ForInStatement,\r\n        SyntaxKind.ForOfStatement,\r\n        SyntaxKind.WhileStatement,\r\n        SyntaxKind.DoStatement,\r\n        SyntaxKind.SwitchStatement,\r\n        SyntaxKind.TryStatement,\r\n        SyntaxKind.CatchClause,\r\n      ];\r\n      \r\n      const newDepth = nestingKinds.includes(kind) ? depth + 1 : depth;\r\n      \r\n      n.forEachChild(child => traverse(child, newDepth));\r\n    };\r\n    \r\n    traverse(node, 0);\r\n    return maxDepth;\r\n  }\r\n\r\n  /**\r\n   * Get all identifiers in a node\r\n   * @param node AST node\r\n   * @returns Array of identifier names\r\n   */\r\n  static getIdentifiers(node: Node): string[] {\r\n    const identifiers: string[] = [];\r\n    \r\n    node.forEachDescendant(child => {\r\n      if (child.getKind() === SyntaxKind.Identifier) {\r\n        identifiers.push(child.getText());\r\n      }\r\n    });\r\n    \r\n    return identifiers;\r\n  }\r\n\r\n  /**\r\n   * Check if a node contains a specific pattern\r\n   * @param node AST node\r\n   * @param pattern Regular expression pattern\r\n   * @returns True if pattern is found\r\n   */\r\n  static containsPattern(node: Node, pattern: RegExp): boolean {\r\n    return pattern.test(node.getText());\r\n  }\r\n}\r\n\r\n/**\r\n * Export a singleton instance of ASTParser for convenience\r\n */\r\nexport const astParser = new ASTParser();\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[572,575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[572,575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1508,1511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1508,1511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2011,2014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2011,2014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":86,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test for arrow function detection\r\n */\r\n\r\nimport { Project, Node } from 'ts-morph';\r\n\r\nasync function testArrowFunctionAnalysis() {\r\n  console.log('Detailed arrow function analysis...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Find the arrow function\r\n  let arrowFunc: any = null;\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (Node.isArrowFunction(node)) {\r\n      arrowFunc = node;\r\n    }\r\n  });\r\n\r\n  if (!arrowFunc) {\r\n    console.log('No arrow function found!');\r\n    return;\r\n  }\r\n\r\n  console.log('Arrow function found!');\r\n  console.log('Full text:', arrowFunc.getText());\r\n  \r\n  const body = arrowFunc.getBody();\r\n  console.log('\\nBody kind:', body.getKindName());\r\n  console.log('Body text:', body.getText());\r\n  console.log('Body is Block?', Node.isBlock(body));\r\n  console.log('Body is CallExpression?', Node.isCallExpression(body));\r\n  \r\n  // Check if body is a call expression\r\n  if (Node.isCallExpression(body)) {\r\n    console.log('\\n✓ Body is a call expression (expression body)');\r\n    console.log('Call text:', body.getText());\r\n    \r\n    const expression = body.getExpression();\r\n    console.log('Expression:', expression.getText());\r\n  }\r\n  \r\n  // Get statements\r\n  let statements: any[] = [];\r\n  if (Node.isBlock(body)) {\r\n    statements = body.getStatements();\r\n    console.log('\\nStatements in block:', statements.length);\r\n  } else {\r\n    statements = [body];\r\n    console.log('\\nExpression body (single statement)');\r\n  }\r\n  \r\n  console.log('Statement count:', statements.length);\r\n  statements.forEach((stmt, i) => {\r\n    console.log(`  Statement ${i}: ${stmt.getKindName()} - ${stmt.getText().substring(0, 50)}`);\r\n  });\r\n  \r\n  // Get call expressions\r\n  const callExpressions: any[] = [];\r\n  body.forEachDescendant((node) => {\r\n    if (Node.isCallExpression(node)) {\r\n      callExpressions.push(node);\r\n    }\r\n  });\r\n  \r\n  console.log('\\nCall expressions found:', callExpressions.length);\r\n  callExpressions.forEach((call, i) => {\r\n    console.log(`  Call ${i}: ${call.getText()}`);\r\n  });\r\n  \r\n  // Get parameters\r\n  const params = arrowFunc.getParameters();\r\n  console.log('\\nParameters:', params.length);\r\n  params.forEach((param: any) => {\r\n    console.log(`  - ${param.getName()}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctionAnalysis().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-arrow-function-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1189,1192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1189,1192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1575,1578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1575,1578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug test for arrow function detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { AdapterPatternAnalyzer } from './src/analyzers/adapter-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nfunction createFileInfo(path: string): FileInfo {\r\n  return {\r\n    path: `/test/${path}`,\r\n    relativePath: path,\r\n    extension: '.ts',\r\n    size: 1000,\r\n    category: 'util',\r\n  };\r\n}\r\n\r\nasync function testArrowFunctions() {\r\n  console.log('Testing arrow function detection...\\n');\r\n\r\n  const project = new Project({\r\n    useInMemoryFileSystem: true,\r\n    compilerOptions: {\r\n      target: 99,\r\n      module: 99,\r\n    },\r\n  });\r\n\r\n  const code = `\r\n    const fetchUser = (userId: string) => database.getUser(userId);\r\n    \r\n    const checkAuth = (userId: string) => supabase.auth.getUser(userId);\r\n    \r\n    const verifyUser = (id: string) => authService.verify(id);\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  // Check what functions are found\r\n  console.log('Functions found in AST:');\r\n  const functions = sourceFile.getFunctions();\r\n  console.log(`  Regular functions: ${functions.length}`);\r\n  \r\n  const arrowFunctions: any[] = [];\r\n  sourceFile.forEachDescendant((node) => {\r\n    if (node.getKindName() === 'ArrowFunction') {\r\n      arrowFunctions.push(node);\r\n      const parent = node.getParent();\r\n      console.log(`  Arrow function found, parent: ${parent?.getKindName()}`);\r\n      if (parent && parent.getKindName() === 'VariableDeclaration') {\r\n        console.log(`    Variable name: ${(parent as any).getName()}`);\r\n      }\r\n    }\r\n  });\r\n  console.log(`  Arrow functions: ${arrowFunctions.length}\\n`);\r\n\r\n  const analyzer = new AdapterPatternAnalyzer();\r\n  const issues = await analyzer.analyze(createFileInfo('test.ts'), sourceFile);\r\n  \r\n  console.log(`Issues found: ${issues.length}`);\r\n  issues.forEach(issue => {\r\n    console.log(`  - ${issue.description}`);\r\n  });\r\n}\r\n\r\ntestArrowFunctions().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-export-detection.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1309,1312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1309,1312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1534,1537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1534,1537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Test export detection for variable declarations\r\n */\r\n\r\nimport { Project, SyntaxKind } from 'ts-morph';\r\n\r\nasync function testExportDetection() {\r\n  console.log('Testing Export Detection...\\n');\r\n\r\n  const project = new Project();\r\n  \r\n  const code = `\r\n    export const passthrough = (req: Request, res: Response, next: NextFunction) => next();\r\n    export const noop = (req: any, res: any, next: any) => next();\r\n    const notExported = () => {};\r\n  `;\r\n\r\n  const sourceFile = project.createSourceFile('test.ts', code);\r\n  \r\n  const varDecls = sourceFile.getVariableDeclarations();\r\n  \r\n  console.log('Variable declarations found:');\r\n  varDecls.forEach(varDecl => {\r\n    const name = varDecl.getName();\r\n    console.log(`\\n  Variable: ${name}`);\r\n    \r\n    // Check modifiers on the variable declaration itself\r\n    const declModifiers = (varDecl as any).getModifiers?.() || [];\r\n    console.log(`    Modifiers on declaration: ${declModifiers.length}`);\r\n    \r\n    // Check modifiers on the parent variable statement\r\n    const parent = varDecl.getParent();\r\n    console.log(`    Parent type: ${parent.getKindName()}`);\r\n    \r\n    const parentParent = parent.getParent();\r\n    console.log(`    Parent's parent type: ${parentParent?.getKindName()}`);\r\n    \r\n    if (parentParent && (parentParent as any).getModifiers) {\r\n      const parentModifiers = (parentParent as any).getModifiers();\r\n      console.log(`    Modifiers on parent's parent: ${parentModifiers.length}`);\r\n      const hasExport = parentModifiers.some((mod: any) => \r\n        mod.getKind() === SyntaxKind.ExportKeyword\r\n      );\r\n      console.log(`    Has export keyword: ${hasExport}`);\r\n    }\r\n  });\r\n}\r\n\r\ntestExportDetection().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-middleware-detailed-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[432,435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[432,435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2466,2469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2466,2469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2965,2968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2965,2968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3176,3179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3176,3179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3184,3187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3184,3187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":96,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3229,3232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3229,3232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Detailed debug test to trace middleware usage extraction\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\n// Extend the analyzer to expose internal state for debugging\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function detailedDebug() {\r\n  console.log('Detailed Middleware Usage Debug...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware library\r\n  const middlewareLib = `\r\n    export function authenticateMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authenticating...');\r\n      next();\r\n    }\r\n\r\n    export function authorizeMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      console.log('Authorizing...');\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/auth.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/auth.ts',\r\n    relativePath: 'middleware/auth.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  console.log('After analyzing middleware library:');\r\n  console.log('Usages:', analyzer.getMiddlewareUsages());\r\n  console.log();\r\n\r\n  // Create route with wrong order\r\n  const routeCode = `\r\n    import { authenticateMiddleware, authorizeMiddleware } from '../middleware/auth';\r\n\r\n    export async function GET(req: Request) {\r\n      // Wrong order: authorize before authenticate\r\n      authorizeMiddleware(req, res, next);\r\n      authenticateMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'success' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  \r\n  console.log('Analyzing route file...');\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('\\nAfter analyzing route:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  console.log(`Total usages tracked: ${usages.length}`);\r\n  usages.forEach((usage: any, idx: number) => {\r\n    console.log(`  Usage ${idx + 1}:`);\r\n    console.log(`    Middleware name: \"${usage.middlewareName}\"`);\r\n    console.log(`    Route file: ${usage.routeFile}`);\r\n    console.log(`    Order: ${usage.order}`);\r\n  });\r\n  console.log();\r\n\r\n  console.log('Route issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  ⚠️  No issues found!');\r\n    console.log('\\nLet me check what the ordering detection sees:');\r\n    \r\n    const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n    console.log(`  Usages for this route: ${routeUsages.length}`);\r\n    \r\n    if (routeUsages.length > 0) {\r\n      const order = routeUsages\r\n        .sort((a: any, b: any) => a.order - b.order)\r\n        .map((u: any) => u.middlewareName.toLowerCase());\r\n      \r\n      console.log(`  Order array: [${order.join(', ')}]`);\r\n      \r\n      const authIndex = order.findIndex((name: string) => \r\n        name.includes('auth') || name.includes('authenticate')\r\n      );\r\n      const authorizeIndex = order.findIndex((name: string) => \r\n        name.includes('authorize') || name.includes('permission')\r\n      );\r\n      \r\n      console.log(`  Auth index: ${authIndex} (looking for 'auth' or 'authenticate')`);\r\n      console.log(`  Authorize index: ${authorizeIndex} (looking for 'authorize' or 'permission')`);\r\n      console.log(`  Should trigger anti-pattern: ${authIndex > authorizeIndex && authIndex >= 0 && authorizeIndex >= 0}`);\r\n    }\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description}`);\r\n    });\r\n  }\r\n}\r\n\r\ndetailedDebug().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\codebase-cleanup\\test-rate-limit-debug.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[342,345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[342,345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2293,2296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2293,2296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2426,2429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2426,2429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2520,2523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2520,2523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":80,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2528,2531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2528,2531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":81,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2569,2572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2569,2572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Debug rate limiting detection\r\n */\r\n\r\nimport { Project } from 'ts-morph';\r\nimport { MiddlewarePatternAnalyzer } from './src/analyzers/middleware-pattern-analyzer';\r\nimport type { FileInfo } from './src/types';\r\n\r\nclass DebugMiddlewareAnalyzer extends MiddlewarePatternAnalyzer {\r\n  public getMiddlewareUsages() {\r\n    return (this as any).middlewareUsages;\r\n  }\r\n}\r\n\r\nasync function debugRateLimit() {\r\n  console.log('Debugging Rate Limit Detection...\\n');\r\n\r\n  const analyzer = new DebugMiddlewareAnalyzer();\r\n  const project = new Project();\r\n\r\n  // Create middleware\r\n  const middlewareLib = `\r\n    export function rateLimitMiddleware(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic1(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic2(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n    export function businessLogic3(req: Request, res: Response, next: NextFunction) {\r\n      next();\r\n    }\r\n  `;\r\n\r\n  const libFile = project.createSourceFile('middleware/lib.ts', middlewareLib);\r\n  await analyzer.analyze({\r\n    path: '/test/middleware/lib.ts',\r\n    relativePath: 'middleware/lib.ts',\r\n    extension: '.ts',\r\n    size: middlewareLib.length,\r\n    category: 'middleware',\r\n    lastModified: new Date(),\r\n  }, libFile);\r\n\r\n  // Create route with rate limit at the end\r\n  const routeCode = `\r\n    import { businessLogic1, businessLogic2, businessLogic3, rateLimitMiddleware } from '../middleware/lib';\r\n\r\n    export async function POST(req: Request) {\r\n      businessLogic1(req, res, next);\r\n      businessLogic2(req, res, next);\r\n      businessLogic3(req, res, next);\r\n      rateLimitMiddleware(req, res, next);\r\n      \r\n      return Response.json({ data: 'created' });\r\n    }\r\n  `;\r\n\r\n  const routeFile = project.createSourceFile('app/api/test/route.ts', routeCode);\r\n  const routeIssues = await analyzer.analyze({\r\n    path: '/test/app/api/test/route.ts',\r\n    relativePath: 'app/api/test/route.ts',\r\n    extension: '.ts',\r\n    size: routeCode.length,\r\n    category: 'api-route',\r\n    lastModified: new Date(),\r\n  }, routeFile);\r\n\r\n  console.log('Usages tracked:');\r\n  const usages = analyzer.getMiddlewareUsages();\r\n  usages.forEach((u: any) => {\r\n    console.log(`  ${u.order}: ${u.middlewareName}`);\r\n  });\r\n  console.log();\r\n\r\n  const routeUsages = usages.filter((u: any) => u.routeFile === 'app/api/test/route.ts');\r\n  const order = routeUsages\r\n    .sort((a: any, b: any) => a.order - b.order)\r\n    .map((u: any) => u.middlewareName.toLowerCase());\r\n  \r\n  console.log(`Order array: [${order.join(', ')}]`);\r\n  \r\n  const rateLimitIndex = order.findIndex((name: string) => \r\n    name.includes('ratelimit') || name.includes('rate-limit') || name.includes('throttle')\r\n  );\r\n  \r\n  console.log(`Rate limit index: ${rateLimitIndex}`);\r\n  console.log(`Should trigger (index > 2): ${rateLimitIndex > 2}`);\r\n  console.log();\r\n\r\n  console.log('Issues found:');\r\n  if (routeIssues.length === 0) {\r\n    console.log('  ⚠️  No issues!');\r\n  } else {\r\n    routeIssues.forEach(issue => {\r\n      console.log(`  - [${issue.severity}] ${issue.description.substring(0, 100)}`);\r\n    });\r\n  }\r\n}\r\n\r\ndebugRateLimit().catch(console.error);\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\content-layout-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport { ToggleGroup, ToggleGroupItem } from \"@/components/ui/toggle-group\";\r\n\r\nexport function ContentLayoutSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  return (\r\n    <div className=\"hidden flex-col gap-4 lg:flex\">\r\n      <Label>Content layout</Label>\r\n      <ToggleGroup\r\n        value={theme.contentLayout}\r\n        type=\"single\"\r\n        onValueChange={(value) => setTheme({ ...theme, contentLayout: value as any })}\r\n        className=\"*:border-input w-full gap-4 *:rounded-md *:border\">\r\n        <ToggleGroupItem variant=\"outline\" value=\"full\">\r\n          Full\r\n        </ToggleGroupItem>\r\n        <ToggleGroupItem\r\n          variant=\"outline\"\r\n          value=\"centered\"\r\n          className=\"data-[variant=outline]:border-l-1\">\r\n          Centered\r\n        </ToggleGroupItem>\r\n      </ToggleGroup>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\theme-customizer\\preset-selector.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[496,499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[496,499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { DEFAULT_THEME, THEMES } from \"@/lib/themes\";\r\nimport { useThemeConfig } from \"@/components/active-theme\";\r\nimport {\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue\r\n} from \"@/components/ui/select\";\r\nimport { Label } from \"@/components/ui/label\";\r\n\r\nexport function PresetSelector() {\r\n  const { theme, setTheme } = useThemeConfig();\r\n\r\n  const handlePreset = (value: string) => {\r\n    setTheme({ ...theme, ...DEFAULT_THEME, preset: value as any });\r\n  };\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-4\">\r\n      <Label>Theme preset:</Label>\r\n      <Select value={theme.preset} onValueChange={(value) => handlePreset(value)}>\r\n        <SelectTrigger className=\"w-full\">\r\n          <SelectValue placeholder=\"Select a theme\" />\r\n        </SelectTrigger>\r\n        <SelectContent align=\"end\">\r\n          {THEMES.map((theme) => (\r\n            <SelectItem key={theme.name} value={theme.value}>\r\n              <div className=\"flex shrink-0 gap-1\">\r\n                {theme.colors.map((color, key) => (\r\n                  <span\r\n                    key={key}\r\n                    className=\"size-2 rounded-full\"\r\n                    style={{ backgroundColor: color }}></span>\r\n                ))}\r\n              </div>\r\n              {theme.name}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n    </div>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\ui\\custom\\minimal-tiptap\\extensions\\code-block-lowlight\\code-block-lowlight.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[325,328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[325,328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CodeBlockLowlight as TiptapCodeBlockLowlight } from \"@tiptap/extension-code-block-lowlight\";\r\nimport { common, createLowlight } from \"lowlight\";\r\n\r\nexport const CodeBlockLowlight = TiptapCodeBlockLowlight.extend({\r\n  addOptions() {\r\n    return {\r\n      ...this.parent?.(),\r\n      lowlight: createLowlight(common) as any,\r\n      defaultLanguage: null,\r\n      HTMLAttributes: {\r\n        class: \"block-node\",\r\n      },\r\n    };\r\n  },\r\n});\r\n\r\nexport default CodeBlockLowlight;\r\n","usedDeprecatedRules":[]},{"filePath":"E:\\Development\\aluminify\\components\\ui\\kanban.tsx","messages":[{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `kanbanProps`, but the source dependencies were [kanbanProps.onDragStart]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:297:5\n  295 |\n  296 |   const onDragStart = React.useCallback(\n> 297 |     (event: DragStartEvent) => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 298 |       kanbanProps.onDragStart?.(event);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 299 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 300 |       if (event.activatorEvent.defaultPrevented) return;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 301 |       setActiveId(event.active.id);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 302 |     },\n      | ^^^^^^ Could not preserve existing manual memoization\n  303 |     [kanbanProps.onDragStart]\n  304 |   );\n  305 |","line":297,"column":5,"nodeType":null,"endLine":302,"endColumn":6},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `kanbanProps`, but the source dependencies were [value, getColumn, getItemValue, onValueChange, kanbanProps.onDragOver]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:307:5\n  305 |\n  306 |   const onDragOver = React.useCallback(\n> 307 |     (event: DragOverEvent) => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 308 |       kanbanProps.onDragOver?.(event);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 309 |\n      …\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 353 |       }\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 354 |     },\n      | ^^^^^^ Could not preserve existing manual memoization\n  355 |     [value, getColumn, getItemValue, onValueChange, kanbanProps.onDragOver]\n  356 |   );\n  357 |","line":307,"column":5,"nodeType":null,"endLine":354,"endColumn":6},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `kanbanProps`, but the source dependencies were [value, getColumn, getItemValue, onValueChange, onMove, kanbanProps.onDragEnd]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:359:5\n  357 |\n  358 |   const onDragEnd = React.useCallback(\n> 359 |     (event: DragEndEvent) => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 360 |       kanbanProps.onDragEnd?.(event);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 361 |\n      …\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 429 |       hasMovedRef.current = false;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 430 |     },\n      | ^^^^^^ Could not preserve existing manual memoization\n  431 |     [value, getColumn, getItemValue, onValueChange, onMove, kanbanProps.onDragEnd]\n  432 |   );\n  433 |","line":359,"column":5,"nodeType":null,"endLine":430,"endColumn":6},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `kanbanProps`, but the source dependencies were [kanbanProps.onDragCancel]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:435:5\n  433 |\n  434 |   const onDragCancel = React.useCallback(\n> 435 |     (event: DragCancelEvent) => {\n      |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 436 |       kanbanProps.onDragCancel?.(event);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 437 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 438 |       if (event.activatorEvent.defaultPrevented) return;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 439 |\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 440 |       setActiveId(null);\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 441 |       hasMovedRef.current = false;\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 442 |     },\n      | ^^^^^^ Could not preserve existing manual memoization\n  443 |     [kanbanProps.onDragCancel]\n  444 |   );\n  445 |","line":435,"column":5,"nodeType":null,"endLine":442,"endColumn":6},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `context`, but the source dependencies were [context.items, value, context.getItemValue]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:710:31\n  708 |   }, [transform, transition, style]);\n  709 |\n> 710 |   const items = React.useMemo(() => {\n      |                               ^^^^^^^\n> 711 |     const items = context.items[value] ?? [];\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 712 |     return items.map((item) => context.getItemValue(item));\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 713 |   }, [context.items, value, context.getItemValue]);\n      | ^^^^ Could not preserve existing manual memoization\n  714 |\n  715 |   const columnContext = React.useMemo<KanbanColumnContextValue>(\n  716 |     () => ({","line":710,"column":31,"nodeType":null,"endLine":713,"endColumn":4},{"ruleId":"react-hooks/preserve-manual-memoization","severity":2,"message":"Compilation Skipped: Existing memoization could not be preserved\n\nReact Compiler has skipped optimizing this component because the existing manual memoization could not be preserved. The inferred dependencies did not match the manually specified dependencies, which could cause the value to change more or less frequently than expected. The inferred dependency was `context`, but the source dependencies were [context.items, value, context.getItemValue]. Inferred less specific property than source.\n\nE:\\Development\\aluminify\\components\\ui\\kanban.tsx:710:31\n  708 |   }, [transform, transition, style]);\n  709 |\n> 710 |   const items = React.useMemo(() => {\n      |                               ^^^^^^^\n> 711 |     const items = context.items[value] ?? [];\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 712 |     return items.map((item) => context.getItemValue(item));\n      | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n> 713 |   }, [context.items, value, context.getItemValue]);\n      | ^^^^ Could not preserve existing manual memoization\n  714 |\n  715 |   const columnContext = React.useMemo<KanbanColumnContextValue>(\n  716 |     () => ({","line":710,"column":31,"nodeType":null,"endLine":713,"endColumn":4}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport {\r\n  type Announcements,\r\n  type CollisionDetection,\r\n  DndContext,\r\n  type DndContextProps,\r\n  type DragCancelEvent,\r\n  type DragEndEvent,\r\n  type DragOverEvent,\r\n  DragOverlay,\r\n  type DragStartEvent,\r\n  type DraggableAttributes,\r\n  type DraggableSyntheticListeners,\r\n  type DropAnimation,\r\n  type DroppableContainer,\r\n  KeyboardCode,\r\n  type KeyboardCoordinateGetter,\r\n  KeyboardSensor,\r\n  MeasuringStrategy,\r\n  MouseSensor,\r\n  TouchSensor,\r\n  type UniqueIdentifier,\r\n  closestCenter,\r\n  closestCorners,\r\n  defaultDropAnimationSideEffects,\r\n  getFirstCollision,\r\n  pointerWithin,\r\n  rectIntersection,\r\n  useSensor,\r\n  useSensors\r\n} from \"@dnd-kit/core\";\r\nimport {\r\n  type AnimateLayoutChanges,\r\n  SortableContext,\r\n  type SortableContextProps,\r\n  arrayMove,\r\n  defaultAnimateLayoutChanges,\r\n  horizontalListSortingStrategy,\r\n  useSortable,\r\n  verticalListSortingStrategy\r\n} from \"@dnd-kit/sortable\";\r\nimport { CSS } from \"@dnd-kit/utilities\";\r\nimport { Slot } from \"@radix-ui/react-slot\";\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\n\r\nimport { useComposedRefs } from \"@/lib/compose-refs\";\r\nimport { cn } from \"@/lib/utils\";\r\n\r\nconst directions: string[] = [\r\n  KeyboardCode.Down,\r\n  KeyboardCode.Right,\r\n  KeyboardCode.Up,\r\n  KeyboardCode.Left\r\n];\r\n\r\nconst coordinateGetter: KeyboardCoordinateGetter = (event, { context }) => {\r\n  const { active, droppableRects, droppableContainers, collisionRect } = context;\r\n\r\n  if (directions.includes(event.code)) {\r\n    event.preventDefault();\r\n\r\n    if (!active || !collisionRect) return;\r\n\r\n    const filteredContainers: DroppableContainer[] = [];\r\n\r\n    for (const entry of droppableContainers.getEnabled()) {\r\n      if (!entry || entry?.disabled) return;\r\n\r\n      const rect = droppableRects.get(entry.id);\r\n\r\n      if (!rect) return;\r\n\r\n      const data = entry.data.current;\r\n\r\n      if (data) {\r\n        const { type, children } = data;\r\n\r\n        if (type === \"container\" && children?.length > 0) {\r\n          if (active.data.current?.type !== \"container\") {\r\n            return;\r\n          }\r\n        }\r\n      }\r\n\r\n      switch (event.code) {\r\n        case KeyboardCode.Down:\r\n          if (collisionRect.top < rect.top) {\r\n            filteredContainers.push(entry);\r\n          }\r\n          break;\r\n        case KeyboardCode.Up:\r\n          if (collisionRect.top > rect.top) {\r\n            filteredContainers.push(entry);\r\n          }\r\n          break;\r\n        case KeyboardCode.Left:\r\n          if (collisionRect.left >= rect.left + rect.width) {\r\n            filteredContainers.push(entry);\r\n          }\r\n          break;\r\n        case KeyboardCode.Right:\r\n          if (collisionRect.left + collisionRect.width <= rect.left) {\r\n            filteredContainers.push(entry);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    const collisions = closestCorners({\r\n      active,\r\n      collisionRect: collisionRect,\r\n      droppableRects,\r\n      droppableContainers: filteredContainers,\r\n      pointerCoordinates: null\r\n    });\r\n    const closestId = getFirstCollision(collisions, \"id\");\r\n\r\n    if (closestId != null) {\r\n      const newDroppable = droppableContainers.get(closestId);\r\n      const newNode = newDroppable?.node.current;\r\n      const newRect = newDroppable?.rect.current;\r\n\r\n      if (newNode && newRect) {\r\n        if (newDroppable.id === \"placeholder\") {\r\n          return {\r\n            x: newRect.left + (newRect.width - collisionRect.width) / 2,\r\n            y: newRect.top + (newRect.height - collisionRect.height) / 2\r\n          };\r\n        }\r\n\r\n        if (newDroppable.data.current?.type === \"container\") {\r\n          return {\r\n            x: newRect.left + 20,\r\n            y: newRect.top + 74\r\n          };\r\n        }\r\n\r\n        return {\r\n          x: newRect.left,\r\n          y: newRect.top\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n};\r\n\r\nconst ROOT_NAME = \"Kanban\";\r\nconst BOARD_NAME = \"KanbanBoard\";\r\nconst COLUMN_NAME = \"KanbanColumn\";\r\nconst COLUMN_HANDLE_NAME = \"KanbanColumnHandle\";\r\nconst ITEM_NAME = \"KanbanItem\";\r\nconst ITEM_HANDLE_NAME = \"KanbanItemHandle\";\r\nconst OVERLAY_NAME = \"KanbanOverlay\";\r\n\r\ninterface KanbanContextValue<T> {\r\n  id: string;\r\n  items: Record<UniqueIdentifier, T[]>;\r\n  modifiers: DndContextProps[\"modifiers\"];\r\n  strategy: SortableContextProps[\"strategy\"];\r\n  orientation: \"horizontal\" | \"vertical\";\r\n  activeId: UniqueIdentifier | null;\r\n  setActiveId: (id: UniqueIdentifier | null) => void;\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n  flatCursor: boolean;\r\n}\r\n\r\nconst KanbanContext = React.createContext<KanbanContextValue<unknown> | null>(null);\r\nKanbanContext.displayName = ROOT_NAME;\r\n\r\nfunction useKanbanContext(consumerName: string) {\r\n  const context = React.useContext(KanbanContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ROOT_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface GetItemValue<T> {\r\n  /**\r\n   * Callback that returns a unique identifier for each kanban item. Required for array of objects.\r\n   * @example getItemValue={(item) => item.id}\r\n   */\r\n  getItemValue: (item: T) => UniqueIdentifier;\r\n}\r\n\r\ntype KanbanRootProps<T> = Omit<DndContextProps, \"collisionDetection\"> &\r\n  GetItemValue<T> & {\r\n    value: Record<UniqueIdentifier, T[]>;\r\n    onValueChange?: (columns: Record<UniqueIdentifier, T[]>) => void;\r\n    onMove?: (event: DragEndEvent & { activeIndex: number; overIndex: number }) => void;\r\n    strategy?: SortableContextProps[\"strategy\"];\r\n    orientation?: \"horizontal\" | \"vertical\";\r\n    flatCursor?: boolean;\r\n  } & (T extends object ? GetItemValue<T> : Partial<GetItemValue<T>>);\r\n\r\nfunction KanbanRoot<T>(props: KanbanRootProps<T>) {\r\n  const {\r\n    value,\r\n    onValueChange,\r\n    modifiers,\r\n    strategy = verticalListSortingStrategy,\r\n    orientation = \"horizontal\",\r\n    onMove,\r\n    getItemValue: getItemValueProp,\r\n    accessibility,\r\n    flatCursor = false,\r\n    ...kanbanProps\r\n  } = props;\r\n\r\n  const id = React.useId();\r\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\r\n  const lastOverIdRef = React.useRef<UniqueIdentifier | null>(null);\r\n  const hasMovedRef = React.useRef(false);\r\n  const sensors = useSensors(\r\n    useSensor(MouseSensor),\r\n    useSensor(TouchSensor),\r\n    useSensor(KeyboardSensor, {\r\n      coordinateGetter\r\n    })\r\n  );\r\n\r\n  const getItemValue = React.useCallback(\r\n    (item: T): UniqueIdentifier => {\r\n      if (typeof item === \"object\" && !getItemValueProp) {\r\n        throw new Error(\"getItemValue is required when using array of objects\");\r\n      }\r\n      return getItemValueProp ? getItemValueProp(item) : (item as UniqueIdentifier);\r\n    },\r\n    [getItemValueProp]\r\n  );\r\n\r\n  const getColumn = React.useCallback(\r\n    (id: UniqueIdentifier) => {\r\n      if (id in value) return id;\r\n\r\n      for (const [columnId, items] of Object.entries(value)) {\r\n        if (items.some((item) => getItemValue(item) === id)) {\r\n          return columnId;\r\n        }\r\n      }\r\n\r\n      return null;\r\n    },\r\n    [value, getItemValue]\r\n  );\r\n\r\n  const collisionDetection: CollisionDetection = React.useCallback(\r\n    (args) => {\r\n      if (activeId && activeId in value) {\r\n        return closestCenter({\r\n          ...args,\r\n          droppableContainers: args.droppableContainers.filter((container) => container.id in value)\r\n        });\r\n      }\r\n\r\n      const pointerIntersections = pointerWithin(args);\r\n      const intersections =\r\n        pointerIntersections.length > 0 ? pointerIntersections : rectIntersection(args);\r\n      let overId = getFirstCollision(intersections, \"id\");\r\n\r\n      if (!overId) {\r\n        if (hasMovedRef.current) {\r\n          lastOverIdRef.current = activeId;\r\n        }\r\n        return lastOverIdRef.current ? [{ id: lastOverIdRef.current }] : [];\r\n      }\r\n\r\n      if (overId in value) {\r\n        const containerItems = value[overId];\r\n        if (containerItems && containerItems.length > 0) {\r\n          const closestItem = closestCenter({\r\n            ...args,\r\n            droppableContainers: args.droppableContainers.filter(\r\n              (container) =>\r\n                container.id !== overId &&\r\n                containerItems.some((item) => getItemValue(item) === container.id)\r\n            )\r\n          });\r\n\r\n          if (closestItem.length > 0) {\r\n            overId = closestItem[0]?.id ?? overId;\r\n          }\r\n        }\r\n      }\r\n\r\n      lastOverIdRef.current = overId;\r\n      return [{ id: overId }];\r\n    },\r\n    [activeId, value, getItemValue]\r\n  );\r\n\r\n  const onDragStart = React.useCallback(\r\n    (event: DragStartEvent) => {\r\n      kanbanProps.onDragStart?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n      setActiveId(event.active.id);\r\n    },\r\n    [kanbanProps.onDragStart]\r\n  );\r\n\r\n  const onDragOver = React.useCallback(\r\n    (event: DragOverEvent) => {\r\n      kanbanProps.onDragOver?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      const { active, over } = event;\r\n      if (!over) return;\r\n\r\n      const activeColumn = getColumn(active.id);\r\n      const overColumn = getColumn(over.id);\r\n\r\n      if (!activeColumn || !overColumn) return;\r\n\r\n      if (activeColumn === overColumn) {\r\n        const items = value[activeColumn];\r\n        if (!items) return;\r\n\r\n        const activeIndex = items.findIndex((item) => getItemValue(item) === active.id);\r\n        const overIndex = items.findIndex((item) => getItemValue(item) === over.id);\r\n\r\n        if (activeIndex !== overIndex) {\r\n          const newColumns = { ...value };\r\n          newColumns[activeColumn] = arrayMove(items, activeIndex, overIndex);\r\n          onValueChange?.(newColumns);\r\n        }\r\n      } else {\r\n        const activeItems = value[activeColumn];\r\n        const overItems = value[overColumn];\r\n\r\n        if (!activeItems || !overItems) return;\r\n\r\n        const activeIndex = activeItems.findIndex((item) => getItemValue(item) === active.id);\r\n\r\n        if (activeIndex === -1) return;\r\n\r\n        const activeItem = activeItems[activeIndex];\r\n        if (!activeItem) return;\r\n\r\n        const updatedItems = {\r\n          ...value,\r\n          [activeColumn]: activeItems.filter((item) => getItemValue(item) !== active.id),\r\n          [overColumn]: [...overItems, activeItem]\r\n        };\r\n\r\n        onValueChange?.(updatedItems);\r\n        hasMovedRef.current = true;\r\n      }\r\n    },\r\n    [value, getColumn, getItemValue, onValueChange, kanbanProps.onDragOver]\r\n  );\r\n\r\n  const onDragEnd = React.useCallback(\r\n    (event: DragEndEvent) => {\r\n      kanbanProps.onDragEnd?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      const { active, over } = event;\r\n\r\n      if (!over) {\r\n        setActiveId(null);\r\n        return;\r\n      }\r\n\r\n      if (active.id in value && over.id in value) {\r\n        const activeIndex = Object.keys(value).indexOf(active.id as string);\r\n        const overIndex = Object.keys(value).indexOf(over.id as string);\r\n\r\n        if (activeIndex !== overIndex) {\r\n          const orderedColumns = Object.keys(value);\r\n          const newOrder = arrayMove(orderedColumns, activeIndex, overIndex);\r\n\r\n          const newColumns: Record<UniqueIdentifier, T[]> = {};\r\n          for (const key of newOrder) {\r\n            const items = value[key];\r\n            if (items) {\r\n              newColumns[key] = items;\r\n            }\r\n          }\r\n\r\n          if (onMove) {\r\n            onMove({ ...event, activeIndex, overIndex });\r\n          } else {\r\n            onValueChange?.(newColumns);\r\n          }\r\n        }\r\n      } else {\r\n        const activeColumn = getColumn(active.id);\r\n        const overColumn = getColumn(over.id);\r\n\r\n        if (!activeColumn || !overColumn) {\r\n          setActiveId(null);\r\n          return;\r\n        }\r\n\r\n        if (activeColumn === overColumn) {\r\n          const items = value[activeColumn];\r\n          if (!items) {\r\n            setActiveId(null);\r\n            return;\r\n          }\r\n\r\n          const activeIndex = items.findIndex((item) => getItemValue(item) === active.id);\r\n          const overIndex = items.findIndex((item) => getItemValue(item) === over.id);\r\n\r\n          if (activeIndex !== overIndex) {\r\n            const newColumns = { ...value };\r\n            newColumns[activeColumn] = arrayMove(items, activeIndex, overIndex);\r\n            if (onMove) {\r\n              onMove({\r\n                ...event,\r\n                activeIndex,\r\n                overIndex\r\n              });\r\n            } else {\r\n              onValueChange?.(newColumns);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      setActiveId(null);\r\n      hasMovedRef.current = false;\r\n    },\r\n    [value, getColumn, getItemValue, onValueChange, onMove, kanbanProps.onDragEnd]\r\n  );\r\n\r\n  const onDragCancel = React.useCallback(\r\n    (event: DragCancelEvent) => {\r\n      kanbanProps.onDragCancel?.(event);\r\n\r\n      if (event.activatorEvent.defaultPrevented) return;\r\n\r\n      setActiveId(null);\r\n      hasMovedRef.current = false;\r\n    },\r\n    [kanbanProps.onDragCancel]\r\n  );\r\n\r\n  const announcements: Announcements = React.useMemo(\r\n    () => ({\r\n      onDragStart({ active }) {\r\n        const isColumn = active.id in value;\r\n        const itemType = isColumn ? \"column\" : \"item\";\r\n        const position = isColumn\r\n          ? Object.keys(value).indexOf(active.id as string) + 1\r\n          : (() => {\r\n              const column = getColumn(active.id);\r\n              if (!column || !value[column]) return 1;\r\n              return value[column].findIndex((item) => getItemValue(item) === active.id) + 1;\r\n            })();\r\n        const total = isColumn\r\n          ? Object.keys(value).length\r\n          : (() => {\r\n              const column = getColumn(active.id);\r\n              return column ? (value[column]?.length ?? 0) : 0;\r\n            })();\r\n\r\n        return `Picked up ${itemType} at position ${position} of ${total}`;\r\n      },\r\n      onDragOver({ active, over }) {\r\n        if (!over) return;\r\n\r\n        const isColumn = active.id in value;\r\n        const itemType = isColumn ? \"column\" : \"item\";\r\n        const position = isColumn\r\n          ? Object.keys(value).indexOf(over.id as string) + 1\r\n          : (() => {\r\n              const column = getColumn(over.id);\r\n              if (!column || !value[column]) return 1;\r\n              return value[column].findIndex((item) => getItemValue(item) === over.id) + 1;\r\n            })();\r\n        const total = isColumn\r\n          ? Object.keys(value).length\r\n          : (() => {\r\n              const column = getColumn(over.id);\r\n              return column ? (value[column]?.length ?? 0) : 0;\r\n            })();\r\n\r\n        const overColumn = getColumn(over.id);\r\n        const activeColumn = getColumn(active.id);\r\n\r\n        if (isColumn) {\r\n          return `${itemType} is now at position ${position} of ${total}`;\r\n        }\r\n\r\n        if (activeColumn !== overColumn) {\r\n          return `${itemType} is now at position ${position} of ${total} in ${overColumn}`;\r\n        }\r\n\r\n        return `${itemType} is now at position ${position} of ${total}`;\r\n      },\r\n      onDragEnd({ active, over }) {\r\n        if (!over) return;\r\n\r\n        const isColumn = active.id in value;\r\n        const itemType = isColumn ? \"column\" : \"item\";\r\n        const position = isColumn\r\n          ? Object.keys(value).indexOf(over.id as string) + 1\r\n          : (() => {\r\n              const column = getColumn(over.id);\r\n              if (!column || !value[column]) return 1;\r\n              return value[column].findIndex((item) => getItemValue(item) === over.id) + 1;\r\n            })();\r\n        const total = isColumn\r\n          ? Object.keys(value).length\r\n          : (() => {\r\n              const column = getColumn(over.id);\r\n              return column ? (value[column]?.length ?? 0) : 0;\r\n            })();\r\n\r\n        const overColumn = getColumn(over.id);\r\n        const activeColumn = getColumn(active.id);\r\n\r\n        if (isColumn) {\r\n          return `${itemType} was dropped at position ${position} of ${total}`;\r\n        }\r\n\r\n        if (activeColumn !== overColumn) {\r\n          return `${itemType} was dropped at position ${position} of ${total} in ${overColumn}`;\r\n        }\r\n\r\n        return `${itemType} was dropped at position ${position} of ${total}`;\r\n      },\r\n      onDragCancel({ active }) {\r\n        const isColumn = active.id in value;\r\n        const itemType = isColumn ? \"column\" : \"item\";\r\n        return `Dragging was cancelled. ${itemType} was dropped.`;\r\n      }\r\n    }),\r\n    [value, getColumn, getItemValue]\r\n  );\r\n\r\n  const contextValue = React.useMemo<KanbanContextValue<T>>(\r\n    () => ({\r\n      id,\r\n      items: value,\r\n      modifiers,\r\n      strategy,\r\n      orientation,\r\n      activeId,\r\n      setActiveId,\r\n      getItemValue,\r\n      flatCursor\r\n    }),\r\n    [id, value, activeId, modifiers, strategy, orientation, getItemValue, flatCursor]\r\n  );\r\n\r\n  return (\r\n    <KanbanContext.Provider value={contextValue as KanbanContextValue<unknown>}>\r\n      <DndContext\r\n        collisionDetection={collisionDetection}\r\n        modifiers={modifiers}\r\n        sensors={sensors}\r\n        {...kanbanProps}\r\n        id={id}\r\n        measuring={{\r\n          droppable: {\r\n            strategy: MeasuringStrategy.Always\r\n          }\r\n        }}\r\n        onDragStart={onDragStart}\r\n        onDragOver={onDragOver}\r\n        onDragEnd={onDragEnd}\r\n        onDragCancel={onDragCancel}\r\n        accessibility={{\r\n          announcements,\r\n          screenReaderInstructions: {\r\n            draggable: `\r\n            To pick up a kanban item or column, press space or enter.\r\n            While dragging, use the arrow keys to move the item.\r\n            Press space or enter again to drop the item in its new position, or press escape to cancel.\r\n          `\r\n          },\r\n          ...accessibility\r\n        }}\r\n      />\r\n    </KanbanContext.Provider>\r\n  );\r\n}\r\n\r\nconst KanbanBoardContext = React.createContext<boolean>(false);\r\nKanbanBoardContext.displayName = BOARD_NAME;\r\n\r\ninterface KanbanBoardProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  children: React.ReactNode;\r\n  asChild?: boolean;\r\n}\r\n\r\nconst KanbanBoard = React.forwardRef<HTMLDivElement, KanbanBoardProps>((props, forwardedRef) => {\r\n  const { asChild, className, ...boardProps } = props;\r\n\r\n  const context = useKanbanContext(BOARD_NAME);\r\n\r\n  const columns = React.useMemo(() => {\r\n    return Object.keys(context.items);\r\n  }, [context.items]);\r\n\r\n  const BoardPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <KanbanBoardContext.Provider value={true}>\r\n      <SortableContext\r\n        items={columns}\r\n        strategy={\r\n          context.orientation === \"horizontal\"\r\n            ? horizontalListSortingStrategy\r\n            : verticalListSortingStrategy\r\n        }>\r\n        <BoardPrimitive\r\n          aria-orientation={context.orientation}\r\n          data-orientation={context.orientation}\r\n          data-slot=\"kanban-board\"\r\n          {...boardProps}\r\n          ref={forwardedRef}\r\n          className={cn(\r\n            \"flex size-full gap-4\",\r\n            context.orientation === \"horizontal\" ? \"flex-row\" : \"flex-col\",\r\n            className\r\n          )}\r\n        />\r\n      </SortableContext>\r\n    </KanbanBoardContext.Provider>\r\n  );\r\n});\r\nKanbanBoard.displayName = BOARD_NAME;\r\n\r\ninterface KanbanColumnContextValue {\r\n  id: string;\r\n  attributes: DraggableAttributes;\r\n  listeners: DraggableSyntheticListeners | undefined;\r\n  setActivatorNodeRef: (node: HTMLElement | null) => void;\r\n  isDragging?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst KanbanColumnContext = React.createContext<KanbanColumnContextValue | null>(null);\r\nKanbanColumnContext.displayName = COLUMN_NAME;\r\n\r\nfunction useKanbanColumnContext(consumerName: string) {\r\n  const context = React.useContext(KanbanColumnContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${COLUMN_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\nconst animateLayoutChanges: AnimateLayoutChanges = (args) =>\r\n  defaultAnimateLayoutChanges({ ...args, wasDragging: true });\r\n\r\ninterface KanbanColumnProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  value: UniqueIdentifier;\r\n  children: React.ReactNode;\r\n  asChild?: boolean;\r\n  asHandle?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst KanbanColumn = React.forwardRef<HTMLDivElement, KanbanColumnProps>((props, forwardedRef) => {\r\n  const { value, asChild, asHandle, disabled, className, style, ...columnProps } = props;\r\n\r\n  const id = React.useId();\r\n  const context = useKanbanContext(COLUMN_NAME);\r\n  const inBoard = React.useContext(KanbanBoardContext);\r\n  const inOverlay = React.useContext(KanbanOverlayContext);\r\n\r\n  if (!inBoard && !inOverlay) {\r\n    throw new Error(\r\n      `\\`${COLUMN_NAME}\\` must be used within \\`${BOARD_NAME}\\` or \\`${OVERLAY_NAME}\\``\r\n    );\r\n  }\r\n\r\n  if (value === \"\") {\r\n    throw new Error(`\\`${COLUMN_NAME}\\` value cannot be an empty string`);\r\n  }\r\n\r\n  const {\r\n    attributes,\r\n    listeners,\r\n    setNodeRef,\r\n    setActivatorNodeRef,\r\n    transform,\r\n    transition,\r\n    isDragging\r\n  } = useSortable({\r\n    id: value,\r\n    disabled,\r\n    animateLayoutChanges\r\n  });\r\n\r\n  const composedRef = useComposedRefs(forwardedRef, (node) => {\r\n    if (disabled) return;\r\n    setNodeRef(node);\r\n  });\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      transform: CSS.Transform.toString(transform),\r\n      transition,\r\n      ...style\r\n    };\r\n  }, [transform, transition, style]);\r\n\r\n  const items = React.useMemo(() => {\r\n    const items = context.items[value] ?? [];\r\n    return items.map((item) => context.getItemValue(item));\r\n  }, [context.items, value, context.getItemValue]);\r\n\r\n  const columnContext = React.useMemo<KanbanColumnContextValue>(\r\n    () => ({\r\n      id,\r\n      attributes,\r\n      listeners,\r\n      setActivatorNodeRef,\r\n      isDragging,\r\n      disabled\r\n    }),\r\n    [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled]\r\n  );\r\n\r\n  const ColumnPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <KanbanColumnContext.Provider value={columnContext}>\r\n      <SortableContext\r\n        items={items}\r\n        strategy={\r\n          context.orientation === \"horizontal\"\r\n            ? horizontalListSortingStrategy\r\n            : verticalListSortingStrategy\r\n        }>\r\n        <ColumnPrimitive\r\n          id={id}\r\n          data-disabled={disabled}\r\n          data-dragging={isDragging ? \"\" : undefined}\r\n          data-slot=\"kanban-column\"\r\n          {...columnProps}\r\n          {...(asHandle && !disabled ? attributes : {})}\r\n          {...(asHandle && !disabled ? listeners : {})}\r\n          ref={composedRef}\r\n          style={composedStyle}\r\n          className={cn(\r\n            \"bg-muted flex size-full flex-col gap-2 rounded-lg p-2.5 aria-disabled:pointer-events-none aria-disabled:opacity-50\",\r\n            {\r\n              \"touch-none select-none\": asHandle,\r\n              \"cursor-default\": context.flatCursor,\r\n              \"data-dragging:cursor-grabbing\": !context.flatCursor,\r\n              \"cursor-grab\": !isDragging && asHandle && !context.flatCursor,\r\n              \"opacity-50\": isDragging,\r\n              \"pointer-events-none opacity-50\": disabled\r\n            },\r\n            className\r\n          )}\r\n        />\r\n      </SortableContext>\r\n    </KanbanColumnContext.Provider>\r\n  );\r\n});\r\nKanbanColumn.displayName = COLUMN_NAME;\r\n\r\ninterface KanbanColumnHandleProps extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst KanbanColumnHandle = React.forwardRef<HTMLButtonElement, KanbanColumnHandleProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, disabled, className, ...columnHandleProps } = props;\r\n\r\n    const context = useKanbanContext(COLUMN_NAME);\r\n    const columnContext = useKanbanColumnContext(COLUMN_HANDLE_NAME);\r\n\r\n    const isDisabled = disabled ?? columnContext.disabled;\r\n\r\n    const composedRef = useComposedRefs(forwardedRef, (node) => {\r\n      if (isDisabled) return;\r\n      columnContext.setActivatorNodeRef(node);\r\n    });\r\n\r\n    const HandlePrimitive = asChild ? Slot : \"button\";\r\n\r\n    return (\r\n      <HandlePrimitive\r\n        type=\"button\"\r\n        aria-controls={columnContext.id}\r\n        data-disabled={isDisabled}\r\n        data-dragging={columnContext.isDragging ? \"\" : undefined}\r\n        data-slot=\"kanban-column-handle\"\r\n        {...columnHandleProps}\r\n        {...(isDisabled ? {} : columnContext.attributes)}\r\n        {...(isDisabled ? {} : columnContext.listeners)}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"select-none disabled:pointer-events-none disabled:opacity-50\",\r\n          context.flatCursor ? \"cursor-default\" : \"cursor-grab data-dragging:cursor-grabbing\",\r\n          className\r\n        )}\r\n        disabled={isDisabled}\r\n      />\r\n    );\r\n  }\r\n);\r\nKanbanColumnHandle.displayName = COLUMN_HANDLE_NAME;\r\n\r\ninterface KanbanItemContextValue {\r\n  id: string;\r\n  attributes: DraggableAttributes;\r\n  listeners: DraggableSyntheticListeners | undefined;\r\n  setActivatorNodeRef: (node: HTMLElement | null) => void;\r\n  isDragging?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst KanbanItemContext = React.createContext<KanbanItemContextValue | null>(null);\r\nKanbanItemContext.displayName = ITEM_NAME;\r\n\r\nfunction useKanbanItemContext(consumerName: string) {\r\n  const context = React.useContext(KanbanItemContext);\r\n  if (!context) {\r\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${ITEM_NAME}\\``);\r\n  }\r\n  return context;\r\n}\r\n\r\ninterface KanbanItemProps extends React.ComponentPropsWithoutRef<\"div\"> {\r\n  value: UniqueIdentifier;\r\n  asHandle?: boolean;\r\n  asChild?: boolean;\r\n  disabled?: boolean;\r\n}\r\n\r\nconst KanbanItem = React.forwardRef<HTMLDivElement, KanbanItemProps>((props, forwardedRef) => {\r\n  const { value, style, asHandle, asChild, disabled, className, ...itemProps } = props;\r\n\r\n  const id = React.useId();\r\n  const context = useKanbanContext(ITEM_NAME);\r\n  const inBoard = React.useContext(KanbanBoardContext);\r\n  const inOverlay = React.useContext(KanbanOverlayContext);\r\n\r\n  if (!inBoard && !inOverlay) {\r\n    throw new Error(`\\`${ITEM_NAME}\\` must be used within \\`${BOARD_NAME}\\``);\r\n  }\r\n\r\n  const {\r\n    attributes,\r\n    listeners,\r\n    setNodeRef,\r\n    setActivatorNodeRef,\r\n    transform,\r\n    transition,\r\n    isDragging\r\n  } = useSortable({ id: value, disabled });\r\n\r\n  if (value === \"\") {\r\n    throw new Error(`\\`${ITEM_NAME}\\` value cannot be an empty string`);\r\n  }\r\n\r\n  const composedRef = useComposedRefs(forwardedRef, (node) => {\r\n    if (disabled) return;\r\n    setNodeRef(node);\r\n  });\r\n\r\n  const composedStyle = React.useMemo<React.CSSProperties>(() => {\r\n    return {\r\n      transform: CSS.Transform.toString(transform),\r\n      transition,\r\n      ...style\r\n    };\r\n  }, [transform, transition, style]);\r\n\r\n  const itemContext = React.useMemo<KanbanItemContextValue>(\r\n    () => ({\r\n      id,\r\n      attributes,\r\n      listeners,\r\n      setActivatorNodeRef,\r\n      isDragging,\r\n      disabled\r\n    }),\r\n    [id, attributes, listeners, setActivatorNodeRef, isDragging, disabled]\r\n  );\r\n\r\n  const ItemPrimitive = asChild ? Slot : \"div\";\r\n\r\n  return (\r\n    <KanbanItemContext.Provider value={itemContext}>\r\n      <ItemPrimitive\r\n        id={id}\r\n        data-disabled={disabled}\r\n        data-dragging={isDragging ? \"\" : undefined}\r\n        data-slot=\"kanban-item\"\r\n        {...itemProps}\r\n        {...(asHandle && !disabled ? attributes : {})}\r\n        {...(asHandle && !disabled ? listeners : {})}\r\n        ref={composedRef}\r\n        style={composedStyle}\r\n        className={cn(\r\n          \"focus-visible:ring-ring focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden\",\r\n          {\r\n            \"touch-none select-none\": asHandle,\r\n            \"cursor-default\": context.flatCursor,\r\n            \"data-dragging:cursor-grabbing\": !context.flatCursor,\r\n            \"cursor-grab\": !isDragging && asHandle && !context.flatCursor,\r\n            \"opacity-50\": isDragging,\r\n            \"pointer-events-none opacity-50\": disabled\r\n          },\r\n          className\r\n        )}\r\n      />\r\n    </KanbanItemContext.Provider>\r\n  );\r\n});\r\nKanbanItem.displayName = ITEM_NAME;\r\n\r\ninterface KanbanItemHandleProps extends React.ComponentPropsWithoutRef<\"button\"> {\r\n  asChild?: boolean;\r\n}\r\n\r\nconst KanbanItemHandle = React.forwardRef<HTMLButtonElement, KanbanItemHandleProps>(\r\n  (props, forwardedRef) => {\r\n    const { asChild, disabled, className, ...itemHandleProps } = props;\r\n\r\n    const context = useKanbanContext(ITEM_HANDLE_NAME);\r\n    const itemContext = useKanbanItemContext(ITEM_HANDLE_NAME);\r\n\r\n    const isDisabled = disabled ?? itemContext.disabled;\r\n\r\n    const composedRef = useComposedRefs(forwardedRef, (node) => {\r\n      if (isDisabled) return;\r\n      itemContext.setActivatorNodeRef(node);\r\n    });\r\n\r\n    const HandlePrimitive = asChild ? Slot : \"button\";\r\n\r\n    return (\r\n      <HandlePrimitive\r\n        type=\"button\"\r\n        aria-controls={itemContext.id}\r\n        data-disabled={isDisabled}\r\n        data-dragging={itemContext.isDragging ? \"\" : undefined}\r\n        data-slot=\"kanban-item-handle\"\r\n        {...itemHandleProps}\r\n        {...(isDisabled ? {} : itemContext.attributes)}\r\n        {...(isDisabled ? {} : itemContext.listeners)}\r\n        ref={composedRef}\r\n        className={cn(\r\n          \"select-none disabled:pointer-events-none disabled:opacity-50\",\r\n          context.flatCursor ? \"cursor-default\" : \"cursor-grab data-dragging:cursor-grabbing\",\r\n          className\r\n        )}\r\n        disabled={isDisabled}\r\n      />\r\n    );\r\n  }\r\n);\r\nKanbanItemHandle.displayName = ITEM_HANDLE_NAME;\r\n\r\nconst KanbanOverlayContext = React.createContext(false);\r\nKanbanOverlayContext.displayName = OVERLAY_NAME;\r\n\r\nconst dropAnimation: DropAnimation = {\r\n  sideEffects: defaultDropAnimationSideEffects({\r\n    styles: {\r\n      active: {\r\n        opacity: \"0.4\"\r\n      }\r\n    }\r\n  })\r\n};\r\n\r\ninterface KanbanOverlayProps\r\n  extends Omit<React.ComponentPropsWithoutRef<typeof DragOverlay>, \"children\"> {\r\n  container?: Element | DocumentFragment | null;\r\n  children?:\r\n    | ((params: { value: UniqueIdentifier; variant: \"column\" | \"item\" }) => React.ReactNode)\r\n    | React.ReactNode;\r\n}\r\n\r\nfunction KanbanOverlay(props: KanbanOverlayProps) {\r\n  const { container: containerProp, children, ...overlayProps } = props;\r\n\r\n  const context = useKanbanContext(OVERLAY_NAME);\r\n\r\n  const [mounted, setMounted] = React.useState(false);\r\n  React.useLayoutEffect(() => setMounted(true), []);\r\n\r\n  const container = containerProp ?? (mounted ? globalThis.document?.body : null);\r\n\r\n  if (!container) return null;\r\n\r\n  const variant = context.activeId && context.activeId in context.items ? \"column\" : \"item\";\r\n\r\n  return ReactDOM.createPortal(\r\n    <DragOverlay\r\n      dropAnimation={dropAnimation}\r\n      modifiers={context.modifiers}\r\n      className={cn(!context.flatCursor && \"cursor-grabbing\")}\r\n      {...overlayProps}>\r\n      <KanbanOverlayContext.Provider value={true}>\r\n        {context.activeId && children\r\n          ? typeof children === \"function\"\r\n            ? children({\r\n                value: context.activeId,\r\n                variant\r\n              })\r\n            : children\r\n          : null}\r\n      </KanbanOverlayContext.Provider>\r\n    </DragOverlay>,\r\n    container\r\n  );\r\n}\r\n\r\nexport {\r\n  KanbanRoot as Kanban,\r\n  KanbanBoard,\r\n  KanbanColumn,\r\n  KanbanColumnHandle,\r\n  KanbanItem,\r\n  KanbanItemHandle,\r\n  KanbanOverlay,\r\n  //\r\n  KanbanRoot as Root,\r\n  KanbanBoard as Board,\r\n  KanbanColumn as Column,\r\n  KanbanColumnHandle as ColumnHandle,\r\n  KanbanItem as Item,\r\n  KanbanItemHandle as ItemHandle,\r\n  KanbanOverlay as Overlay\r\n};\r\n","usedDeprecatedRules":[]}]
